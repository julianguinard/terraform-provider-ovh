// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package ovh

import (
	"context"
	"encoding/json"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	ovhtypes "github.com/ovh/terraform-provider-ovh/ovh/types"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
)

func CloudProjectAiAppResourceSchema(ctx context.Context) schema.Schema {
	attrs := map[string]schema.Attribute{
		"app_id": schema.StringAttribute{
			CustomType:          ovhtypes.TfStringType{},
			Optional:            true,
			Computed:            true,
			Description:         "App ID",
			MarkdownDescription: "App ID",
		},
		"command": schema.ListAttribute{
			CustomType:          ovhtypes.NewTfListNestedType[ovhtypes.TfStringValue](ctx),
			Optional:            true,
			Computed:            true,
			Description:         "App command",
			MarkdownDescription: "App command",
		},
		"cpu": schema.Int64Attribute{
			CustomType:          ovhtypes.TfInt64Type{},
			Optional:            true,
			Description:         "Number of CPU resources requested (applies to CPU flavors)",
			MarkdownDescription: "Number of CPU resources requested (applies to CPU flavors)",
		},
		"created_at": schema.StringAttribute{
			CustomType:          ovhtypes.TfStringType{},
			Computed:            true,
			Description:         "App creation date",
			MarkdownDescription: "App creation date",
		},
		"default_http_port": schema.Int64Attribute{
			CustomType:          ovhtypes.TfInt64Type{},
			Optional:            true,
			Computed:            true,
			Description:         "Default port to access http service inside the app",
			MarkdownDescription: "Default port to access http service inside the app",
		},
		"deployment_strategy": schema.SingleNestedAttribute{
			Attributes: map[string]schema.Attribute{
				"max_surge": schema.StringAttribute{
					CustomType:          ovhtypes.TfStringType{},
					Optional:            true,
					Computed:            true,
					Description:         "Maximum number of replicas that can be created over the desired number of Pods (can be expressed as a percentage of the desired pods, suffixed with '%')",
					MarkdownDescription: "Maximum number of replicas that can be created over the desired number of Pods (can be expressed as a percentage of the desired pods, suffixed with '%')",
				},
				"max_unavailable": schema.StringAttribute{
					CustomType:          ovhtypes.TfStringType{},
					Optional:            true,
					Computed:            true,
					Description:         "Maximum number of replicas that can be unavailable during the update process (can be expressed as a percentage of the desired pods, suffixed with '%')",
					MarkdownDescription: "Maximum number of replicas that can be unavailable during the update process (can be expressed as a percentage of the desired pods, suffixed with '%')",
				},
				"progress_deadline_seconds": schema.Int64Attribute{
					CustomType:          ovhtypes.TfInt64Type{},
					Optional:            true,
					Computed:            true,
					Description:         "Number of seconds you want to wait for your Deployment to progress before the system reports back that the Deployment has failed progressing",
					MarkdownDescription: "Number of seconds you want to wait for your Deployment to progress before the system reports back that the Deployment has failed progressing",
				},
			},
			CustomType: DeploymentStrategyType{
				ObjectType: types.ObjectType{
					AttrTypes: DeploymentStrategyValue{}.AttributeTypes(ctx),
				},
			},
			Optional:            true,
			Computed:            true,
			Description:         "AI App deployment strategy",
			MarkdownDescription: "AI App deployment strategy",
		},
		"env_vars": schema.ListNestedAttribute{
			NestedObject: schema.NestedAttributeObject{
				Attributes: map[string]schema.Attribute{
					"name": schema.StringAttribute{
						CustomType:          ovhtypes.TfStringType{},
						Required:            true,
						Description:         "Name of the environment variable to set inside the job",
						MarkdownDescription: "Name of the environment variable to set inside the job",
					},
					"value": schema.StringAttribute{
						CustomType:          ovhtypes.TfStringType{},
						Required:            true,
						Description:         "Value of the environment variable to set inside the job",
						MarkdownDescription: "Value of the environment variable to set inside the job",
					},
				},
				CustomType: EnvVarsType{
					ObjectType: types.ObjectType{
						AttrTypes: EnvVarsValue{}.AttributeTypes(ctx),
					},
				},
			},
			CustomType:          ovhtypes.NewTfListNestedType[EnvVarsValue](ctx),
			Optional:            true,
			Computed:            true,
			Description:         "List of environment variable to be set inside the app",
			MarkdownDescription: "List of environment variable to be set inside the app",
		},
		"flavor": schema.StringAttribute{
			CustomType:          ovhtypes.TfStringType{},
			Optional:            true,
			Description:         "App instance flavor",
			MarkdownDescription: "App instance flavor",
		},
		"gpu": schema.Int64Attribute{
			CustomType:          ovhtypes.TfInt64Type{},
			Optional:            true,
			Description:         "Number of GPU resources requested (applies to GPU flavors)",
			MarkdownDescription: "Number of GPU resources requested (applies to GPU flavors)",
		},
		"grpc_port": schema.Int64Attribute{
			CustomType:          ovhtypes.TfInt64Type{},
			Optional:            true,
			Computed:            true,
			Description:         "GRPC Port that we want to expose in case workload HTTP & gRPC servers cannot be multiplexed to listen on the same port",
			MarkdownDescription: "GRPC Port that we want to expose in case workload HTTP & gRPC servers cannot be multiplexed to listen on the same port",
		},
		"id": schema.StringAttribute{
			CustomType:          ovhtypes.TfStringType{},
			Computed:            true,
			Description:         "App Id",
			MarkdownDescription: "App Id",
		},
		"image": schema.StringAttribute{
			CustomType:          ovhtypes.TfStringType{},
			Required:            true,
			Description:         "Docker or capability image to use in the app. App capability images must comply with the pattern 'image-id:version'",
			MarkdownDescription: "Docker or capability image to use in the app. App capability images must comply with the pattern 'image-id:version'",
		},
		"labels": schema.MapAttribute{
			CustomType:          ovhtypes.NewTfMapNestedType[ovhtypes.TfStringValue](ctx),
			Optional:            true,
			Computed:            true,
			Description:         "Labels are used to scope tokens, labels prefixed by 'ovh/' are owned by the platform and overridden",
			MarkdownDescription: "Labels are used to scope tokens, labels prefixed by 'ovh/' are owned by the platform and overridden",
		},
		"name": schema.StringAttribute{
			CustomType:          ovhtypes.TfStringType{},
			Optional:            true,
			Computed:            true,
			Description:         "App name",
			MarkdownDescription: "App name",
		},
		"partner_id": schema.StringAttribute{
			CustomType:          ovhtypes.TfStringType{},
			Optional:            true,
			Computed:            true,
			Description:         "Partner ID",
			MarkdownDescription: "Partner ID",
		},
		"probe": schema.SingleNestedAttribute{
			Attributes: map[string]schema.Attribute{
				"path": schema.StringAttribute{
					CustomType:          ovhtypes.TfStringType{},
					Optional:            true,
					Computed:            true,
					Description:         "Path to access to check for readiness",
					MarkdownDescription: "Path to access to check for readiness",
				},
				"port": schema.Int64Attribute{
					CustomType:          ovhtypes.TfInt64Type{},
					Optional:            true,
					Computed:            true,
					Description:         "Port to access to check for readiness",
					MarkdownDescription: "Port to access to check for readiness",
				},
			},
			CustomType: ProbeType{
				ObjectType: types.ObjectType{
					AttrTypes: ProbeValue{}.AttributeTypes(ctx),
				},
			},
			Optional:            true,
			Computed:            true,
			Description:         "App readiness probe",
			MarkdownDescription: "App readiness probe",
		},
		"region": schema.StringAttribute{
			CustomType:          ovhtypes.TfStringType{},
			Required:            true,
			Description:         "Host region of the app",
			MarkdownDescription: "Host region of the app",
		},
		"resources": schema.SingleNestedAttribute{
			Attributes: map[string]schema.Attribute{
				"cpu": schema.Int64Attribute{
					CustomType:          ovhtypes.TfInt64Type{},
					Optional:            true,
					Computed:            true,
					Description:         "Number of vCPU resources requested",
					MarkdownDescription: "Number of vCPU resources requested",
				},
				"ephemeral_storage": schema.Int64Attribute{
					CustomType:          ovhtypes.TfInt64Type{},
					Optional:            true,
					Computed:            true,
					Description:         "The amount of ephemeral storage in bytes",
					MarkdownDescription: "The amount of ephemeral storage in bytes",
				},
				"flavor": schema.StringAttribute{
					CustomType:          ovhtypes.TfStringType{},
					Optional:            true,
					Computed:            true,
					Description:         "Instance flavor",
					MarkdownDescription: "Instance flavor",
				},
				"gpu": schema.Int64Attribute{
					CustomType:          ovhtypes.TfInt64Type{},
					Optional:            true,
					Computed:            true,
					Description:         "Number of GPU resources requested",
					MarkdownDescription: "Number of GPU resources requested",
				},
				"gpu_brand": schema.StringAttribute{
					CustomType:          ovhtypes.TfStringType{},
					Optional:            true,
					Computed:            true,
					Description:         "The GPU Brand",
					MarkdownDescription: "The GPU Brand",
				},
				"gpu_memory": schema.Int64Attribute{
					CustomType:          ovhtypes.TfInt64Type{},
					Optional:            true,
					Computed:            true,
					Description:         "The GPU Memory in bytes",
					MarkdownDescription: "The GPU Memory in bytes",
				},
				"gpu_model": schema.StringAttribute{
					CustomType:          ovhtypes.TfStringType{},
					Optional:            true,
					Computed:            true,
					Description:         "The GPU Model",
					MarkdownDescription: "The GPU Model",
				},
				"memory": schema.Int64Attribute{
					CustomType:          ovhtypes.TfInt64Type{},
					Optional:            true,
					Computed:            true,
					Description:         "The amount of memory in bytes",
					MarkdownDescription: "The amount of memory in bytes",
				},
				"private_network": schema.Int64Attribute{
					CustomType:          ovhtypes.TfInt64Type{},
					Optional:            true,
					Computed:            true,
					Description:         "The private network bandwidth in bits per seconds",
					MarkdownDescription: "The private network bandwidth in bits per seconds",
				},
				"public_network": schema.Int64Attribute{
					CustomType:          ovhtypes.TfInt64Type{},
					Optional:            true,
					Computed:            true,
					Description:         "The public network bandwidth in bits per seconds",
					MarkdownDescription: "The public network bandwidth in bits per seconds",
				},
			},
			CustomType: ResourcesType{
				ObjectType: types.ObjectType{
					AttrTypes: ResourcesValue{}.AttributeTypes(ctx),
				},
			},
			Required:            true,
			Description:         "App resources",
			MarkdownDescription: "App resources",
		},
		"scaling_strategy": schema.SingleNestedAttribute{
			Attributes: map[string]schema.Attribute{
				"automatic": schema.SingleNestedAttribute{
					Attributes: map[string]schema.Attribute{
						"average_usage_target": schema.Int64Attribute{
							CustomType:          ovhtypes.TfInt64Type{},
							Optional:            true,
							Computed:            true,
							Description:         "The average resource usage threshold that the app upscale or downscale will be triggered from, in percent",
							MarkdownDescription: "The average resource usage threshold that the app upscale or downscale will be triggered from, in percent",
						},
						"replicas_max": schema.Int64Attribute{
							CustomType:          ovhtypes.TfInt64Type{},
							Optional:            true,
							Computed:            true,
							Description:         "Maximum number of replicas",
							MarkdownDescription: "Maximum number of replicas",
						},
						"replicas_min": schema.Int64Attribute{
							CustomType:          ovhtypes.TfInt64Type{},
							Optional:            true,
							Computed:            true,
							Description:         "Minimum number of replicas",
							MarkdownDescription: "Minimum number of replicas",
						},
						"resource_type": schema.StringAttribute{
							CustomType:          ovhtypes.TfStringType{},
							Optional:            true,
							Computed:            true,
							Description:         "Type of the resource to base the automatic scaling on",
							MarkdownDescription: "Type of the resource to base the automatic scaling on",
							Validators: []validator.String{
								stringvalidator.OneOf(
									"CPU",
									"RAM",
								),
							},
						},
					},
					CustomType: ScalingStrategyAutomaticType{
						ObjectType: types.ObjectType{
							AttrTypes: ScalingStrategyAutomaticValue{}.AttributeTypes(ctx),
						},
					},
					Optional:            true,
					Computed:            true,
					Description:         "Strategy setting a variable number of replicas, based on an average resource usage threshold (conflicts with 'fixed' property when both are not null)",
					MarkdownDescription: "Strategy setting a variable number of replicas, based on an average resource usage threshold (conflicts with 'fixed' property when both are not null)",
				},
				"fixed": schema.SingleNestedAttribute{
					Attributes: map[string]schema.Attribute{
						"replicas": schema.Int64Attribute{
							CustomType:          ovhtypes.TfInt64Type{},
							Optional:            true,
							Computed:            true,
							Description:         "Number of wanted replicas",
							MarkdownDescription: "Number of wanted replicas",
						},
					},
					CustomType: ScalingStrategyFixedType{
						ObjectType: types.ObjectType{
							AttrTypes: ScalingStrategyFixedValue{}.AttributeTypes(ctx),
						},
					},
					Optional:            true,
					Computed:            true,
					Description:         "Strategy setting a fix number of replicas (conflicts with 'automatic' property when both are not null)",
					MarkdownDescription: "Strategy setting a fix number of replicas (conflicts with 'automatic' property when both are not null)",
				},
			},
			CustomType: ScalingStrategyType{
				ObjectType: types.ObjectType{
					AttrTypes: ScalingStrategyValue{}.AttributeTypes(ctx),
				},
			},
			Optional:            true,
			Computed:            true,
			Description:         "App scaling strategy",
			MarkdownDescription: "App scaling strategy",
		},
		"service_name": schema.StringAttribute{
			CustomType:          ovhtypes.TfStringType{},
			Required:            true,
			Description:         "Service name",
			MarkdownDescription: "Service name",
		},
		"spec": schema.SingleNestedAttribute{
			Attributes: map[string]schema.Attribute{
				"command": schema.ListAttribute{
					CustomType:          ovhtypes.NewTfListNestedType[ovhtypes.TfStringValue](ctx),
					Computed:            true,
					Description:         "App command",
					MarkdownDescription: "App command",
				},
				"default_http_port": schema.Int64Attribute{
					CustomType:          ovhtypes.TfInt64Type{},
					Computed:            true,
					Description:         "Default port to access the http service inside the app",
					MarkdownDescription: "Default port to access the http service inside the app",
				},
				"deployment_strategy": schema.SingleNestedAttribute{
					Attributes: map[string]schema.Attribute{
						"max_surge": schema.StringAttribute{
							CustomType:          ovhtypes.TfStringType{},
							Computed:            true,
							Description:         "Maximum number of replicas that can be created over the desired number of Pods (can be expressed as a percentage of the desired pods, suffixed with '%')",
							MarkdownDescription: "Maximum number of replicas that can be created over the desired number of Pods (can be expressed as a percentage of the desired pods, suffixed with '%')",
						},
						"max_unavailable": schema.StringAttribute{
							CustomType:          ovhtypes.TfStringType{},
							Computed:            true,
							Description:         "Maximum number of replicas that can be unavailable during the update process (can be expressed as a percentage of the desired pods, suffixed with '%')",
							MarkdownDescription: "Maximum number of replicas that can be unavailable during the update process (can be expressed as a percentage of the desired pods, suffixed with '%')",
						},
						"progress_deadline_seconds": schema.Int64Attribute{
							CustomType:          ovhtypes.TfInt64Type{},
							Computed:            true,
							Description:         "Number of seconds you want to wait for your Deployment to progress before the system reports back that the Deployment has failed progressing",
							MarkdownDescription: "Number of seconds you want to wait for your Deployment to progress before the system reports back that the Deployment has failed progressing",
						},
					},
					CustomType: SpecDeploymentStrategyType{
						ObjectType: types.ObjectType{
							AttrTypes: SpecDeploymentStrategyValue{}.AttributeTypes(ctx),
						},
					},
					Computed:            true,
					Description:         "AI App deployment strategy",
					MarkdownDescription: "AI App deployment strategy",
				},
				"env_vars": schema.ListNestedAttribute{
					NestedObject: schema.NestedAttributeObject{
						Attributes: map[string]schema.Attribute{
							"name": schema.StringAttribute{
								CustomType:          ovhtypes.TfStringType{},
								Computed:            true,
								Description:         "Name of the environment variable to set inside the job",
								MarkdownDescription: "Name of the environment variable to set inside the job",
							},
							"value": schema.StringAttribute{
								CustomType:          ovhtypes.TfStringType{},
								Computed:            true,
								Description:         "Value of the environment variable to set inside the job",
								MarkdownDescription: "Value of the environment variable to set inside the job",
							},
						},
						CustomType: SpecEnvVarsType{
							ObjectType: types.ObjectType{
								AttrTypes: SpecEnvVarsValue{}.AttributeTypes(ctx),
							},
						},
					},
					CustomType:          ovhtypes.NewTfListNestedType[SpecEnvVarsValue](ctx),
					Computed:            true,
					Description:         "List of environment variable to be set inside the app",
					MarkdownDescription: "List of environment variable to be set inside the app",
				},
				"grpc_port": schema.Int64Attribute{
					CustomType:          ovhtypes.TfInt64Type{},
					Computed:            true,
					Description:         "GRPC Port that we want to expose in case workload HTTP & gRPC servers cannot be multiplexed to listen on the same port",
					MarkdownDescription: "GRPC Port that we want to expose in case workload HTTP & gRPC servers cannot be multiplexed to listen on the same port",
				},
				"image": schema.StringAttribute{
					CustomType:          ovhtypes.TfStringType{},
					Computed:            true,
					Description:         "App image",
					MarkdownDescription: "App image",
				},
				"labels": schema.MapAttribute{
					CustomType:          ovhtypes.NewTfMapNestedType[ovhtypes.TfStringValue](ctx),
					Computed:            true,
					Description:         "Labels for the app",
					MarkdownDescription: "Labels for the app",
				},
				"name": schema.StringAttribute{
					CustomType:          ovhtypes.TfStringType{},
					Computed:            true,
					Description:         "App name",
					MarkdownDescription: "App name",
				},
				"partner_id": schema.StringAttribute{
					CustomType:          ovhtypes.TfStringType{},
					Computed:            true,
					Description:         "Partner ID",
					MarkdownDescription: "Partner ID",
				},
				"probe": schema.SingleNestedAttribute{
					Attributes: map[string]schema.Attribute{
						"path": schema.StringAttribute{
							CustomType:          ovhtypes.TfStringType{},
							Computed:            true,
							Description:         "Path to access to check for readiness",
							MarkdownDescription: "Path to access to check for readiness",
						},
						"port": schema.Int64Attribute{
							CustomType:          ovhtypes.TfInt64Type{},
							Computed:            true,
							Description:         "Port to access to check for readiness",
							MarkdownDescription: "Port to access to check for readiness",
						},
					},
					CustomType: SpecProbeType{
						ObjectType: types.ObjectType{
							AttrTypes: SpecProbeValue{}.AttributeTypes(ctx),
						},
					},
					Computed:            true,
					Description:         "App readiness probe",
					MarkdownDescription: "App readiness probe",
				},
				"region": schema.StringAttribute{
					CustomType:          ovhtypes.TfStringType{},
					Computed:            true,
					Description:         "Host region of the app",
					MarkdownDescription: "Host region of the app",
				},
				"resources": schema.SingleNestedAttribute{
					Attributes: map[string]schema.Attribute{
						"cpu": schema.Int64Attribute{
							CustomType:          ovhtypes.TfInt64Type{},
							Computed:            true,
							Description:         "Number of vCPU resources requested",
							MarkdownDescription: "Number of vCPU resources requested",
						},
						"ephemeral_storage": schema.Int64Attribute{
							CustomType:          ovhtypes.TfInt64Type{},
							Computed:            true,
							Description:         "The amount of ephemeral storage in bytes",
							MarkdownDescription: "The amount of ephemeral storage in bytes",
						},
						"flavor": schema.StringAttribute{
							CustomType:          ovhtypes.TfStringType{},
							Computed:            true,
							Description:         "Current instance flavor",
							MarkdownDescription: "Current instance flavor",
						},
						"gpu": schema.Int64Attribute{
							CustomType:          ovhtypes.TfInt64Type{},
							Computed:            true,
							Description:         "Number of GPU resources requested",
							MarkdownDescription: "Number of GPU resources requested",
						},
						"gpu_brand": schema.StringAttribute{
							CustomType:          ovhtypes.TfStringType{},
							Computed:            true,
							Description:         "The GPU Brand",
							MarkdownDescription: "The GPU Brand",
						},
						"gpu_memory": schema.Int64Attribute{
							CustomType:          ovhtypes.TfInt64Type{},
							Computed:            true,
							Description:         "The GPU Memory in bits",
							MarkdownDescription: "The GPU Memory in bits",
						},
						"gpu_model": schema.StringAttribute{
							CustomType:          ovhtypes.TfStringType{},
							Computed:            true,
							Description:         "The GPU Model",
							MarkdownDescription: "The GPU Model",
						},
						"memory": schema.Int64Attribute{
							CustomType:          ovhtypes.TfInt64Type{},
							Computed:            true,
							Description:         "The amount of memory in bytes",
							MarkdownDescription: "The amount of memory in bytes",
						},
						"private_network": schema.Int64Attribute{
							CustomType:          ovhtypes.TfInt64Type{},
							Computed:            true,
							Description:         "The guarantee private bandwidth in bytes per seconds",
							MarkdownDescription: "The guarantee private bandwidth in bytes per seconds",
						},
						"public_network": schema.Int64Attribute{
							CustomType:          ovhtypes.TfInt64Type{},
							Computed:            true,
							Description:         "The guarantee public bandwidth in bytes per seconds",
							MarkdownDescription: "The guarantee public bandwidth in bytes per seconds",
						},
					},
					CustomType: SpecResourcesType{
						ObjectType: types.ObjectType{
							AttrTypes: SpecResourcesValue{}.AttributeTypes(ctx),
						},
					},
					Computed:            true,
					Description:         "App resources",
					MarkdownDescription: "App resources",
				},
				"scaling_strategy": schema.SingleNestedAttribute{
					Attributes: map[string]schema.Attribute{
						"automatic": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"average_usage_target": schema.Int64Attribute{
									CustomType:          ovhtypes.TfInt64Type{},
									Computed:            true,
									Description:         "The average resource usage threshold that the app upscale or downscale will be triggered from, in percent",
									MarkdownDescription: "The average resource usage threshold that the app upscale or downscale will be triggered from, in percent",
								},
								"replicas_max": schema.Int64Attribute{
									CustomType:          ovhtypes.TfInt64Type{},
									Computed:            true,
									Description:         "Maximum number of replicas",
									MarkdownDescription: "Maximum number of replicas",
								},
								"replicas_min": schema.Int64Attribute{
									CustomType:          ovhtypes.TfInt64Type{},
									Computed:            true,
									Description:         "Minimum number of replicas",
									MarkdownDescription: "Minimum number of replicas",
								},
								"resource_type": schema.StringAttribute{
									CustomType:          ovhtypes.TfStringType{},
									Computed:            true,
									Description:         "Type of the resource to base the automatic scaling on",
									MarkdownDescription: "Type of the resource to base the automatic scaling on",
								},
							},
							CustomType: SpecScalingStrategyAutomaticType{
								ObjectType: types.ObjectType{
									AttrTypes: SpecScalingStrategyAutomaticValue{}.AttributeTypes(ctx),
								},
							},
							Computed:            true,
							Description:         "Strategy setting a variable number of replicas, based on an average resource usage threshold",
							MarkdownDescription: "Strategy setting a variable number of replicas, based on an average resource usage threshold",
						},
						"fixed": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"replicas": schema.Int64Attribute{
									CustomType:          ovhtypes.TfInt64Type{},
									Computed:            true,
									Description:         "Number of wanted replicas",
									MarkdownDescription: "Number of wanted replicas",
								},
							},
							CustomType: SpecScalingStrategyFixedType{
								ObjectType: types.ObjectType{
									AttrTypes: SpecScalingStrategyFixedValue{}.AttributeTypes(ctx),
								},
							},
							Computed:            true,
							Description:         "Strategy setting a fix number of replicas",
							MarkdownDescription: "Strategy setting a fix number of replicas",
						},
					},
					CustomType: SpecScalingStrategyType{
						ObjectType: types.ObjectType{
							AttrTypes: SpecScalingStrategyValue{}.AttributeTypes(ctx),
						},
					},
					Computed:            true,
					Description:         "App scaling strategy",
					MarkdownDescription: "App scaling strategy",
				},
				"unsecure_http": schema.BoolAttribute{
					CustomType:          ovhtypes.TfBoolType{},
					Computed:            true,
					Description:         "True if app api port can be accessed without any authentication token, false otherwise",
					MarkdownDescription: "True if app api port can be accessed without any authentication token, false otherwise",
				},
				"volumes": schema.ListNestedAttribute{
					NestedObject: schema.NestedAttributeObject{
						Attributes: map[string]schema.Attribute{
							"cache": schema.BoolAttribute{
								CustomType:          ovhtypes.TfBoolType{},
								Computed:            true,
								Description:         "Enable/disable volume caching",
								MarkdownDescription: "Enable/disable volume caching",
							},
							"container": schema.StringAttribute{
								CustomType:          ovhtypes.TfStringType{},
								Computed:            true,
								Description:         "Public Cloud Storage container to attach",
								MarkdownDescription: "Public Cloud Storage container to attach",
							},
							"data_store": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{
									"alias": schema.StringAttribute{
										CustomType:          ovhtypes.TfStringType{},
										Computed:            true,
										Description:         "Data store alias",
										MarkdownDescription: "Data store alias",
									},
									"archive": schema.StringAttribute{
										CustomType:          ovhtypes.TfStringType{},
										Computed:            true,
										Description:         "Name of the tar archive that needs to be saved",
										MarkdownDescription: "Name of the tar archive that needs to be saved",
									},
									"container": schema.StringAttribute{
										CustomType:          ovhtypes.TfStringType{},
										Computed:            true,
										Description:         "Data store container to attach",
										MarkdownDescription: "Data store container to attach",
									},
									"internal": schema.BoolAttribute{
										CustomType:          ovhtypes.TfBoolType{},
										Computed:            true,
										Description:         "True if data is stored on OVHcloud AI's internal storage",
										MarkdownDescription: "True if data is stored on OVHcloud AI's internal storage",
									},
									"prefix": schema.StringAttribute{
										CustomType:          ovhtypes.TfStringType{},
										Computed:            true,
										Description:         "Prefix to fetch only part of the volume",
										MarkdownDescription: "Prefix to fetch only part of the volume",
									},
								},
								CustomType: SpecVolumesDataStoreType{
									ObjectType: types.ObjectType{
										AttrTypes: SpecVolumesDataStoreValue{}.AttributeTypes(ctx),
									},
								},
								Computed:            true,
								Description:         "Volume details for data store containers. Deprecated: Use volumeSource.dataStore instead",
								MarkdownDescription: "Volume details for data store containers. Deprecated: Use volumeSource.dataStore instead",
							},
							"id": schema.StringAttribute{
								CustomType:          ovhtypes.TfStringType{},
								Computed:            true,
								Description:         "Volume Id. Deprecated: moved to status.volumes[]",
								MarkdownDescription: "Volume Id. Deprecated: moved to status.volumes[]",
							},
							"mount_path": schema.StringAttribute{
								CustomType:          ovhtypes.TfStringType{},
								Computed:            true,
								Description:         "Path where to mount the data inside the container",
								MarkdownDescription: "Path where to mount the data inside the container",
							},
							"permission": schema.StringAttribute{
								CustomType:          ovhtypes.TfStringType{},
								Computed:            true,
								Description:         "Permissions to use on the mounted volume",
								MarkdownDescription: "Permissions to use on the mounted volume",
							},
							"prefix": schema.StringAttribute{
								CustomType:          ovhtypes.TfStringType{},
								Computed:            true,
								Description:         "Prefix to fetch only part of the volume",
								MarkdownDescription: "Prefix to fetch only part of the volume",
							},
							"private_swift": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{
									"archive": schema.StringAttribute{
										CustomType:          ovhtypes.TfStringType{},
										Computed:            true,
										Description:         "Name of the tar archive that needs to be saved",
										MarkdownDescription: "Name of the tar archive that needs to be saved",
									},
									"container": schema.StringAttribute{
										CustomType:          ovhtypes.TfStringType{},
										Computed:            true,
										Description:         "Public Cloud Storage container to attach",
										MarkdownDescription: "Public Cloud Storage container to attach",
									},
									"internal": schema.BoolAttribute{
										CustomType:          ovhtypes.TfBoolType{},
										Computed:            true,
										Description:         "True if data is stored on OVHcloud AI's internal storage",
										MarkdownDescription: "True if data is stored on OVHcloud AI's internal storage",
									},
									"prefix": schema.StringAttribute{
										CustomType:          ovhtypes.TfStringType{},
										Computed:            true,
										Description:         "Prefix to fetch only part of the volume",
										MarkdownDescription: "Prefix to fetch only part of the volume",
									},
									"region": schema.StringAttribute{
										CustomType:          ovhtypes.TfStringType{},
										Computed:            true,
										Description:         "Public Cloud Storage Region",
										MarkdownDescription: "Public Cloud Storage Region",
									},
								},
								CustomType: SpecVolumesPrivateSwiftType{
									ObjectType: types.ObjectType{
										AttrTypes: SpecVolumesPrivateSwiftValue{}.AttributeTypes(ctx),
									},
								},
								Computed:            true,
								Description:         "Volume details for private swift containers. Deprecated: Use volumeSource.dataStore instead",
								MarkdownDescription: "Volume details for private swift containers. Deprecated: Use volumeSource.dataStore instead",
							},
							"public_git": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{
									"url": schema.StringAttribute{
										CustomType:          ovhtypes.TfStringType{},
										Computed:            true,
										Description:         "URL of the public git repository",
										MarkdownDescription: "URL of the public git repository",
									},
								},
								CustomType: SpecVolumesPublicGitType{
									ObjectType: types.ObjectType{
										AttrTypes: SpecVolumesPublicGitValue{}.AttributeTypes(ctx),
									},
								},
								Computed:            true,
								Description:         "Volume details for public git repositories. Deprecated: Use volumeSource.publicGit instead",
								MarkdownDescription: "Volume details for public git repositories. Deprecated: Use volumeSource.publicGit instead",
							},
							"public_swift": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{
									"url": schema.StringAttribute{
										CustomType:          ovhtypes.TfStringType{},
										Computed:            true,
										Description:         "URL of the public swift container",
										MarkdownDescription: "URL of the public swift container",
									},
								},
								CustomType: SpecVolumesPublicSwiftType{
									ObjectType: types.ObjectType{
										AttrTypes: SpecVolumesPublicSwiftValue{}.AttributeTypes(ctx),
									},
								},
								Computed:            true,
								Description:         "Volume details for public swift containers. Deprecated: Use volumeSource.publicSwift instead",
								MarkdownDescription: "Volume details for public swift containers. Deprecated: Use volumeSource.publicSwift instead",
							},
							"region": schema.StringAttribute{
								CustomType:          ovhtypes.TfStringType{},
								Computed:            true,
								Description:         "Public Cloud Storage Region",
								MarkdownDescription: "Public Cloud Storage Region",
							},
							"standalone": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{
									"name": schema.StringAttribute{
										CustomType:          ovhtypes.TfStringType{},
										Computed:            true,
										Description:         "Name of the volume",
										MarkdownDescription: "Name of the volume",
									},
								},
								CustomType: SpecVolumesStandaloneType{
									ObjectType: types.ObjectType{
										AttrTypes: SpecVolumesStandaloneValue{}.AttributeTypes(ctx),
									},
								},
								Computed:            true,
								Description:         "Volume details for volumes that do not have a datasource. Deprecated: Use volumeSource.standalone instead",
								MarkdownDescription: "Volume details for volumes that do not have a datasource. Deprecated: Use volumeSource.standalone instead",
							},
							"target_data_store": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{
									"alias": schema.StringAttribute{
										CustomType:          ovhtypes.TfStringType{},
										Computed:            true,
										Description:         "Data store alias",
										MarkdownDescription: "Data store alias",
									},
									"archive": schema.StringAttribute{
										CustomType:          ovhtypes.TfStringType{},
										Computed:            true,
										Description:         "Name of the tar archive that needs to be saved",
										MarkdownDescription: "Name of the tar archive that needs to be saved",
									},
									"container": schema.StringAttribute{
										CustomType:          ovhtypes.TfStringType{},
										Computed:            true,
										Description:         "Data store container to attach",
										MarkdownDescription: "Data store container to attach",
									},
									"internal": schema.BoolAttribute{
										CustomType:          ovhtypes.TfBoolType{},
										Computed:            true,
										Description:         "True if data is stored on OVHcloud AI's internal storage",
										MarkdownDescription: "True if data is stored on OVHcloud AI's internal storage",
									},
									"prefix": schema.StringAttribute{
										CustomType:          ovhtypes.TfStringType{},
										Computed:            true,
										Description:         "Prefix to fetch only part of the volume",
										MarkdownDescription: "Prefix to fetch only part of the volume",
									},
								},
								CustomType: SpecVolumesTargetDataStoreType{
									ObjectType: types.ObjectType{
										AttrTypes: SpecVolumesTargetDataStoreValue{}.AttributeTypes(ctx),
									},
								},
								Computed:            true,
								Description:         "Target volume details for data store containers. Deprecated: Use volumeTarget.targetDataStore instead",
								MarkdownDescription: "Target volume details for data store containers. Deprecated: Use volumeTarget.targetDataStore instead",
							},
							"target_private_swift": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{
									"archive": schema.StringAttribute{
										CustomType:          ovhtypes.TfStringType{},
										Computed:            true,
										Description:         "Name of the tar archive that needs to be saved",
										MarkdownDescription: "Name of the tar archive that needs to be saved",
									},
									"container": schema.StringAttribute{
										CustomType:          ovhtypes.TfStringType{},
										Computed:            true,
										Description:         "Public Cloud Storage container to attach",
										MarkdownDescription: "Public Cloud Storage container to attach",
									},
									"internal": schema.BoolAttribute{
										CustomType:          ovhtypes.TfBoolType{},
										Computed:            true,
										Description:         "True if data is stored on OVHcloud AI's internal storage",
										MarkdownDescription: "True if data is stored on OVHcloud AI's internal storage",
									},
									"prefix": schema.StringAttribute{
										CustomType:          ovhtypes.TfStringType{},
										Computed:            true,
										Description:         "Prefix to fetch only part of the volume",
										MarkdownDescription: "Prefix to fetch only part of the volume",
									},
									"region": schema.StringAttribute{
										CustomType:          ovhtypes.TfStringType{},
										Computed:            true,
										Description:         "Public Cloud Storage Region",
										MarkdownDescription: "Public Cloud Storage Region",
									},
								},
								CustomType: SpecVolumesTargetPrivateSwiftType{
									ObjectType: types.ObjectType{
										AttrTypes: SpecVolumesTargetPrivateSwiftValue{}.AttributeTypes(ctx),
									},
								},
								Computed:            true,
								Description:         "Target volume details for private swift containers. Deprecated: Use volumeTarget.targetDataStore instead",
								MarkdownDescription: "Target volume details for private swift containers. Deprecated: Use volumeTarget.targetDataStore instead",
							},
							"volume_source": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{
									"data_store": schema.SingleNestedAttribute{
										Attributes: map[string]schema.Attribute{
											"alias": schema.StringAttribute{
												CustomType:          ovhtypes.TfStringType{},
												Computed:            true,
												Description:         "Data store alias",
												MarkdownDescription: "Data store alias",
											},
											"archive": schema.StringAttribute{
												CustomType:          ovhtypes.TfStringType{},
												Computed:            true,
												Description:         "Name of the tar archive that needs to be saved",
												MarkdownDescription: "Name of the tar archive that needs to be saved",
											},
											"container": schema.StringAttribute{
												CustomType:          ovhtypes.TfStringType{},
												Computed:            true,
												Description:         "Data store container to attach",
												MarkdownDescription: "Data store container to attach",
											},
											"internal": schema.BoolAttribute{
												CustomType:          ovhtypes.TfBoolType{},
												Computed:            true,
												Description:         "True if data is stored on OVHcloud AI's internal storage",
												MarkdownDescription: "True if data is stored on OVHcloud AI's internal storage",
											},
											"prefix": schema.StringAttribute{
												CustomType:          ovhtypes.TfStringType{},
												Computed:            true,
												Description:         "Prefix to fetch only part of the volume",
												MarkdownDescription: "Prefix to fetch only part of the volume",
											},
										},
										CustomType: SpecVolumesVolumeSourceDataStoreType{
											ObjectType: types.ObjectType{
												AttrTypes: SpecVolumesVolumeSourceDataStoreValue{}.AttributeTypes(ctx),
											},
										},
										Computed:            true,
										Description:         "Volume details for data store containers",
										MarkdownDescription: "Volume details for data store containers",
									},
									"public_git": schema.SingleNestedAttribute{
										Attributes: map[string]schema.Attribute{
											"url": schema.StringAttribute{
												CustomType:          ovhtypes.TfStringType{},
												Computed:            true,
												Description:         "URL of the public git repository",
												MarkdownDescription: "URL of the public git repository",
											},
										},
										CustomType: SpecVolumesVolumeSourcePublicGitType{
											ObjectType: types.ObjectType{
												AttrTypes: SpecVolumesVolumeSourcePublicGitValue{}.AttributeTypes(ctx),
											},
										},
										Computed:            true,
										Description:         "Volume details for public git repositories",
										MarkdownDescription: "Volume details for public git repositories",
									},
									"public_swift": schema.SingleNestedAttribute{
										Attributes: map[string]schema.Attribute{
											"url": schema.StringAttribute{
												CustomType:          ovhtypes.TfStringType{},
												Computed:            true,
												Description:         "URL of the public swift container",
												MarkdownDescription: "URL of the public swift container",
											},
										},
										CustomType: SpecVolumesVolumeSourcePublicSwiftType{
											ObjectType: types.ObjectType{
												AttrTypes: SpecVolumesVolumeSourcePublicSwiftValue{}.AttributeTypes(ctx),
											},
										},
										Computed:            true,
										Description:         "Volume details for public swift containers",
										MarkdownDescription: "Volume details for public swift containers",
									},
									"standalone": schema.SingleNestedAttribute{
										Attributes: map[string]schema.Attribute{
											"name": schema.StringAttribute{
												CustomType:          ovhtypes.TfStringType{},
												Computed:            true,
												Description:         "Name of the volume",
												MarkdownDescription: "Name of the volume",
											},
										},
										CustomType: SpecVolumesVolumeSourceStandaloneType{
											ObjectType: types.ObjectType{
												AttrTypes: SpecVolumesVolumeSourceStandaloneValue{}.AttributeTypes(ctx),
											},
										},
										Computed:            true,
										Description:         "Volume details for volumes that do not have a datasource",
										MarkdownDescription: "Volume details for volumes that do not have a datasource",
									},
								},
								CustomType: SpecVolumesVolumeSourceType{
									ObjectType: types.ObjectType{
										AttrTypes: SpecVolumesVolumeSourceValue{}.AttributeTypes(ctx),
									},
								},
								Computed:            true,
								Description:         "Source volume details",
								MarkdownDescription: "Source volume details",
							},
							"volume_target": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{
									"target_data_store": schema.SingleNestedAttribute{
										Attributes: map[string]schema.Attribute{
											"alias": schema.StringAttribute{
												CustomType:          ovhtypes.TfStringType{},
												Computed:            true,
												Description:         "Data store alias",
												MarkdownDescription: "Data store alias",
											},
											"archive": schema.StringAttribute{
												CustomType:          ovhtypes.TfStringType{},
												Computed:            true,
												Description:         "Name of the tar archive that needs to be saved",
												MarkdownDescription: "Name of the tar archive that needs to be saved",
											},
											"container": schema.StringAttribute{
												CustomType:          ovhtypes.TfStringType{},
												Computed:            true,
												Description:         "Data store container to attach",
												MarkdownDescription: "Data store container to attach",
											},
											"internal": schema.BoolAttribute{
												CustomType:          ovhtypes.TfBoolType{},
												Computed:            true,
												Description:         "True if data is stored on OVHcloud AI's internal storage",
												MarkdownDescription: "True if data is stored on OVHcloud AI's internal storage",
											},
											"prefix": schema.StringAttribute{
												CustomType:          ovhtypes.TfStringType{},
												Computed:            true,
												Description:         "Prefix to fetch only part of the volume",
												MarkdownDescription: "Prefix to fetch only part of the volume",
											},
										},
										CustomType: SpecVolumesVolumeTargetTargetDataStoreType{
											ObjectType: types.ObjectType{
												AttrTypes: SpecVolumesVolumeTargetTargetDataStoreValue{}.AttributeTypes(ctx),
											},
										},
										Computed:            true,
										Description:         "Volume details for data store containers",
										MarkdownDescription: "Volume details for data store containers",
									},
								},
								CustomType: SpecVolumesVolumeTargetType{
									ObjectType: types.ObjectType{
										AttrTypes: SpecVolumesVolumeTargetValue{}.AttributeTypes(ctx),
									},
								},
								Computed:            true,
								Description:         "Target volume details",
								MarkdownDescription: "Target volume details",
							},
						},
						CustomType: SpecVolumesType{
							ObjectType: types.ObjectType{
								AttrTypes: SpecVolumesValue{}.AttributeTypes(ctx),
							},
						},
					},
					CustomType:          ovhtypes.NewTfListNestedType[SpecVolumesValue](ctx),
					Computed:            true,
					Description:         "App Data linked",
					MarkdownDescription: "App Data linked",
				},
			},
			CustomType: SpecType{
				ObjectType: types.ObjectType{
					AttrTypes: SpecValue{}.AttributeTypes(ctx),
				},
			},
			Computed:            true,
			Description:         "App spec",
			MarkdownDescription: "App spec",
		},
		"status": schema.SingleNestedAttribute{
			Attributes: map[string]schema.Attribute{
				"available_replicas": schema.Int64Attribute{
					CustomType:          ovhtypes.TfInt64Type{},
					Computed:            true,
					Description:         "Number of available replicas",
					MarkdownDescription: "Number of available replicas",
				},
				"data_sync": schema.ListNestedAttribute{
					NestedObject: schema.NestedAttributeObject{
						Attributes: map[string]schema.Attribute{
							"created_at": schema.StringAttribute{
								CustomType:          ovhtypes.TfStringType{},
								Computed:            true,
								Description:         "Data Sync creation date",
								MarkdownDescription: "Data Sync creation date",
							},
							"id": schema.StringAttribute{
								CustomType:          ovhtypes.TfStringType{},
								Computed:            true,
								Description:         "Data Sync Id",
								MarkdownDescription: "Data Sync Id",
							},
							"spec": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{
									"direction": schema.StringAttribute{
										CustomType:          ovhtypes.TfStringType{},
										Computed:            true,
										Description:         "Direction of the sync",
										MarkdownDescription: "Direction of the sync",
									},
									"manual": schema.BoolAttribute{
										CustomType:          ovhtypes.TfBoolType{},
										Computed:            true,
										Description:         "True if the user has created the object",
										MarkdownDescription: "True if the user has created the object",
									},
									"volume": schema.StringAttribute{
										CustomType:          ovhtypes.TfStringType{},
										Computed:            true,
										Description:         "Only sync this volume",
										MarkdownDescription: "Only sync this volume",
									},
								},
								CustomType: StatusDataSyncSpecType{
									ObjectType: types.ObjectType{
										AttrTypes: StatusDataSyncSpecValue{}.AttributeTypes(ctx),
									},
								},
								Computed:            true,
								Description:         "Data Sync specifications",
								MarkdownDescription: "Data Sync specifications",
							},
							"status": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{
									"ended_at": schema.StringAttribute{
										CustomType:          ovhtypes.TfStringType{},
										Computed:            true,
										Description:         "Date when the data sync ended",
										MarkdownDescription: "Date when the data sync ended",
									},
									"info": schema.SingleNestedAttribute{
										Attributes: map[string]schema.Attribute{
											"code": schema.StringAttribute{
												CustomType:          ovhtypes.TfStringType{},
												Computed:            true,
												Description:         "Info code identifier",
												MarkdownDescription: "Info code identifier",
											},
											"message": schema.StringAttribute{
												CustomType:          ovhtypes.TfStringType{},
												Computed:            true,
												Description:         "Formatted message",
												MarkdownDescription: "Formatted message",
											},
										},
										CustomType: StatusDataSyncStatusInfoType{
											ObjectType: types.ObjectType{
												AttrTypes: StatusDataSyncStatusInfoValue{}.AttributeTypes(ctx),
											},
										},
										Computed:            true,
										Description:         "Information about the data sync",
										MarkdownDescription: "Information about the data sync",
									},
									"progress": schema.ListNestedAttribute{
										NestedObject: schema.NestedAttributeObject{
											Attributes: map[string]schema.Attribute{
												"completed": schema.Int64Attribute{
													CustomType:          ovhtypes.TfInt64Type{},
													Computed:            true,
													Description:         "Number of completed files",
													MarkdownDescription: "Number of completed files",
												},
												"created_at": schema.StringAttribute{
													CustomType:          ovhtypes.TfStringType{},
													Computed:            true,
													Description:         "Progress creation date",
													MarkdownDescription: "Progress creation date",
												},
												"deleted": schema.Int64Attribute{
													CustomType:          ovhtypes.TfInt64Type{},
													Computed:            true,
													Description:         "Number of deleted files",
													MarkdownDescription: "Number of deleted files",
												},
												"direction": schema.StringAttribute{
													CustomType:          ovhtypes.TfStringType{},
													Computed:            true,
													Description:         "Direction of the progress sync",
													MarkdownDescription: "Direction of the progress sync",
												},
												"eta": schema.Int64Attribute{
													CustomType:          ovhtypes.TfInt64Type{},
													Computed:            true,
													Description:         "ETA to finish in seconds. Deprecated",
													MarkdownDescription: "ETA to finish in seconds. Deprecated",
												},
												"failed": schema.Int64Attribute{
													CustomType:          ovhtypes.TfInt64Type{},
													Computed:            true,
													Description:         "Number of failed files",
													MarkdownDescription: "Number of failed files",
												},
												"id": schema.StringAttribute{
													CustomType:          ovhtypes.TfStringType{},
													Computed:            true,
													Description:         "Progress Id",
													MarkdownDescription: "Progress Id",
												},
												"info": schema.StringAttribute{
													CustomType:          ovhtypes.TfStringType{},
													Computed:            true,
													Description:         "Volume information",
													MarkdownDescription: "Volume information",
												},
												"processed": schema.Int64Attribute{
													CustomType:          ovhtypes.TfInt64Type{},
													Computed:            true,
													Description:         "Number of processed files",
													MarkdownDescription: "Number of processed files",
												},
												"skipped": schema.Int64Attribute{
													CustomType:          ovhtypes.TfInt64Type{},
													Computed:            true,
													Description:         "Number of skipped files",
													MarkdownDescription: "Number of skipped files",
												},
												"state": schema.StringAttribute{
													CustomType:          ovhtypes.TfStringType{},
													Computed:            true,
													Description:         "State of the progress sync",
													MarkdownDescription: "State of the progress sync",
												},
												"total": schema.Int64Attribute{
													CustomType:          ovhtypes.TfInt64Type{},
													Computed:            true,
													Description:         "Total number of files",
													MarkdownDescription: "Total number of files",
												},
												"transferred_bytes": schema.Int64Attribute{
													CustomType:          ovhtypes.TfInt64Type{},
													Computed:            true,
													Description:         "Transferred size in bytes",
													MarkdownDescription: "Transferred size in bytes",
												},
												"updated_at": schema.StringAttribute{
													CustomType:          ovhtypes.TfStringType{},
													Computed:            true,
													Description:         "Progress update date",
													MarkdownDescription: "Progress update date",
												},
											},
											CustomType: StatusDataSyncStatusProgressType{
												ObjectType: types.ObjectType{
													AttrTypes: StatusDataSyncStatusProgressValue{}.AttributeTypes(ctx),
												},
											},
										},
										CustomType:          ovhtypes.NewTfListNestedType[StatusDataSyncStatusProgressValue](ctx),
										Computed:            true,
										Description:         "Progress status of the data sync",
										MarkdownDescription: "Progress status of the data sync",
									},
									"queued_at": schema.StringAttribute{
										CustomType:          ovhtypes.TfStringType{},
										Computed:            true,
										Description:         "Date when the data sync was queued",
										MarkdownDescription: "Date when the data sync was queued",
									},
									"started_at": schema.StringAttribute{
										CustomType:          ovhtypes.TfStringType{},
										Computed:            true,
										Description:         "Date when the data sync was started",
										MarkdownDescription: "Date when the data sync was started",
									},
									"state": schema.StringAttribute{
										CustomType:          ovhtypes.TfStringType{},
										Computed:            true,
										Description:         "State of the data sync",
										MarkdownDescription: "State of the data sync",
									},
								},
								CustomType: StatusDataSyncStatusType{
									ObjectType: types.ObjectType{
										AttrTypes: StatusDataSyncStatusValue{}.AttributeTypes(ctx),
									},
								},
								Computed:            true,
								Description:         "Data Sync status",
								MarkdownDescription: "Data Sync status",
							},
							"updated_at": schema.StringAttribute{
								CustomType:          ovhtypes.TfStringType{},
								Computed:            true,
								Description:         "Data Sync update date",
								MarkdownDescription: "Data Sync update date",
							},
						},
						CustomType: StatusDataSyncType{
							ObjectType: types.ObjectType{
								AttrTypes: StatusDataSyncValue{}.AttributeTypes(ctx),
							},
						},
					},
					CustomType:          ovhtypes.NewTfListNestedType[StatusDataSyncValue](ctx),
					Computed:            true,
					Description:         "Status about the datasync linked to the app",
					MarkdownDescription: "Status about the datasync linked to the app",
				},
				"grpc_address": schema.StringAttribute{
					CustomType:          ovhtypes.TfStringType{},
					Computed:            true,
					Description:         "Address to reach when you want to access the App's gRPC services",
					MarkdownDescription: "Address to reach when you want to access the App's gRPC services",
				},
				"history": schema.ListNestedAttribute{
					NestedObject: schema.NestedAttributeObject{
						Attributes: map[string]schema.Attribute{
							"date": schema.StringAttribute{
								CustomType:          ovhtypes.TfStringType{},
								Computed:            true,
								Description:         "Date when the status occurred",
								MarkdownDescription: "Date when the status occurred",
							},
							"state": schema.StringAttribute{
								CustomType:          ovhtypes.TfStringType{},
								Computed:            true,
								Description:         "State of the app",
								MarkdownDescription: "State of the app",
							},
						},
						CustomType: StatusHistoryType{
							ObjectType: types.ObjectType{
								AttrTypes: StatusHistoryValue{}.AttributeTypes(ctx),
							},
						},
					},
					CustomType:          ovhtypes.NewTfListNestedType[StatusHistoryValue](ctx),
					Computed:            true,
					Description:         "Job state history",
					MarkdownDescription: "Job state history",
				},
				"info": schema.SingleNestedAttribute{
					Attributes: map[string]schema.Attribute{
						"code": schema.StringAttribute{
							CustomType:          ovhtypes.TfStringType{},
							Computed:            true,
							Description:         "Info code identifier",
							MarkdownDescription: "Info code identifier",
						},
						"message": schema.StringAttribute{
							CustomType:          ovhtypes.TfStringType{},
							Computed:            true,
							Description:         "Formatted message",
							MarkdownDescription: "Formatted message",
						},
					},
					CustomType: StatusInfoType{
						ObjectType: types.ObjectType{
							AttrTypes: StatusInfoValue{}.AttributeTypes(ctx),
						},
					},
					Computed:            true,
					Description:         "Information about the app",
					MarkdownDescription: "Information about the app",
				},
				"info_url": schema.StringAttribute{
					CustomType:          ovhtypes.TfStringType{},
					Computed:            true,
					Description:         "App info url",
					MarkdownDescription: "App info url",
				},
				"internal_service_ip": schema.StringAttribute{
					CustomType:          ovhtypes.TfStringType{},
					Computed:            true,
					Description:         "Internal IP address of the app service",
					MarkdownDescription: "Internal IP address of the app service",
				},
				"last_transition_date": schema.StringAttribute{
					CustomType:          ovhtypes.TfStringType{},
					Computed:            true,
					Description:         "Date of the last app state change",
					MarkdownDescription: "Date of the last app state change",
				},
				"monitoring_url": schema.StringAttribute{
					CustomType:          ovhtypes.TfStringType{},
					Computed:            true,
					Description:         "App resource usage url",
					MarkdownDescription: "App resource usage url",
				},
				"state": schema.StringAttribute{
					CustomType:          ovhtypes.TfStringType{},
					Computed:            true,
					Description:         "State of the app",
					MarkdownDescription: "State of the app",
				},
				"url": schema.StringAttribute{
					CustomType:          ovhtypes.TfStringType{},
					Computed:            true,
					Description:         "App access url",
					MarkdownDescription: "App access url",
				},
				"volumes": schema.ListNestedAttribute{
					NestedObject: schema.NestedAttributeObject{
						Attributes: map[string]schema.Attribute{
							"id": schema.StringAttribute{
								CustomType:          ovhtypes.TfStringType{},
								Computed:            true,
								Description:         "Volume Id",
								MarkdownDescription: "Volume Id",
							},
							"mount_path": schema.StringAttribute{
								CustomType:          ovhtypes.TfStringType{},
								Computed:            true,
								Description:         "Path where the data is mounted inside the container",
								MarkdownDescription: "Path where the data is mounted inside the container",
							},
							"user_volume_id": schema.StringAttribute{
								CustomType:          ovhtypes.TfStringType{},
								Computed:            true,
								Description:         "User volume Id",
								MarkdownDescription: "User volume Id",
							},
						},
						CustomType: StatusVolumesType{
							ObjectType: types.ObjectType{
								AttrTypes: StatusVolumesValue{}.AttributeTypes(ctx),
							},
						},
					},
					CustomType:          ovhtypes.NewTfListNestedType[StatusVolumesValue](ctx),
					Computed:            true,
					Description:         "App Data linked",
					MarkdownDescription: "App Data linked",
				},
			},
			CustomType: StatusType{
				ObjectType: types.ObjectType{
					AttrTypes: StatusValue{}.AttributeTypes(ctx),
				},
			},
			Computed:            true,
			Description:         "App Container Status",
			MarkdownDescription: "App Container Status",
		},
		"unsecure_http": schema.BoolAttribute{
			CustomType:          ovhtypes.TfBoolType{},
			Optional:            true,
			Computed:            true,
			Description:         "Whether if app api port can be accessed without any authentication token",
			MarkdownDescription: "Whether if app api port can be accessed without any authentication token",
		},
		"updated_at": schema.StringAttribute{
			CustomType:          ovhtypes.TfStringType{},
			Computed:            true,
			Description:         "App last update date",
			MarkdownDescription: "App last update date",
		},
		"url": schema.StringAttribute{
			CustomType:          ovhtypes.TfStringType{},
			Optional:            true,
			Description:         "URL of the Docker image for this AI deployment",
			MarkdownDescription: "URL of the Docker image for this AI deployment",
		},
		"user": schema.StringAttribute{
			CustomType:          ovhtypes.TfStringType{},
			Computed:            true,
			Description:         "App user owner",
			MarkdownDescription: "App user owner",
		},
		"volumes": schema.ListNestedAttribute{
			NestedObject: schema.NestedAttributeObject{
				Attributes: map[string]schema.Attribute{
					"cache": schema.BoolAttribute{
						CustomType:          ovhtypes.TfBoolType{},
						Optional:            true,
						Computed:            true,
						Description:         "Enable/disable volume caching",
						MarkdownDescription: "Enable/disable volume caching",
					},
					"container": schema.StringAttribute{
						CustomType:          ovhtypes.TfStringType{},
						Optional:            true,
						Computed:            true,
						Description:         "Public Cloud Storage container to attach",
						MarkdownDescription: "Public Cloud Storage container to attach",
					},
					"data_store": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"alias": schema.StringAttribute{
								CustomType:          ovhtypes.TfStringType{},
								Required:            true,
								Description:         "Data store alias",
								MarkdownDescription: "Data store alias",
							},
							"archive": schema.StringAttribute{
								CustomType:          ovhtypes.TfStringType{},
								Optional:            true,
								Computed:            true,
								Description:         "Name of the tar archive that needs to be saved",
								MarkdownDescription: "Name of the tar archive that needs to be saved",
							},
							"container": schema.StringAttribute{
								CustomType:          ovhtypes.TfStringType{},
								Required:            true,
								Description:         "Data store container to attach",
								MarkdownDescription: "Data store container to attach",
							},
							"internal": schema.BoolAttribute{
								CustomType:          ovhtypes.TfBoolType{},
								Optional:            true,
								Computed:            true,
								Description:         "True if data is stored on OVHcloud AI's internal storage",
								MarkdownDescription: "True if data is stored on OVHcloud AI's internal storage",
							},
							"prefix": schema.StringAttribute{
								CustomType:          ovhtypes.TfStringType{},
								Optional:            true,
								Computed:            true,
								Description:         "Prefix to fetch only part of the volume",
								MarkdownDescription: "Prefix to fetch only part of the volume",
							},
						},
						CustomType: VolumesDataStoreType{
							ObjectType: types.ObjectType{
								AttrTypes: VolumesDataStoreValue{}.AttributeTypes(ctx),
							},
						},
						Optional:            true,
						Computed:            true,
						Description:         "Volume details for data store containers. Deprecated: Use volumeSource.dataStore instead",
						MarkdownDescription: "Volume details for data store containers. Deprecated: Use volumeSource.dataStore instead",
					},
					"id": schema.StringAttribute{
						CustomType:          ovhtypes.TfStringType{},
						Optional:            true,
						Computed:            true,
						Description:         "Volume Id. Deprecated: moved to status.volumes[]",
						MarkdownDescription: "Volume Id. Deprecated: moved to status.volumes[]",
					},
					"mount_path": schema.StringAttribute{
						CustomType:          ovhtypes.TfStringType{},
						Required:            true,
						Description:         "Path where to mount the data inside the container",
						MarkdownDescription: "Path where to mount the data inside the container",
					},
					"permission": schema.StringAttribute{
						CustomType:          ovhtypes.TfStringType{},
						Required:            true,
						Description:         "Permissions to use on the mounted volume",
						MarkdownDescription: "Permissions to use on the mounted volume",
						Validators: []validator.String{
							stringvalidator.OneOf(
								"RO",
								"RW",
								"RWD",
							),
						},
					},
					"prefix": schema.StringAttribute{
						CustomType:          ovhtypes.TfStringType{},
						Optional:            true,
						Computed:            true,
						Description:         "Prefix to fetch only part of the volume",
						MarkdownDescription: "Prefix to fetch only part of the volume",
					},
					"private_swift": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"archive": schema.StringAttribute{
								CustomType:          ovhtypes.TfStringType{},
								Optional:            true,
								Computed:            true,
								Description:         "Name of the tar archive that needs to be saved",
								MarkdownDescription: "Name of the tar archive that needs to be saved",
							},
							"container": schema.StringAttribute{
								CustomType:          ovhtypes.TfStringType{},
								Required:            true,
								Description:         "Public Cloud Storage container to attach",
								MarkdownDescription: "Public Cloud Storage container to attach",
							},
							"internal": schema.BoolAttribute{
								CustomType:          ovhtypes.TfBoolType{},
								Optional:            true,
								Computed:            true,
								Description:         "True if data is stored on OVHcloud AI's internal storage",
								MarkdownDescription: "True if data is stored on OVHcloud AI's internal storage",
							},
							"prefix": schema.StringAttribute{
								CustomType:          ovhtypes.TfStringType{},
								Optional:            true,
								Computed:            true,
								Description:         "Prefix to fetch only part of the volume",
								MarkdownDescription: "Prefix to fetch only part of the volume",
							},
							"region": schema.StringAttribute{
								CustomType:          ovhtypes.TfStringType{},
								Required:            true,
								Description:         "Public Cloud Storage Region",
								MarkdownDescription: "Public Cloud Storage Region",
							},
						},
						CustomType: VolumesPrivateSwiftType{
							ObjectType: types.ObjectType{
								AttrTypes: VolumesPrivateSwiftValue{}.AttributeTypes(ctx),
							},
						},
						Optional:            true,
						Computed:            true,
						Description:         "Volume details for private swift containers. Deprecated: Use volumeSource.dataStore instead",
						MarkdownDescription: "Volume details for private swift containers. Deprecated: Use volumeSource.dataStore instead",
					},
					"public_git": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"url": schema.StringAttribute{
								CustomType:          ovhtypes.TfStringType{},
								Required:            true,
								Description:         "URL of the public git repository",
								MarkdownDescription: "URL of the public git repository",
							},
						},
						CustomType: VolumesPublicGitType{
							ObjectType: types.ObjectType{
								AttrTypes: VolumesPublicGitValue{}.AttributeTypes(ctx),
							},
						},
						Optional:            true,
						Computed:            true,
						Description:         "Volume details for public git repositories. Deprecated: Use volumeSource.publicGit instead",
						MarkdownDescription: "Volume details for public git repositories. Deprecated: Use volumeSource.publicGit instead",
					},
					"public_swift": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"url": schema.StringAttribute{
								CustomType:          ovhtypes.TfStringType{},
								Required:            true,
								Description:         "URL of the public swift container",
								MarkdownDescription: "URL of the public swift container",
							},
						},
						CustomType: VolumesPublicSwiftType{
							ObjectType: types.ObjectType{
								AttrTypes: VolumesPublicSwiftValue{}.AttributeTypes(ctx),
							},
						},
						Optional:            true,
						Computed:            true,
						Description:         "Volume details for public swift containers. Deprecated: Use volumeSource.publicSwift instead",
						MarkdownDescription: "Volume details for public swift containers. Deprecated: Use volumeSource.publicSwift instead",
					},
					"region": schema.StringAttribute{
						CustomType:          ovhtypes.TfStringType{},
						Optional:            true,
						Computed:            true,
						Description:         "Public Cloud Storage Region",
						MarkdownDescription: "Public Cloud Storage Region",
					},
					"standalone": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"name": schema.StringAttribute{
								CustomType:          ovhtypes.TfStringType{},
								Optional:            true,
								Computed:            true,
								Description:         "Name of the volume",
								MarkdownDescription: "Name of the volume",
							},
						},
						CustomType: VolumesStandaloneType{
							ObjectType: types.ObjectType{
								AttrTypes: VolumesStandaloneValue{}.AttributeTypes(ctx),
							},
						},
						Optional:            true,
						Computed:            true,
						Description:         "Volume details for volumes that do not have a datasource. Deprecated: Use volumeSource.standalone instead",
						MarkdownDescription: "Volume details for volumes that do not have a datasource. Deprecated: Use volumeSource.standalone instead",
					},
					"target_data_store": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"alias": schema.StringAttribute{
								CustomType:          ovhtypes.TfStringType{},
								Required:            true,
								Description:         "Data store alias",
								MarkdownDescription: "Data store alias",
							},
							"archive": schema.StringAttribute{
								CustomType:          ovhtypes.TfStringType{},
								Optional:            true,
								Computed:            true,
								Description:         "Name of the tar archive that needs to be saved",
								MarkdownDescription: "Name of the tar archive that needs to be saved",
							},
							"container": schema.StringAttribute{
								CustomType:          ovhtypes.TfStringType{},
								Required:            true,
								Description:         "Data store container to attach",
								MarkdownDescription: "Data store container to attach",
							},
							"internal": schema.BoolAttribute{
								CustomType:          ovhtypes.TfBoolType{},
								Optional:            true,
								Computed:            true,
								Description:         "True if data is stored on OVHcloud AI's internal storage",
								MarkdownDescription: "True if data is stored on OVHcloud AI's internal storage",
							},
							"prefix": schema.StringAttribute{
								CustomType:          ovhtypes.TfStringType{},
								Optional:            true,
								Computed:            true,
								Description:         "Prefix to fetch only part of the volume",
								MarkdownDescription: "Prefix to fetch only part of the volume",
							},
						},
						CustomType: VolumesTargetDataStoreType{
							ObjectType: types.ObjectType{
								AttrTypes: VolumesTargetDataStoreValue{}.AttributeTypes(ctx),
							},
						},
						Optional:            true,
						Computed:            true,
						Description:         "Target volume details for data store containers. Deprecated: Use volumeTarget.targetDataStore instead",
						MarkdownDescription: "Target volume details for data store containers. Deprecated: Use volumeTarget.targetDataStore instead",
					},
					"target_private_swift": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"archive": schema.StringAttribute{
								CustomType:          ovhtypes.TfStringType{},
								Optional:            true,
								Computed:            true,
								Description:         "Name of the tar archive that needs to be saved",
								MarkdownDescription: "Name of the tar archive that needs to be saved",
							},
							"container": schema.StringAttribute{
								CustomType:          ovhtypes.TfStringType{},
								Required:            true,
								Description:         "Public Cloud Storage container to attach",
								MarkdownDescription: "Public Cloud Storage container to attach",
							},
							"internal": schema.BoolAttribute{
								CustomType:          ovhtypes.TfBoolType{},
								Optional:            true,
								Computed:            true,
								Description:         "True if data is stored on OVHcloud AI's internal storage",
								MarkdownDescription: "True if data is stored on OVHcloud AI's internal storage",
							},
							"prefix": schema.StringAttribute{
								CustomType:          ovhtypes.TfStringType{},
								Optional:            true,
								Computed:            true,
								Description:         "Prefix to fetch only part of the volume",
								MarkdownDescription: "Prefix to fetch only part of the volume",
							},
							"region": schema.StringAttribute{
								CustomType:          ovhtypes.TfStringType{},
								Required:            true,
								Description:         "Public Cloud Storage Region",
								MarkdownDescription: "Public Cloud Storage Region",
							},
						},
						CustomType: VolumesTargetPrivateSwiftType{
							ObjectType: types.ObjectType{
								AttrTypes: VolumesTargetPrivateSwiftValue{}.AttributeTypes(ctx),
							},
						},
						Optional:            true,
						Computed:            true,
						Description:         "Target volume details for private swift containers. Deprecated: Use volumeTarget.targetDataStore instead",
						MarkdownDescription: "Target volume details for private swift containers. Deprecated: Use volumeTarget.targetDataStore instead",
					},
					"volume_source": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"data_store": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{
									"alias": schema.StringAttribute{
										CustomType:          ovhtypes.TfStringType{},
										Required:            true,
										Description:         "Data store alias",
										MarkdownDescription: "Data store alias",
									},
									"archive": schema.StringAttribute{
										CustomType:          ovhtypes.TfStringType{},
										Optional:            true,
										Computed:            true,
										Description:         "Name of the tar archive that needs to be saved",
										MarkdownDescription: "Name of the tar archive that needs to be saved",
									},
									"container": schema.StringAttribute{
										CustomType:          ovhtypes.TfStringType{},
										Required:            true,
										Description:         "Data store container to attach",
										MarkdownDescription: "Data store container to attach",
									},
									"internal": schema.BoolAttribute{
										CustomType:          ovhtypes.TfBoolType{},
										Optional:            true,
										Computed:            true,
										Description:         "True if data is stored on OVHcloud AI's internal storage",
										MarkdownDescription: "True if data is stored on OVHcloud AI's internal storage",
									},
									"prefix": schema.StringAttribute{
										CustomType:          ovhtypes.TfStringType{},
										Optional:            true,
										Computed:            true,
										Description:         "Prefix to fetch only part of the volume",
										MarkdownDescription: "Prefix to fetch only part of the volume",
									},
								},
								CustomType: VolumesVolumeSourceDataStoreType{
									ObjectType: types.ObjectType{
										AttrTypes: VolumesVolumeSourceDataStoreValue{}.AttributeTypes(ctx),
									},
								},
								Optional:            true,
								Computed:            true,
								Description:         "Volume details for data store containers",
								MarkdownDescription: "Volume details for data store containers",
							},
							"public_git": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{
									"url": schema.StringAttribute{
										CustomType:          ovhtypes.TfStringType{},
										Required:            true,
										Description:         "URL of the public git repository",
										MarkdownDescription: "URL of the public git repository",
									},
								},
								CustomType: VolumesVolumeSourcePublicGitType{
									ObjectType: types.ObjectType{
										AttrTypes: VolumesVolumeSourcePublicGitValue{}.AttributeTypes(ctx),
									},
								},
								Optional:            true,
								Computed:            true,
								Description:         "Volume details for public git repositories",
								MarkdownDescription: "Volume details for public git repositories",
							},
							"public_swift": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{
									"url": schema.StringAttribute{
										CustomType:          ovhtypes.TfStringType{},
										Required:            true,
										Description:         "URL of the public swift container",
										MarkdownDescription: "URL of the public swift container",
									},
								},
								CustomType: VolumesVolumeSourcePublicSwiftType{
									ObjectType: types.ObjectType{
										AttrTypes: VolumesVolumeSourcePublicSwiftValue{}.AttributeTypes(ctx),
									},
								},
								Optional:            true,
								Computed:            true,
								Description:         "Volume details for public swift containers",
								MarkdownDescription: "Volume details for public swift containers",
							},
							"standalone": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{
									"name": schema.StringAttribute{
										CustomType:          ovhtypes.TfStringType{},
										Optional:            true,
										Computed:            true,
										Description:         "Name of the volume",
										MarkdownDescription: "Name of the volume",
									},
								},
								CustomType: VolumesVolumeSourceStandaloneType{
									ObjectType: types.ObjectType{
										AttrTypes: VolumesVolumeSourceStandaloneValue{}.AttributeTypes(ctx),
									},
								},
								Optional:            true,
								Computed:            true,
								Description:         "Volume details for volumes that do not have a datasource",
								MarkdownDescription: "Volume details for volumes that do not have a datasource",
							},
						},
						CustomType: VolumesVolumeSourceType{
							ObjectType: types.ObjectType{
								AttrTypes: VolumesVolumeSourceValue{}.AttributeTypes(ctx),
							},
						},
						Optional:            true,
						Computed:            true,
						Description:         "Source volume details",
						MarkdownDescription: "Source volume details",
					},
					"volume_target": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"target_data_store": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{
									"alias": schema.StringAttribute{
										CustomType:          ovhtypes.TfStringType{},
										Required:            true,
										Description:         "Data store alias",
										MarkdownDescription: "Data store alias",
									},
									"archive": schema.StringAttribute{
										CustomType:          ovhtypes.TfStringType{},
										Optional:            true,
										Computed:            true,
										Description:         "Name of the tar archive that needs to be saved",
										MarkdownDescription: "Name of the tar archive that needs to be saved",
									},
									"container": schema.StringAttribute{
										CustomType:          ovhtypes.TfStringType{},
										Required:            true,
										Description:         "Data store container to attach",
										MarkdownDescription: "Data store container to attach",
									},
									"internal": schema.BoolAttribute{
										CustomType:          ovhtypes.TfBoolType{},
										Optional:            true,
										Computed:            true,
										Description:         "True if data is stored on OVHcloud AI's internal storage",
										MarkdownDescription: "True if data is stored on OVHcloud AI's internal storage",
									},
									"prefix": schema.StringAttribute{
										CustomType:          ovhtypes.TfStringType{},
										Optional:            true,
										Computed:            true,
										Description:         "Prefix to fetch only part of the volume",
										MarkdownDescription: "Prefix to fetch only part of the volume",
									},
								},
								CustomType: VolumesVolumeTargetTargetDataStoreType{
									ObjectType: types.ObjectType{
										AttrTypes: VolumesVolumeTargetTargetDataStoreValue{}.AttributeTypes(ctx),
									},
								},
								Optional:            true,
								Computed:            true,
								Description:         "Volume details for data store containers",
								MarkdownDescription: "Volume details for data store containers",
							},
						},
						CustomType: VolumesVolumeTargetType{
							ObjectType: types.ObjectType{
								AttrTypes: VolumesVolumeTargetValue{}.AttributeTypes(ctx),
							},
						},
						Optional:            true,
						Computed:            true,
						Description:         "Target volume details",
						MarkdownDescription: "Target volume details",
					},
				},
				CustomType: VolumesType{
					ObjectType: types.ObjectType{
						AttrTypes: VolumesValue{}.AttributeTypes(ctx),
					},
				},
			},
			CustomType:          ovhtypes.NewTfListNestedType[VolumesValue](ctx),
			Optional:            true,
			Computed:            true,
			Description:         "App Data linked",
			MarkdownDescription: "App Data linked",
		},
	}

	return schema.Schema{
		Attributes: attrs,
	}
}

type CloudProjectAiAppModel struct {
	AppId              ovhtypes.TfStringValue                             `tfsdk:"app_id" json:"appId"`
	Command            ovhtypes.TfListNestedValue[ovhtypes.TfStringValue] `tfsdk:"command" json:"command"`
	Cpu                ovhtypes.TfInt64Value                              `tfsdk:"cpu" json:"cpu"`
	CreatedAt          ovhtypes.TfStringValue                             `tfsdk:"created_at" json:"createdAt"`
	DefaultHttpPort    ovhtypes.TfInt64Value                              `tfsdk:"default_http_port" json:"defaultHttpPort"`
	DeploymentStrategy DeploymentStrategyValue                            `tfsdk:"deployment_strategy" json:"deploymentStrategy"`
	EnvVars            ovhtypes.TfListNestedValue[EnvVarsValue]           `tfsdk:"env_vars" json:"envVars"`
	Flavor             ovhtypes.TfStringValue                             `tfsdk:"flavor" json:"flavor"`
	Gpu                ovhtypes.TfInt64Value                              `tfsdk:"gpu" json:"gpu"`
	GrpcPort           ovhtypes.TfInt64Value                              `tfsdk:"grpc_port" json:"grpcPort"`
	Id                 ovhtypes.TfStringValue                             `tfsdk:"id" json:"id"`
	Image              ovhtypes.TfStringValue                             `tfsdk:"image" json:"image"`
	Labels             ovhtypes.TfMapNestedValue[ovhtypes.TfStringValue]  `tfsdk:"labels" json:"labels"`
	Name               ovhtypes.TfStringValue                             `tfsdk:"name" json:"name"`
	PartnerId          ovhtypes.TfStringValue                             `tfsdk:"partner_id" json:"partnerId"`
	Probe              ProbeValue                                         `tfsdk:"probe" json:"probe"`
	Region             ovhtypes.TfStringValue                             `tfsdk:"region" json:"region"`
	Resources          ResourcesValue                                     `tfsdk:"resources" json:"resources"`
	ScalingStrategy    ScalingStrategyValue                               `tfsdk:"scaling_strategy" json:"scalingStrategy"`
	ServiceName        ovhtypes.TfStringValue                             `tfsdk:"service_name" json:"serviceName"`
	Spec               SpecValue                                          `tfsdk:"spec" json:"spec"`
	Status             StatusValue                                        `tfsdk:"status" json:"status"`
	UnsecureHttp       ovhtypes.TfBoolValue                               `tfsdk:"unsecure_http" json:"unsecureHttp"`
	UpdatedAt          ovhtypes.TfStringValue                             `tfsdk:"updated_at" json:"updatedAt"`
	Url                ovhtypes.TfStringValue                             `tfsdk:"url" json:"url"`
	User               ovhtypes.TfStringValue                             `tfsdk:"user" json:"user"`
	Volumes            ovhtypes.TfListNestedValue[VolumesValue]           `tfsdk:"volumes" json:"volumes"`
}

func (v *CloudProjectAiAppModel) MergeWith(other *CloudProjectAiAppModel) {

	if (v.AppId.IsUnknown() || v.AppId.IsNull()) && !other.AppId.IsUnknown() {
		v.AppId = other.AppId
	}

	if (v.Command.IsUnknown() || v.Command.IsNull()) && !other.Command.IsUnknown() {
		v.Command = other.Command
	}

	if (v.Cpu.IsUnknown() || v.Cpu.IsNull()) && !other.Cpu.IsUnknown() {
		v.Cpu = other.Cpu
	}

	if (v.CreatedAt.IsUnknown() || v.CreatedAt.IsNull()) && !other.CreatedAt.IsUnknown() {
		v.CreatedAt = other.CreatedAt
	}

	if (v.DefaultHttpPort.IsUnknown() || v.DefaultHttpPort.IsNull()) && !other.DefaultHttpPort.IsUnknown() {
		v.DefaultHttpPort = other.DefaultHttpPort
	}

	if (v.DeploymentStrategy.IsUnknown() || v.DeploymentStrategy.IsNull()) && !other.DeploymentStrategy.IsUnknown() {
		v.DeploymentStrategy = other.DeploymentStrategy
	}

	if (v.EnvVars.IsUnknown() || v.EnvVars.IsNull()) && !other.EnvVars.IsUnknown() {
		v.EnvVars = other.EnvVars
	}

	if (v.Flavor.IsUnknown() || v.Flavor.IsNull()) && !other.Flavor.IsUnknown() {
		v.Flavor = other.Flavor
	}

	if (v.Gpu.IsUnknown() || v.Gpu.IsNull()) && !other.Gpu.IsUnknown() {
		v.Gpu = other.Gpu
	}

	if (v.GrpcPort.IsUnknown() || v.GrpcPort.IsNull()) && !other.GrpcPort.IsUnknown() {
		v.GrpcPort = other.GrpcPort
	}

	if (v.Id.IsUnknown() || v.Id.IsNull()) && !other.Id.IsUnknown() {
		v.Id = other.Id
	}

	if (v.Image.IsUnknown() || v.Image.IsNull()) && !other.Image.IsUnknown() {
		v.Image = other.Image
	}

	if (v.Labels.IsUnknown() || v.Labels.IsNull()) && !other.Labels.IsUnknown() {
		v.Labels = other.Labels
	}

	if (v.Name.IsUnknown() || v.Name.IsNull()) && !other.Name.IsUnknown() {
		v.Name = other.Name
	}

	if (v.PartnerId.IsUnknown() || v.PartnerId.IsNull()) && !other.PartnerId.IsUnknown() {
		v.PartnerId = other.PartnerId
	}

	if (v.Probe.IsUnknown() || v.Probe.IsNull()) && !other.Probe.IsUnknown() {
		v.Probe = other.Probe
	}

	if (v.Region.IsUnknown() || v.Region.IsNull()) && !other.Region.IsUnknown() {
		v.Region = other.Region
	}

	if (v.Resources.IsUnknown() || v.Resources.IsNull()) && !other.Resources.IsUnknown() {
		v.Resources = other.Resources
	}

	if (v.ScalingStrategy.IsUnknown() || v.ScalingStrategy.IsNull()) && !other.ScalingStrategy.IsUnknown() {
		v.ScalingStrategy = other.ScalingStrategy
	}

	if (v.ServiceName.IsUnknown() || v.ServiceName.IsNull()) && !other.ServiceName.IsUnknown() {
		v.ServiceName = other.ServiceName
	}

	if (v.Spec.IsUnknown() || v.Spec.IsNull()) && !other.Spec.IsUnknown() {
		v.Spec = other.Spec
	}

	if (v.Status.IsUnknown() || v.Status.IsNull()) && !other.Status.IsUnknown() {
		v.Status = other.Status
	}

	if (v.UnsecureHttp.IsUnknown() || v.UnsecureHttp.IsNull()) && !other.UnsecureHttp.IsUnknown() {
		v.UnsecureHttp = other.UnsecureHttp
	}

	if (v.UpdatedAt.IsUnknown() || v.UpdatedAt.IsNull()) && !other.UpdatedAt.IsUnknown() {
		v.UpdatedAt = other.UpdatedAt
	}

	if (v.Url.IsUnknown() || v.Url.IsNull()) && !other.Url.IsUnknown() {
		v.Url = other.Url
	}

	if (v.User.IsUnknown() || v.User.IsNull()) && !other.User.IsUnknown() {
		v.User = other.User
	}

	if (v.Volumes.IsUnknown() || v.Volumes.IsNull()) && !other.Volumes.IsUnknown() {
		v.Volumes = other.Volumes
	}

}

func (v CloudProjectAiAppModel) ToCreate() *CloudProjectAiAppModel {
	res := &CloudProjectAiAppModel{}

	if !v.Command.IsUnknown() {
		res.Command = v.Command
	}

	if !v.DefaultHttpPort.IsUnknown() {
		res.DefaultHttpPort = v.DefaultHttpPort
	}

	if !v.DeploymentStrategy.IsUnknown() {
		res.DeploymentStrategy = *v.DeploymentStrategy.ToCreate()
	}

	if !v.EnvVars.IsUnknown() {
		var createEnvVars []EnvVarsValue
		for _, elem := range v.EnvVars.Elements() {
			createEnvVars = append(createEnvVars, *elem.(EnvVarsValue).ToCreate())
		}

		newEnvVars, _ := basetypes.NewListValueFrom(context.Background(), EnvVarsValue{}.Type(context.Background()), createEnvVars)
		res.EnvVars = ovhtypes.TfListNestedValue[EnvVarsValue]{
			ListValue: newEnvVars,
		}
	}

	if !v.GrpcPort.IsUnknown() {
		res.GrpcPort = v.GrpcPort
	}

	if !v.Image.IsUnknown() {
		res.Image = v.Image
	}

	if !v.Labels.IsUnknown() {
		res.Labels = v.Labels
	}

	if !v.Name.IsUnknown() {
		res.Name = v.Name
	}

	if !v.PartnerId.IsUnknown() {
		res.PartnerId = v.PartnerId
	}

	if !v.Probe.IsUnknown() {
		res.Probe = *v.Probe.ToCreate()
	}

	if !v.Region.IsUnknown() {
		res.Region = v.Region
	}

	if !v.Resources.IsUnknown() {
		res.Resources = *v.Resources.ToCreate()
	}

	if !v.ScalingStrategy.IsUnknown() {
		res.ScalingStrategy = *v.ScalingStrategy.ToCreate()
	}

	if !v.UnsecureHttp.IsUnknown() {
		res.UnsecureHttp = v.UnsecureHttp
	}

	if !v.Volumes.IsUnknown() {
		var createVolumes []VolumesValue
		for _, elem := range v.Volumes.Elements() {
			createVolumes = append(createVolumes, *elem.(VolumesValue).ToCreate())
		}

		newVolumes, _ := basetypes.NewListValueFrom(context.Background(), VolumesValue{}.Type(context.Background()), createVolumes)
		res.Volumes = ovhtypes.TfListNestedValue[VolumesValue]{
			ListValue: newVolumes,
		}
	}

	return res
}

func (v CloudProjectAiAppModel) ToUpdate() *CloudProjectAiAppModel {
	res := &CloudProjectAiAppModel{}

	if !v.Command.IsUnknown() {
		res.Command = v.Command
	}

	if !v.Cpu.IsUnknown() {
		res.Cpu = v.Cpu
	}

	if !v.DefaultHttpPort.IsUnknown() {
		res.DefaultHttpPort = v.DefaultHttpPort
	}

	if !v.DeploymentStrategy.IsUnknown() {
		res.DeploymentStrategy = *v.DeploymentStrategy.ToUpdate()
	}

	if !v.EnvVars.IsUnknown() {
		var updateEnvVars []EnvVarsValue
		for _, elem := range v.EnvVars.Elements() {
			updateEnvVars = append(updateEnvVars, *elem.(EnvVarsValue).ToUpdate())
		}

		newEnvVars, _ := basetypes.NewListValueFrom(context.Background(), EnvVarsValue{}.Type(context.Background()), updateEnvVars)
		res.EnvVars = ovhtypes.TfListNestedValue[EnvVarsValue]{
			ListValue: newEnvVars,
		}
	}

	if !v.Flavor.IsUnknown() {
		res.Flavor = v.Flavor
	}

	if !v.Gpu.IsUnknown() {
		res.Gpu = v.Gpu
	}

	if !v.GrpcPort.IsUnknown() {
		res.GrpcPort = v.GrpcPort
	}

	if !v.Url.IsUnknown() {
		res.Url = v.Url
	}

	return res
}

func (v *CloudProjectAiAppModel) MarshalJSON() ([]byte, error) {
	toMarshal := map[string]any{}
	if !v.Command.IsNull() && !v.Command.IsUnknown() {
		toMarshal["command"] = v.Command
	}
	if !v.Cpu.IsNull() && !v.Cpu.IsUnknown() {
		toMarshal["cpu"] = v.Cpu
	}
	if !v.DefaultHttpPort.IsNull() && !v.DefaultHttpPort.IsUnknown() {
		toMarshal["defaultHttpPort"] = v.DefaultHttpPort
	}
	if !v.DeploymentStrategy.IsNull() && !v.DeploymentStrategy.IsUnknown() {
		toMarshal["deploymentStrategy"] = v.DeploymentStrategy
	}
	if !v.EnvVars.IsNull() && !v.EnvVars.IsUnknown() {
		toMarshal["envVars"] = v.EnvVars
	}
	if !v.Flavor.IsNull() && !v.Flavor.IsUnknown() {
		toMarshal["flavor"] = v.Flavor
	}
	if !v.Gpu.IsNull() && !v.Gpu.IsUnknown() {
		toMarshal["gpu"] = v.Gpu
	}
	if !v.GrpcPort.IsNull() && !v.GrpcPort.IsUnknown() {
		toMarshal["grpcPort"] = v.GrpcPort
	}
	if !v.Image.IsNull() && !v.Image.IsUnknown() {
		toMarshal["image"] = v.Image
	}
	if !v.Labels.IsNull() && !v.Labels.IsUnknown() {
		toMarshal["labels"] = v.Labels
	}
	if !v.Name.IsNull() && !v.Name.IsUnknown() {
		toMarshal["name"] = v.Name
	}
	if !v.PartnerId.IsNull() && !v.PartnerId.IsUnknown() {
		toMarshal["partnerId"] = v.PartnerId
	}
	if !v.Probe.IsNull() && !v.Probe.IsUnknown() {
		toMarshal["probe"] = v.Probe
	}
	if !v.Region.IsNull() && !v.Region.IsUnknown() {
		toMarshal["region"] = v.Region
	}
	if !v.Resources.IsNull() && !v.Resources.IsUnknown() {
		toMarshal["resources"] = v.Resources
	}
	if !v.ScalingStrategy.IsNull() && !v.ScalingStrategy.IsUnknown() {
		toMarshal["scalingStrategy"] = v.ScalingStrategy
	}
	if !v.UnsecureHttp.IsNull() && !v.UnsecureHttp.IsUnknown() {
		toMarshal["unsecureHttp"] = v.UnsecureHttp
	}
	if !v.Url.IsNull() && !v.Url.IsUnknown() {
		toMarshal["url"] = v.Url
	}
	if !v.Volumes.IsNull() && !v.Volumes.IsUnknown() {
		toMarshal["volumes"] = v.Volumes
	}

	return json.Marshal(toMarshal)
}

var _ basetypes.ObjectTypable = DeploymentStrategyType{}

type DeploymentStrategyType struct {
	basetypes.ObjectType
}

func (t DeploymentStrategyType) Equal(o attr.Type) bool {
	other, ok := o.(DeploymentStrategyType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t DeploymentStrategyType) String() string {
	return "DeploymentStrategyType"
}

func (t DeploymentStrategyType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	maxSurgeAttribute, ok := attributes["max_surge"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_surge is missing from object`)

		return nil, diags
	}

	maxSurgeVal, ok := maxSurgeAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_surge expected to be ovhtypes.TfStringValue, was: %T`, maxSurgeAttribute))
	}

	maxUnavailableAttribute, ok := attributes["max_unavailable"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_unavailable is missing from object`)

		return nil, diags
	}

	maxUnavailableVal, ok := maxUnavailableAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_unavailable expected to be ovhtypes.TfStringValue, was: %T`, maxUnavailableAttribute))
	}

	progressDeadlineSecondsAttribute, ok := attributes["progress_deadline_seconds"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`progress_deadline_seconds is missing from object`)

		return nil, diags
	}

	progressDeadlineSecondsVal, ok := progressDeadlineSecondsAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`progress_deadline_seconds expected to be ovhtypes.TfInt64Value, was: %T`, progressDeadlineSecondsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return DeploymentStrategyValue{
		MaxSurge:                maxSurgeVal,
		MaxUnavailable:          maxUnavailableVal,
		ProgressDeadlineSeconds: progressDeadlineSecondsVal,
		state:                   attr.ValueStateKnown,
	}, diags
}

func NewDeploymentStrategyValueNull() DeploymentStrategyValue {
	return DeploymentStrategyValue{
		state: attr.ValueStateNull,
	}
}

func NewDeploymentStrategyValueUnknown() DeploymentStrategyValue {
	return DeploymentStrategyValue{
		state: attr.ValueStateUnknown,
	}
}

func NewDeploymentStrategyValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (DeploymentStrategyValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing DeploymentStrategyValue Attribute Value",
				"While creating a DeploymentStrategyValue value, a missing attribute value was detected. "+
					"A DeploymentStrategyValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DeploymentStrategyValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid DeploymentStrategyValue Attribute Type",
				"While creating a DeploymentStrategyValue value, an invalid attribute value was detected. "+
					"A DeploymentStrategyValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DeploymentStrategyValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("DeploymentStrategyValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra DeploymentStrategyValue Attribute Value",
				"While creating a DeploymentStrategyValue value, an extra attribute value was detected. "+
					"A DeploymentStrategyValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra DeploymentStrategyValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewDeploymentStrategyValueUnknown(), diags
	}

	maxSurgeAttribute, ok := attributes["max_surge"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_surge is missing from object`)

		return NewDeploymentStrategyValueUnknown(), diags
	}

	maxSurgeVal, ok := maxSurgeAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_surge expected to be ovhtypes.TfStringValue, was: %T`, maxSurgeAttribute))
	}

	maxUnavailableAttribute, ok := attributes["max_unavailable"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_unavailable is missing from object`)

		return NewDeploymentStrategyValueUnknown(), diags
	}

	maxUnavailableVal, ok := maxUnavailableAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_unavailable expected to be ovhtypes.TfStringValue, was: %T`, maxUnavailableAttribute))
	}

	progressDeadlineSecondsAttribute, ok := attributes["progress_deadline_seconds"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`progress_deadline_seconds is missing from object`)

		return NewDeploymentStrategyValueUnknown(), diags
	}

	progressDeadlineSecondsVal, ok := progressDeadlineSecondsAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`progress_deadline_seconds expected to be ovhtypes.TfInt64Value, was: %T`, progressDeadlineSecondsAttribute))
	}

	if diags.HasError() {
		return NewDeploymentStrategyValueUnknown(), diags
	}

	return DeploymentStrategyValue{
		MaxSurge:                maxSurgeVal,
		MaxUnavailable:          maxUnavailableVal,
		ProgressDeadlineSeconds: progressDeadlineSecondsVal,
		state:                   attr.ValueStateKnown,
	}, diags
}

func NewDeploymentStrategyValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) DeploymentStrategyValue {
	object, diags := NewDeploymentStrategyValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewDeploymentStrategyValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t DeploymentStrategyType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewDeploymentStrategyValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewDeploymentStrategyValueUnknown(), nil
	}

	if in.IsNull() {
		return NewDeploymentStrategyValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewDeploymentStrategyValueMust(DeploymentStrategyValue{}.AttributeTypes(ctx), attributes), nil
}

func (t DeploymentStrategyType) ValueType(ctx context.Context) attr.Value {
	return DeploymentStrategyValue{}
}

var _ basetypes.ObjectValuable = DeploymentStrategyValue{}

type DeploymentStrategyValue struct {
	MaxSurge                ovhtypes.TfStringValue `tfsdk:"max_surge" json:"maxSurge"`
	MaxUnavailable          ovhtypes.TfStringValue `tfsdk:"max_unavailable" json:"maxUnavailable"`
	ProgressDeadlineSeconds ovhtypes.TfInt64Value  `tfsdk:"progress_deadline_seconds" json:"progressDeadlineSeconds"`
	state                   attr.ValueState
}

func (v DeploymentStrategyValue) ToCreate() *DeploymentStrategyValue {
	res := &DeploymentStrategyValue{}

	if !v.MaxSurge.IsNull() {
		res.MaxSurge = v.MaxSurge
	}

	if !v.MaxUnavailable.IsNull() {
		res.MaxUnavailable = v.MaxUnavailable
	}

	if !v.ProgressDeadlineSeconds.IsNull() {
		res.ProgressDeadlineSeconds = v.ProgressDeadlineSeconds
	}

	res.state = attr.ValueStateKnown

	return res
}

func (v DeploymentStrategyValue) ToUpdate() *DeploymentStrategyValue {
	res := &DeploymentStrategyValue{}

	if !v.MaxSurge.IsNull() {
		res.MaxSurge = v.MaxSurge
	}

	if !v.MaxUnavailable.IsNull() {
		res.MaxUnavailable = v.MaxUnavailable
	}

	if !v.ProgressDeadlineSeconds.IsNull() {
		res.ProgressDeadlineSeconds = v.ProgressDeadlineSeconds
	}

	res.state = attr.ValueStateKnown

	return res
}

func (v DeploymentStrategyValue) MarshalJSON() ([]byte, error) {
	toMarshal := map[string]any{}
	if !v.MaxSurge.IsNull() && !v.MaxSurge.IsUnknown() {
		toMarshal["maxSurge"] = v.MaxSurge
	}
	if !v.MaxUnavailable.IsNull() && !v.MaxUnavailable.IsUnknown() {
		toMarshal["maxUnavailable"] = v.MaxUnavailable
	}
	if !v.ProgressDeadlineSeconds.IsNull() && !v.ProgressDeadlineSeconds.IsUnknown() {
		toMarshal["progressDeadlineSeconds"] = v.ProgressDeadlineSeconds
	}

	return json.Marshal(toMarshal)
}

func (v *DeploymentStrategyValue) UnmarshalJSON(data []byte) error {
	type JsonDeploymentStrategyValue DeploymentStrategyValue

	var tmp JsonDeploymentStrategyValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.MaxSurge = tmp.MaxSurge
	v.MaxUnavailable = tmp.MaxUnavailable
	v.ProgressDeadlineSeconds = tmp.ProgressDeadlineSeconds

	v.state = attr.ValueStateKnown

	return nil
}

func (v *DeploymentStrategyValue) MergeWith(other *DeploymentStrategyValue) {

	if (v.MaxSurge.IsUnknown() || v.MaxSurge.IsNull()) && !other.MaxSurge.IsUnknown() {
		v.MaxSurge = other.MaxSurge
	}

	if (v.MaxUnavailable.IsUnknown() || v.MaxUnavailable.IsNull()) && !other.MaxUnavailable.IsUnknown() {
		v.MaxUnavailable = other.MaxUnavailable
	}

	if (v.ProgressDeadlineSeconds.IsUnknown() || v.ProgressDeadlineSeconds.IsNull()) && !other.ProgressDeadlineSeconds.IsUnknown() {
		v.ProgressDeadlineSeconds = other.ProgressDeadlineSeconds
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v DeploymentStrategyValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"maxSurge":                v.MaxSurge,
		"maxUnavailable":          v.MaxUnavailable,
		"progressDeadlineSeconds": v.ProgressDeadlineSeconds,
	}
}
func (v DeploymentStrategyValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["max_surge"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["max_unavailable"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["progress_deadline_seconds"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.MaxSurge.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_surge"] = val

		val, err = v.MaxUnavailable.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_unavailable"] = val

		val, err = v.ProgressDeadlineSeconds.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["progress_deadline_seconds"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v DeploymentStrategyValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v DeploymentStrategyValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v DeploymentStrategyValue) String() string {
	return "DeploymentStrategyValue"
}

func (v DeploymentStrategyValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"max_surge":                 ovhtypes.TfStringType{},
			"max_unavailable":           ovhtypes.TfStringType{},
			"progress_deadline_seconds": ovhtypes.TfInt64Type{},
		},
		map[string]attr.Value{
			"max_surge":                 v.MaxSurge,
			"max_unavailable":           v.MaxUnavailable,
			"progress_deadline_seconds": v.ProgressDeadlineSeconds,
		})

	return objVal, diags
}

func (v DeploymentStrategyValue) Equal(o attr.Value) bool {
	other, ok := o.(DeploymentStrategyValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.MaxSurge.Equal(other.MaxSurge) {
		return false
	}

	if !v.MaxUnavailable.Equal(other.MaxUnavailable) {
		return false
	}

	if !v.ProgressDeadlineSeconds.Equal(other.ProgressDeadlineSeconds) {
		return false
	}

	return true
}

func (v DeploymentStrategyValue) Type(ctx context.Context) attr.Type {
	return DeploymentStrategyType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v DeploymentStrategyValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"max_surge":                 ovhtypes.TfStringType{},
		"max_unavailable":           ovhtypes.TfStringType{},
		"progress_deadline_seconds": ovhtypes.TfInt64Type{},
	}
}

var _ basetypes.ObjectTypable = EnvVarsType{}

type EnvVarsType struct {
	basetypes.ObjectType
}

func (t EnvVarsType) Equal(o attr.Type) bool {
	other, ok := o.(EnvVarsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t EnvVarsType) String() string {
	return "EnvVarsType"
}

func (t EnvVarsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be ovhtypes.TfStringValue, was: %T`, nameAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return nil, diags
	}

	valueVal, ok := valueAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be ovhtypes.TfStringValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return EnvVarsValue{
		Name:  nameVal,
		Value: valueVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewEnvVarsValueNull() EnvVarsValue {
	return EnvVarsValue{
		state: attr.ValueStateNull,
	}
}

func NewEnvVarsValueUnknown() EnvVarsValue {
	return EnvVarsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewEnvVarsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (EnvVarsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing EnvVarsValue Attribute Value",
				"While creating a EnvVarsValue value, a missing attribute value was detected. "+
					"A EnvVarsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("EnvVarsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid EnvVarsValue Attribute Type",
				"While creating a EnvVarsValue value, an invalid attribute value was detected. "+
					"A EnvVarsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("EnvVarsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("EnvVarsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra EnvVarsValue Attribute Value",
				"While creating a EnvVarsValue value, an extra attribute value was detected. "+
					"A EnvVarsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra EnvVarsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewEnvVarsValueUnknown(), diags
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewEnvVarsValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be ovhtypes.TfStringValue, was: %T`, nameAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return NewEnvVarsValueUnknown(), diags
	}

	valueVal, ok := valueAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be ovhtypes.TfStringValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return NewEnvVarsValueUnknown(), diags
	}

	return EnvVarsValue{
		Name:  nameVal,
		Value: valueVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewEnvVarsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) EnvVarsValue {
	object, diags := NewEnvVarsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewEnvVarsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t EnvVarsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewEnvVarsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewEnvVarsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewEnvVarsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewEnvVarsValueMust(EnvVarsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t EnvVarsType) ValueType(ctx context.Context) attr.Value {
	return EnvVarsValue{}
}

var _ basetypes.ObjectValuable = EnvVarsValue{}

type EnvVarsValue struct {
	Name  ovhtypes.TfStringValue `tfsdk:"name" json:"name"`
	Value ovhtypes.TfStringValue `tfsdk:"value" json:"value"`
	state attr.ValueState
}

func (v EnvVarsValue) ToCreate() *EnvVarsValue {
	res := &EnvVarsValue{}

	if !v.Value.IsNull() {
		res.Value = v.Value
	}

	if !v.Name.IsNull() {
		res.Name = v.Name
	}

	res.state = attr.ValueStateKnown

	return res
}

func (v EnvVarsValue) ToUpdate() *EnvVarsValue {
	res := &EnvVarsValue{}

	if !v.Value.IsNull() {
		res.Value = v.Value
	}

	if !v.Name.IsNull() {
		res.Name = v.Name
	}

	res.state = attr.ValueStateKnown

	return res
}

func (v EnvVarsValue) MarshalJSON() ([]byte, error) {
	toMarshal := map[string]any{}
	if !v.Name.IsNull() && !v.Name.IsUnknown() {
		toMarshal["name"] = v.Name
	}
	if !v.Value.IsNull() && !v.Value.IsUnknown() {
		toMarshal["value"] = v.Value
	}

	return json.Marshal(toMarshal)
}

func (v *EnvVarsValue) UnmarshalJSON(data []byte) error {
	type JsonEnvVarsValue EnvVarsValue

	var tmp JsonEnvVarsValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.Name = tmp.Name
	v.Value = tmp.Value

	v.state = attr.ValueStateKnown

	return nil
}

func (v *EnvVarsValue) MergeWith(other *EnvVarsValue) {

	if (v.Name.IsUnknown() || v.Name.IsNull()) && !other.Name.IsUnknown() {
		v.Name = other.Name
	}

	if (v.Value.IsUnknown() || v.Value.IsNull()) && !other.Value.IsUnknown() {
		v.Value = other.Value
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v EnvVarsValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"name":  v.Name,
		"value": v.Value,
	}
}
func (v EnvVarsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["value"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Value.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["value"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v EnvVarsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v EnvVarsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v EnvVarsValue) String() string {
	return "EnvVarsValue"
}

func (v EnvVarsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"name":  ovhtypes.TfStringType{},
			"value": ovhtypes.TfStringType{},
		},
		map[string]attr.Value{
			"name":  v.Name,
			"value": v.Value,
		})

	return objVal, diags
}

func (v EnvVarsValue) Equal(o attr.Value) bool {
	other, ok := o.(EnvVarsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Value.Equal(other.Value) {
		return false
	}

	return true
}

func (v EnvVarsValue) Type(ctx context.Context) attr.Type {
	return EnvVarsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v EnvVarsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"name":  ovhtypes.TfStringType{},
		"value": ovhtypes.TfStringType{},
	}
}

var _ basetypes.ObjectTypable = ProbeType{}

type ProbeType struct {
	basetypes.ObjectType
}

func (t ProbeType) Equal(o attr.Type) bool {
	other, ok := o.(ProbeType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ProbeType) String() string {
	return "ProbeType"
}

func (t ProbeType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	pathAttribute, ok := attributes["path"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`path is missing from object`)

		return nil, diags
	}

	pathVal, ok := pathAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`path expected to be ovhtypes.TfStringValue, was: %T`, pathAttribute))
	}

	portAttribute, ok := attributes["port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port is missing from object`)

		return nil, diags
	}

	portVal, ok := portAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port expected to be ovhtypes.TfInt64Value, was: %T`, portAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ProbeValue{
		Path:  pathVal,
		Port:  portVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewProbeValueNull() ProbeValue {
	return ProbeValue{
		state: attr.ValueStateNull,
	}
}

func NewProbeValueUnknown() ProbeValue {
	return ProbeValue{
		state: attr.ValueStateUnknown,
	}
}

func NewProbeValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ProbeValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ProbeValue Attribute Value",
				"While creating a ProbeValue value, a missing attribute value was detected. "+
					"A ProbeValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ProbeValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ProbeValue Attribute Type",
				"While creating a ProbeValue value, an invalid attribute value was detected. "+
					"A ProbeValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ProbeValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ProbeValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ProbeValue Attribute Value",
				"While creating a ProbeValue value, an extra attribute value was detected. "+
					"A ProbeValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ProbeValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewProbeValueUnknown(), diags
	}

	pathAttribute, ok := attributes["path"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`path is missing from object`)

		return NewProbeValueUnknown(), diags
	}

	pathVal, ok := pathAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`path expected to be ovhtypes.TfStringValue, was: %T`, pathAttribute))
	}

	portAttribute, ok := attributes["port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port is missing from object`)

		return NewProbeValueUnknown(), diags
	}

	portVal, ok := portAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port expected to be ovhtypes.TfInt64Value, was: %T`, portAttribute))
	}

	if diags.HasError() {
		return NewProbeValueUnknown(), diags
	}

	return ProbeValue{
		Path:  pathVal,
		Port:  portVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewProbeValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ProbeValue {
	object, diags := NewProbeValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewProbeValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ProbeType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewProbeValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewProbeValueUnknown(), nil
	}

	if in.IsNull() {
		return NewProbeValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewProbeValueMust(ProbeValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ProbeType) ValueType(ctx context.Context) attr.Value {
	return ProbeValue{}
}

var _ basetypes.ObjectValuable = ProbeValue{}

type ProbeValue struct {
	Path  ovhtypes.TfStringValue `tfsdk:"path" json:"path"`
	Port  ovhtypes.TfInt64Value  `tfsdk:"port" json:"port"`
	state attr.ValueState
}

func (v ProbeValue) ToCreate() *ProbeValue {
	res := &ProbeValue{}

	if !v.Path.IsNull() {
		res.Path = v.Path
	}

	if !v.Port.IsNull() {
		res.Port = v.Port
	}

	res.state = attr.ValueStateKnown

	return res
}

func (v ProbeValue) MarshalJSON() ([]byte, error) {
	toMarshal := map[string]any{}
	if !v.Path.IsNull() && !v.Path.IsUnknown() {
		toMarshal["path"] = v.Path
	}
	if !v.Port.IsNull() && !v.Port.IsUnknown() {
		toMarshal["port"] = v.Port
	}

	return json.Marshal(toMarshal)
}

func (v *ProbeValue) UnmarshalJSON(data []byte) error {
	type JsonProbeValue ProbeValue

	var tmp JsonProbeValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.Path = tmp.Path
	v.Port = tmp.Port

	v.state = attr.ValueStateKnown

	return nil
}

func (v *ProbeValue) MergeWith(other *ProbeValue) {

	if (v.Path.IsUnknown() || v.Path.IsNull()) && !other.Path.IsUnknown() {
		v.Path = other.Path
	}

	if (v.Port.IsUnknown() || v.Port.IsNull()) && !other.Port.IsUnknown() {
		v.Port = other.Port
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v ProbeValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"path": v.Path,
		"port": v.Port,
	}
}
func (v ProbeValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["path"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["port"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Path.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["path"] = val

		val, err = v.Port.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ProbeValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ProbeValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ProbeValue) String() string {
	return "ProbeValue"
}

func (v ProbeValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"path": ovhtypes.TfStringType{},
			"port": ovhtypes.TfInt64Type{},
		},
		map[string]attr.Value{
			"path": v.Path,
			"port": v.Port,
		})

	return objVal, diags
}

func (v ProbeValue) Equal(o attr.Value) bool {
	other, ok := o.(ProbeValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Path.Equal(other.Path) {
		return false
	}

	if !v.Port.Equal(other.Port) {
		return false
	}

	return true
}

func (v ProbeValue) Type(ctx context.Context) attr.Type {
	return ProbeType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ProbeValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"path": ovhtypes.TfStringType{},
		"port": ovhtypes.TfInt64Type{},
	}
}

var _ basetypes.ObjectTypable = ResourcesType{}

type ResourcesType struct {
	basetypes.ObjectType
}

func (t ResourcesType) Equal(o attr.Type) bool {
	other, ok := o.(ResourcesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ResourcesType) String() string {
	return "ResourcesType"
}

func (t ResourcesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	cpuAttribute, ok := attributes["cpu"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cpu is missing from object`)

		return nil, diags
	}

	cpuVal, ok := cpuAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cpu expected to be ovhtypes.TfInt64Value, was: %T`, cpuAttribute))
	}

	ephemeralStorageAttribute, ok := attributes["ephemeral_storage"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ephemeral_storage is missing from object`)

		return nil, diags
	}

	ephemeralStorageVal, ok := ephemeralStorageAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ephemeral_storage expected to be ovhtypes.TfInt64Value, was: %T`, ephemeralStorageAttribute))
	}

	flavorAttribute, ok := attributes["flavor"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`flavor is missing from object`)

		return nil, diags
	}

	flavorVal, ok := flavorAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`flavor expected to be ovhtypes.TfStringValue, was: %T`, flavorAttribute))
	}

	gpuAttribute, ok := attributes["gpu"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gpu is missing from object`)

		return nil, diags
	}

	gpuVal, ok := gpuAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gpu expected to be ovhtypes.TfInt64Value, was: %T`, gpuAttribute))
	}

	gpuBrandAttribute, ok := attributes["gpu_brand"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gpu_brand is missing from object`)

		return nil, diags
	}

	gpuBrandVal, ok := gpuBrandAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gpu_brand expected to be ovhtypes.TfStringValue, was: %T`, gpuBrandAttribute))
	}

	gpuMemoryAttribute, ok := attributes["gpu_memory"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gpu_memory is missing from object`)

		return nil, diags
	}

	gpuMemoryVal, ok := gpuMemoryAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gpu_memory expected to be ovhtypes.TfInt64Value, was: %T`, gpuMemoryAttribute))
	}

	gpuModelAttribute, ok := attributes["gpu_model"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gpu_model is missing from object`)

		return nil, diags
	}

	gpuModelVal, ok := gpuModelAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gpu_model expected to be ovhtypes.TfStringValue, was: %T`, gpuModelAttribute))
	}

	memoryAttribute, ok := attributes["memory"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`memory is missing from object`)

		return nil, diags
	}

	memoryVal, ok := memoryAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`memory expected to be ovhtypes.TfInt64Value, was: %T`, memoryAttribute))
	}

	privateNetworkAttribute, ok := attributes["private_network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`private_network is missing from object`)

		return nil, diags
	}

	privateNetworkVal, ok := privateNetworkAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`private_network expected to be ovhtypes.TfInt64Value, was: %T`, privateNetworkAttribute))
	}

	publicNetworkAttribute, ok := attributes["public_network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`public_network is missing from object`)

		return nil, diags
	}

	publicNetworkVal, ok := publicNetworkAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`public_network expected to be ovhtypes.TfInt64Value, was: %T`, publicNetworkAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ResourcesValue{
		Cpu:              cpuVal,
		EphemeralStorage: ephemeralStorageVal,
		Flavor:           flavorVal,
		Gpu:              gpuVal,
		GpuBrand:         gpuBrandVal,
		GpuMemory:        gpuMemoryVal,
		GpuModel:         gpuModelVal,
		Memory:           memoryVal,
		PrivateNetwork:   privateNetworkVal,
		PublicNetwork:    publicNetworkVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewResourcesValueNull() ResourcesValue {
	return ResourcesValue{
		state: attr.ValueStateNull,
	}
}

func NewResourcesValueUnknown() ResourcesValue {
	return ResourcesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewResourcesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ResourcesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ResourcesValue Attribute Value",
				"While creating a ResourcesValue value, a missing attribute value was detected. "+
					"A ResourcesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ResourcesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ResourcesValue Attribute Type",
				"While creating a ResourcesValue value, an invalid attribute value was detected. "+
					"A ResourcesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ResourcesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ResourcesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ResourcesValue Attribute Value",
				"While creating a ResourcesValue value, an extra attribute value was detected. "+
					"A ResourcesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ResourcesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewResourcesValueUnknown(), diags
	}

	cpuAttribute, ok := attributes["cpu"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cpu is missing from object`)

		return NewResourcesValueUnknown(), diags
	}

	cpuVal, ok := cpuAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cpu expected to be ovhtypes.TfInt64Value, was: %T`, cpuAttribute))
	}

	ephemeralStorageAttribute, ok := attributes["ephemeral_storage"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ephemeral_storage is missing from object`)

		return NewResourcesValueUnknown(), diags
	}

	ephemeralStorageVal, ok := ephemeralStorageAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ephemeral_storage expected to be ovhtypes.TfInt64Value, was: %T`, ephemeralStorageAttribute))
	}

	flavorAttribute, ok := attributes["flavor"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`flavor is missing from object`)

		return NewResourcesValueUnknown(), diags
	}

	flavorVal, ok := flavorAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`flavor expected to be ovhtypes.TfStringValue, was: %T`, flavorAttribute))
	}

	gpuAttribute, ok := attributes["gpu"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gpu is missing from object`)

		return NewResourcesValueUnknown(), diags
	}

	gpuVal, ok := gpuAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gpu expected to be ovhtypes.TfInt64Value, was: %T`, gpuAttribute))
	}

	gpuBrandAttribute, ok := attributes["gpu_brand"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gpu_brand is missing from object`)

		return NewResourcesValueUnknown(), diags
	}

	gpuBrandVal, ok := gpuBrandAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gpu_brand expected to be ovhtypes.TfStringValue, was: %T`, gpuBrandAttribute))
	}

	gpuMemoryAttribute, ok := attributes["gpu_memory"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gpu_memory is missing from object`)

		return NewResourcesValueUnknown(), diags
	}

	gpuMemoryVal, ok := gpuMemoryAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gpu_memory expected to be ovhtypes.TfInt64Value, was: %T`, gpuMemoryAttribute))
	}

	gpuModelAttribute, ok := attributes["gpu_model"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gpu_model is missing from object`)

		return NewResourcesValueUnknown(), diags
	}

	gpuModelVal, ok := gpuModelAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gpu_model expected to be ovhtypes.TfStringValue, was: %T`, gpuModelAttribute))
	}

	memoryAttribute, ok := attributes["memory"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`memory is missing from object`)

		return NewResourcesValueUnknown(), diags
	}

	memoryVal, ok := memoryAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`memory expected to be ovhtypes.TfInt64Value, was: %T`, memoryAttribute))
	}

	privateNetworkAttribute, ok := attributes["private_network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`private_network is missing from object`)

		return NewResourcesValueUnknown(), diags
	}

	privateNetworkVal, ok := privateNetworkAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`private_network expected to be ovhtypes.TfInt64Value, was: %T`, privateNetworkAttribute))
	}

	publicNetworkAttribute, ok := attributes["public_network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`public_network is missing from object`)

		return NewResourcesValueUnknown(), diags
	}

	publicNetworkVal, ok := publicNetworkAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`public_network expected to be ovhtypes.TfInt64Value, was: %T`, publicNetworkAttribute))
	}

	if diags.HasError() {
		return NewResourcesValueUnknown(), diags
	}

	return ResourcesValue{
		Cpu:              cpuVal,
		EphemeralStorage: ephemeralStorageVal,
		Flavor:           flavorVal,
		Gpu:              gpuVal,
		GpuBrand:         gpuBrandVal,
		GpuMemory:        gpuMemoryVal,
		GpuModel:         gpuModelVal,
		Memory:           memoryVal,
		PrivateNetwork:   privateNetworkVal,
		PublicNetwork:    publicNetworkVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewResourcesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ResourcesValue {
	object, diags := NewResourcesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewResourcesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ResourcesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewResourcesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewResourcesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewResourcesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewResourcesValueMust(ResourcesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ResourcesType) ValueType(ctx context.Context) attr.Value {
	return ResourcesValue{}
}

var _ basetypes.ObjectValuable = ResourcesValue{}

type ResourcesValue struct {
	Cpu              ovhtypes.TfInt64Value  `tfsdk:"cpu" json:"cpu"`
	EphemeralStorage ovhtypes.TfInt64Value  `tfsdk:"ephemeral_storage" json:"ephemeralStorage"`
	Flavor           ovhtypes.TfStringValue `tfsdk:"flavor" json:"flavor"`
	Gpu              ovhtypes.TfInt64Value  `tfsdk:"gpu" json:"gpu"`
	GpuBrand         ovhtypes.TfStringValue `tfsdk:"gpu_brand" json:"gpuBrand"`
	GpuMemory        ovhtypes.TfInt64Value  `tfsdk:"gpu_memory" json:"gpuMemory"`
	GpuModel         ovhtypes.TfStringValue `tfsdk:"gpu_model" json:"gpuModel"`
	Memory           ovhtypes.TfInt64Value  `tfsdk:"memory" json:"memory"`
	PrivateNetwork   ovhtypes.TfInt64Value  `tfsdk:"private_network" json:"privateNetwork"`
	PublicNetwork    ovhtypes.TfInt64Value  `tfsdk:"public_network" json:"publicNetwork"`
	state            attr.ValueState
}

func (v ResourcesValue) ToCreate() *ResourcesValue {
	res := &ResourcesValue{}

	if !v.GpuMemory.IsNull() {
		res.GpuMemory = v.GpuMemory
	}

	if !v.Flavor.IsNull() {
		res.Flavor = v.Flavor
	}

	if !v.PrivateNetwork.IsNull() {
		res.PrivateNetwork = v.PrivateNetwork
	}

	if !v.PublicNetwork.IsNull() {
		res.PublicNetwork = v.PublicNetwork
	}

	if !v.GpuBrand.IsNull() {
		res.GpuBrand = v.GpuBrand
	}

	if !v.GpuModel.IsNull() {
		res.GpuModel = v.GpuModel
	}

	if !v.Cpu.IsNull() {
		res.Cpu = v.Cpu
	}

	if !v.EphemeralStorage.IsNull() {
		res.EphemeralStorage = v.EphemeralStorage
	}

	if !v.Memory.IsNull() {
		res.Memory = v.Memory
	}

	if !v.Gpu.IsNull() {
		res.Gpu = v.Gpu
	}

	res.state = attr.ValueStateKnown

	return res
}

func (v ResourcesValue) MarshalJSON() ([]byte, error) {
	toMarshal := map[string]any{}
	if !v.Cpu.IsNull() && !v.Cpu.IsUnknown() {
		toMarshal["cpu"] = v.Cpu
	}
	if !v.EphemeralStorage.IsNull() && !v.EphemeralStorage.IsUnknown() {
		toMarshal["ephemeralStorage"] = v.EphemeralStorage
	}
	if !v.Flavor.IsNull() && !v.Flavor.IsUnknown() {
		toMarshal["flavor"] = v.Flavor
	}
	if !v.Gpu.IsNull() && !v.Gpu.IsUnknown() {
		toMarshal["gpu"] = v.Gpu
	}
	if !v.GpuBrand.IsNull() && !v.GpuBrand.IsUnknown() {
		toMarshal["gpuBrand"] = v.GpuBrand
	}
	if !v.GpuMemory.IsNull() && !v.GpuMemory.IsUnknown() {
		toMarshal["gpuMemory"] = v.GpuMemory
	}
	if !v.GpuModel.IsNull() && !v.GpuModel.IsUnknown() {
		toMarshal["gpuModel"] = v.GpuModel
	}
	if !v.Memory.IsNull() && !v.Memory.IsUnknown() {
		toMarshal["memory"] = v.Memory
	}
	if !v.PrivateNetwork.IsNull() && !v.PrivateNetwork.IsUnknown() {
		toMarshal["privateNetwork"] = v.PrivateNetwork
	}
	if !v.PublicNetwork.IsNull() && !v.PublicNetwork.IsUnknown() {
		toMarshal["publicNetwork"] = v.PublicNetwork
	}

	return json.Marshal(toMarshal)
}

func (v *ResourcesValue) UnmarshalJSON(data []byte) error {
	type JsonResourcesValue ResourcesValue

	var tmp JsonResourcesValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.Cpu = tmp.Cpu
	v.EphemeralStorage = tmp.EphemeralStorage
	v.Flavor = tmp.Flavor
	v.Gpu = tmp.Gpu
	v.GpuBrand = tmp.GpuBrand
	v.GpuMemory = tmp.GpuMemory
	v.GpuModel = tmp.GpuModel
	v.Memory = tmp.Memory
	v.PrivateNetwork = tmp.PrivateNetwork
	v.PublicNetwork = tmp.PublicNetwork

	v.state = attr.ValueStateKnown

	return nil
}

func (v *ResourcesValue) MergeWith(other *ResourcesValue) {

	if (v.Cpu.IsUnknown() || v.Cpu.IsNull()) && !other.Cpu.IsUnknown() {
		v.Cpu = other.Cpu
	}

	if (v.EphemeralStorage.IsUnknown() || v.EphemeralStorage.IsNull()) && !other.EphemeralStorage.IsUnknown() {
		v.EphemeralStorage = other.EphemeralStorage
	}

	if (v.Flavor.IsUnknown() || v.Flavor.IsNull()) && !other.Flavor.IsUnknown() {
		v.Flavor = other.Flavor
	}

	if (v.Gpu.IsUnknown() || v.Gpu.IsNull()) && !other.Gpu.IsUnknown() {
		v.Gpu = other.Gpu
	}

	if (v.GpuBrand.IsUnknown() || v.GpuBrand.IsNull()) && !other.GpuBrand.IsUnknown() {
		v.GpuBrand = other.GpuBrand
	}

	if (v.GpuMemory.IsUnknown() || v.GpuMemory.IsNull()) && !other.GpuMemory.IsUnknown() {
		v.GpuMemory = other.GpuMemory
	}

	if (v.GpuModel.IsUnknown() || v.GpuModel.IsNull()) && !other.GpuModel.IsUnknown() {
		v.GpuModel = other.GpuModel
	}

	if (v.Memory.IsUnknown() || v.Memory.IsNull()) && !other.Memory.IsUnknown() {
		v.Memory = other.Memory
	}

	if (v.PrivateNetwork.IsUnknown() || v.PrivateNetwork.IsNull()) && !other.PrivateNetwork.IsUnknown() {
		v.PrivateNetwork = other.PrivateNetwork
	}

	if (v.PublicNetwork.IsUnknown() || v.PublicNetwork.IsNull()) && !other.PublicNetwork.IsUnknown() {
		v.PublicNetwork = other.PublicNetwork
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v ResourcesValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"cpu":              v.Cpu,
		"ephemeralStorage": v.EphemeralStorage,
		"flavor":           v.Flavor,
		"gpu":              v.Gpu,
		"gpuBrand":         v.GpuBrand,
		"gpuMemory":        v.GpuMemory,
		"gpuModel":         v.GpuModel,
		"memory":           v.Memory,
		"privateNetwork":   v.PrivateNetwork,
		"publicNetwork":    v.PublicNetwork,
	}
}
func (v ResourcesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 10)

	var val tftypes.Value
	var err error

	attrTypes["cpu"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["ephemeral_storage"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["flavor"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["gpu"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["gpu_brand"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["gpu_memory"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["gpu_model"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["memory"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["private_network"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["public_network"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 10)

		val, err = v.Cpu.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cpu"] = val

		val, err = v.EphemeralStorage.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ephemeral_storage"] = val

		val, err = v.Flavor.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["flavor"] = val

		val, err = v.Gpu.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["gpu"] = val

		val, err = v.GpuBrand.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["gpu_brand"] = val

		val, err = v.GpuMemory.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["gpu_memory"] = val

		val, err = v.GpuModel.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["gpu_model"] = val

		val, err = v.Memory.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["memory"] = val

		val, err = v.PrivateNetwork.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["private_network"] = val

		val, err = v.PublicNetwork.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["public_network"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ResourcesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ResourcesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ResourcesValue) String() string {
	return "ResourcesValue"
}

func (v ResourcesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"cpu":               ovhtypes.TfInt64Type{},
			"ephemeral_storage": ovhtypes.TfInt64Type{},
			"flavor":            ovhtypes.TfStringType{},
			"gpu":               ovhtypes.TfInt64Type{},
			"gpu_brand":         ovhtypes.TfStringType{},
			"gpu_memory":        ovhtypes.TfInt64Type{},
			"gpu_model":         ovhtypes.TfStringType{},
			"memory":            ovhtypes.TfInt64Type{},
			"private_network":   ovhtypes.TfInt64Type{},
			"public_network":    ovhtypes.TfInt64Type{},
		},
		map[string]attr.Value{
			"cpu":               v.Cpu,
			"ephemeral_storage": v.EphemeralStorage,
			"flavor":            v.Flavor,
			"gpu":               v.Gpu,
			"gpu_brand":         v.GpuBrand,
			"gpu_memory":        v.GpuMemory,
			"gpu_model":         v.GpuModel,
			"memory":            v.Memory,
			"private_network":   v.PrivateNetwork,
			"public_network":    v.PublicNetwork,
		})

	return objVal, diags
}

func (v ResourcesValue) Equal(o attr.Value) bool {
	other, ok := o.(ResourcesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Cpu.Equal(other.Cpu) {
		return false
	}

	if !v.EphemeralStorage.Equal(other.EphemeralStorage) {
		return false
	}

	if !v.Flavor.Equal(other.Flavor) {
		return false
	}

	if !v.Gpu.Equal(other.Gpu) {
		return false
	}

	if !v.GpuBrand.Equal(other.GpuBrand) {
		return false
	}

	if !v.GpuMemory.Equal(other.GpuMemory) {
		return false
	}

	if !v.GpuModel.Equal(other.GpuModel) {
		return false
	}

	if !v.Memory.Equal(other.Memory) {
		return false
	}

	if !v.PrivateNetwork.Equal(other.PrivateNetwork) {
		return false
	}

	if !v.PublicNetwork.Equal(other.PublicNetwork) {
		return false
	}

	return true
}

func (v ResourcesValue) Type(ctx context.Context) attr.Type {
	return ResourcesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ResourcesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"cpu":               ovhtypes.TfInt64Type{},
		"ephemeral_storage": ovhtypes.TfInt64Type{},
		"flavor":            ovhtypes.TfStringType{},
		"gpu":               ovhtypes.TfInt64Type{},
		"gpu_brand":         ovhtypes.TfStringType{},
		"gpu_memory":        ovhtypes.TfInt64Type{},
		"gpu_model":         ovhtypes.TfStringType{},
		"memory":            ovhtypes.TfInt64Type{},
		"private_network":   ovhtypes.TfInt64Type{},
		"public_network":    ovhtypes.TfInt64Type{},
	}
}

var _ basetypes.ObjectTypable = ScalingStrategyType{}

type ScalingStrategyType struct {
	basetypes.ObjectType
}

func (t ScalingStrategyType) Equal(o attr.Type) bool {
	other, ok := o.(ScalingStrategyType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ScalingStrategyType) String() string {
	return "ScalingStrategyType"
}

func (t ScalingStrategyType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	automaticAttribute, ok := attributes["automatic"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`automatic is missing from object`)

		return nil, diags
	}

	automaticVal, ok := automaticAttribute.(ScalingStrategyAutomaticValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`automatic expected to be ScalingStrategyAutomaticValue, was: %T`, automaticAttribute))
	}

	fixedAttribute, ok := attributes["fixed"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fixed is missing from object`)

		return nil, diags
	}

	fixedVal, ok := fixedAttribute.(ScalingStrategyFixedValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fixed expected to be ScalingStrategyFixedValue, was: %T`, fixedAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ScalingStrategyValue{
		Automatic: automaticVal,
		Fixed:     fixedVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewScalingStrategyValueNull() ScalingStrategyValue {
	return ScalingStrategyValue{
		state: attr.ValueStateNull,
	}
}

func NewScalingStrategyValueUnknown() ScalingStrategyValue {
	return ScalingStrategyValue{
		state: attr.ValueStateUnknown,
	}
}

func NewScalingStrategyValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ScalingStrategyValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ScalingStrategyValue Attribute Value",
				"While creating a ScalingStrategyValue value, a missing attribute value was detected. "+
					"A ScalingStrategyValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ScalingStrategyValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ScalingStrategyValue Attribute Type",
				"While creating a ScalingStrategyValue value, an invalid attribute value was detected. "+
					"A ScalingStrategyValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ScalingStrategyValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ScalingStrategyValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ScalingStrategyValue Attribute Value",
				"While creating a ScalingStrategyValue value, an extra attribute value was detected. "+
					"A ScalingStrategyValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ScalingStrategyValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewScalingStrategyValueUnknown(), diags
	}

	automaticAttribute, ok := attributes["automatic"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`automatic is missing from object`)

		return NewScalingStrategyValueUnknown(), diags
	}

	automaticVal, ok := automaticAttribute.(ScalingStrategyAutomaticValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`automatic expected to be ScalingStrategyAutomaticValue, was: %T`, automaticAttribute))
	}

	fixedAttribute, ok := attributes["fixed"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fixed is missing from object`)

		return NewScalingStrategyValueUnknown(), diags
	}

	fixedVal, ok := fixedAttribute.(ScalingStrategyFixedValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fixed expected to be ScalingStrategyFixedValue, was: %T`, fixedAttribute))
	}

	if diags.HasError() {
		return NewScalingStrategyValueUnknown(), diags
	}

	return ScalingStrategyValue{
		Automatic: automaticVal,
		Fixed:     fixedVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewScalingStrategyValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ScalingStrategyValue {
	object, diags := NewScalingStrategyValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewScalingStrategyValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ScalingStrategyType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewScalingStrategyValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewScalingStrategyValueUnknown(), nil
	}

	if in.IsNull() {
		return NewScalingStrategyValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewScalingStrategyValueMust(ScalingStrategyValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ScalingStrategyType) ValueType(ctx context.Context) attr.Value {
	return ScalingStrategyValue{}
}

var _ basetypes.ObjectValuable = ScalingStrategyValue{}

type ScalingStrategyValue struct {
	Automatic ScalingStrategyAutomaticValue `tfsdk:"automatic" json:"automatic"`
	Fixed     ScalingStrategyFixedValue     `tfsdk:"fixed" json:"fixed"`
	state     attr.ValueState
}

func (v ScalingStrategyValue) ToCreate() *ScalingStrategyValue {
	res := &ScalingStrategyValue{}

	if !v.Fixed.IsNull() {
		res.Fixed = v.Fixed
	}

	if !v.Automatic.IsNull() {
		res.Automatic = v.Automatic
	}

	res.state = attr.ValueStateKnown

	return res
}

func (v ScalingStrategyValue) MarshalJSON() ([]byte, error) {
	toMarshal := map[string]any{}
	if !v.Automatic.IsNull() && !v.Automatic.IsUnknown() {
		toMarshal["automatic"] = v.Automatic
	}
	if !v.Fixed.IsNull() && !v.Fixed.IsUnknown() {
		toMarshal["fixed"] = v.Fixed
	}

	return json.Marshal(toMarshal)
}

func (v *ScalingStrategyValue) UnmarshalJSON(data []byte) error {
	type JsonScalingStrategyValue ScalingStrategyValue

	var tmp JsonScalingStrategyValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.Automatic = tmp.Automatic
	v.Fixed = tmp.Fixed

	v.state = attr.ValueStateKnown

	return nil
}

func (v *ScalingStrategyValue) MergeWith(other *ScalingStrategyValue) {

	if v.Automatic.IsUnknown() && !other.Automatic.IsUnknown() {
		v.Automatic = other.Automatic
	} else if !other.Automatic.IsUnknown() {
		v.Automatic.MergeWith(&other.Automatic)
	}

	if v.Fixed.IsUnknown() && !other.Fixed.IsUnknown() {
		v.Fixed = other.Fixed
	} else if !other.Fixed.IsUnknown() {
		v.Fixed.MergeWith(&other.Fixed)
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v ScalingStrategyValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"automatic": v.Automatic,
		"fixed":     v.Fixed,
	}
}
func (v ScalingStrategyValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["automatic"] = basetypes.ObjectType{
		AttrTypes: ScalingStrategyAutomaticValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["fixed"] = basetypes.ObjectType{
		AttrTypes: ScalingStrategyFixedValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Automatic.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["automatic"] = val

		val, err = v.Fixed.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["fixed"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ScalingStrategyValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ScalingStrategyValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ScalingStrategyValue) String() string {
	return "ScalingStrategyValue"
}

func (v ScalingStrategyValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"automatic": ScalingStrategyAutomaticType{
				basetypes.ObjectType{
					AttrTypes: ScalingStrategyAutomaticValue{}.AttributeTypes(ctx),
				},
			},
			"fixed": ScalingStrategyFixedType{
				basetypes.ObjectType{
					AttrTypes: ScalingStrategyFixedValue{}.AttributeTypes(ctx),
				},
			},
		},
		map[string]attr.Value{
			"automatic": v.Automatic,
			"fixed":     v.Fixed,
		})

	return objVal, diags
}

func (v ScalingStrategyValue) Equal(o attr.Value) bool {
	other, ok := o.(ScalingStrategyValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Automatic.Equal(other.Automatic) {
		return false
	}

	if !v.Fixed.Equal(other.Fixed) {
		return false
	}

	return true
}

func (v ScalingStrategyValue) Type(ctx context.Context) attr.Type {
	return ScalingStrategyType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ScalingStrategyValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"automatic": ScalingStrategyAutomaticValue{}.Type(ctx),
		"fixed":     ScalingStrategyFixedValue{}.Type(ctx),
	}
}

var _ basetypes.ObjectTypable = ScalingStrategyAutomaticType{}

type ScalingStrategyAutomaticType struct {
	basetypes.ObjectType
}

func (t ScalingStrategyAutomaticType) Equal(o attr.Type) bool {
	other, ok := o.(ScalingStrategyAutomaticType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ScalingStrategyAutomaticType) String() string {
	return "ScalingStrategyAutomaticType"
}

func (t ScalingStrategyAutomaticType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	averageUsageTargetAttribute, ok := attributes["average_usage_target"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`average_usage_target is missing from object`)

		return nil, diags
	}

	averageUsageTargetVal, ok := averageUsageTargetAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`average_usage_target expected to be ovhtypes.TfInt64Value, was: %T`, averageUsageTargetAttribute))
	}

	replicasMaxAttribute, ok := attributes["replicas_max"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`replicas_max is missing from object`)

		return nil, diags
	}

	replicasMaxVal, ok := replicasMaxAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`replicas_max expected to be ovhtypes.TfInt64Value, was: %T`, replicasMaxAttribute))
	}

	replicasMinAttribute, ok := attributes["replicas_min"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`replicas_min is missing from object`)

		return nil, diags
	}

	replicasMinVal, ok := replicasMinAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`replicas_min expected to be ovhtypes.TfInt64Value, was: %T`, replicasMinAttribute))
	}

	resourceTypeAttribute, ok := attributes["resource_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`resource_type is missing from object`)

		return nil, diags
	}

	resourceTypeVal, ok := resourceTypeAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`resource_type expected to be ovhtypes.TfStringValue, was: %T`, resourceTypeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ScalingStrategyAutomaticValue{
		AverageUsageTarget: averageUsageTargetVal,
		ReplicasMax:        replicasMaxVal,
		ReplicasMin:        replicasMinVal,
		ResourceType:       resourceTypeVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewScalingStrategyAutomaticValueNull() ScalingStrategyAutomaticValue {
	return ScalingStrategyAutomaticValue{
		state: attr.ValueStateNull,
	}
}

func NewScalingStrategyAutomaticValueUnknown() ScalingStrategyAutomaticValue {
	return ScalingStrategyAutomaticValue{
		state: attr.ValueStateUnknown,
	}
}

func NewScalingStrategyAutomaticValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ScalingStrategyAutomaticValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ScalingStrategyAutomaticValue Attribute Value",
				"While creating a ScalingStrategyAutomaticValue value, a missing attribute value was detected. "+
					"A ScalingStrategyAutomaticValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ScalingStrategyAutomaticValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ScalingStrategyAutomaticValue Attribute Type",
				"While creating a ScalingStrategyAutomaticValue value, an invalid attribute value was detected. "+
					"A ScalingStrategyAutomaticValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ScalingStrategyAutomaticValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ScalingStrategyAutomaticValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ScalingStrategyAutomaticValue Attribute Value",
				"While creating a ScalingStrategyAutomaticValue value, an extra attribute value was detected. "+
					"A ScalingStrategyAutomaticValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ScalingStrategyAutomaticValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewScalingStrategyAutomaticValueUnknown(), diags
	}

	averageUsageTargetAttribute, ok := attributes["average_usage_target"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`average_usage_target is missing from object`)

		return NewScalingStrategyAutomaticValueUnknown(), diags
	}

	averageUsageTargetVal, ok := averageUsageTargetAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`average_usage_target expected to be ovhtypes.TfInt64Value, was: %T`, averageUsageTargetAttribute))
	}

	replicasMaxAttribute, ok := attributes["replicas_max"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`replicas_max is missing from object`)

		return NewScalingStrategyAutomaticValueUnknown(), diags
	}

	replicasMaxVal, ok := replicasMaxAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`replicas_max expected to be ovhtypes.TfInt64Value, was: %T`, replicasMaxAttribute))
	}

	replicasMinAttribute, ok := attributes["replicas_min"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`replicas_min is missing from object`)

		return NewScalingStrategyAutomaticValueUnknown(), diags
	}

	replicasMinVal, ok := replicasMinAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`replicas_min expected to be ovhtypes.TfInt64Value, was: %T`, replicasMinAttribute))
	}

	resourceTypeAttribute, ok := attributes["resource_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`resource_type is missing from object`)

		return NewScalingStrategyAutomaticValueUnknown(), diags
	}

	resourceTypeVal, ok := resourceTypeAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`resource_type expected to be ovhtypes.TfStringValue, was: %T`, resourceTypeAttribute))
	}

	if diags.HasError() {
		return NewScalingStrategyAutomaticValueUnknown(), diags
	}

	return ScalingStrategyAutomaticValue{
		AverageUsageTarget: averageUsageTargetVal,
		ReplicasMax:        replicasMaxVal,
		ReplicasMin:        replicasMinVal,
		ResourceType:       resourceTypeVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewScalingStrategyAutomaticValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ScalingStrategyAutomaticValue {
	object, diags := NewScalingStrategyAutomaticValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewScalingStrategyAutomaticValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ScalingStrategyAutomaticType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewScalingStrategyAutomaticValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewScalingStrategyAutomaticValueUnknown(), nil
	}

	if in.IsNull() {
		return NewScalingStrategyAutomaticValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewScalingStrategyAutomaticValueMust(ScalingStrategyAutomaticValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ScalingStrategyAutomaticType) ValueType(ctx context.Context) attr.Value {
	return ScalingStrategyAutomaticValue{}
}

var _ basetypes.ObjectValuable = ScalingStrategyAutomaticValue{}

type ScalingStrategyAutomaticValue struct {
	AverageUsageTarget ovhtypes.TfInt64Value  `tfsdk:"average_usage_target" json:"averageUsageTarget"`
	ReplicasMax        ovhtypes.TfInt64Value  `tfsdk:"replicas_max" json:"replicasMax"`
	ReplicasMin        ovhtypes.TfInt64Value  `tfsdk:"replicas_min" json:"replicasMin"`
	ResourceType       ovhtypes.TfStringValue `tfsdk:"resource_type" json:"resourceType"`
	state              attr.ValueState
}

func (v ScalingStrategyAutomaticValue) ToCreate() *ScalingStrategyAutomaticValue {
	res := &ScalingStrategyAutomaticValue{}

	if !v.ResourceType.IsNull() {
		res.ResourceType = v.ResourceType
	}

	if !v.AverageUsageTarget.IsNull() {
		res.AverageUsageTarget = v.AverageUsageTarget
	}

	if !v.ReplicasMax.IsNull() {
		res.ReplicasMax = v.ReplicasMax
	}

	if !v.ReplicasMin.IsNull() {
		res.ReplicasMin = v.ReplicasMin
	}

	res.state = attr.ValueStateKnown

	return res
}

func (v ScalingStrategyAutomaticValue) MarshalJSON() ([]byte, error) {
	toMarshal := map[string]any{}
	if !v.AverageUsageTarget.IsNull() && !v.AverageUsageTarget.IsUnknown() {
		toMarshal["averageUsageTarget"] = v.AverageUsageTarget
	}
	if !v.ReplicasMax.IsNull() && !v.ReplicasMax.IsUnknown() {
		toMarshal["replicasMax"] = v.ReplicasMax
	}
	if !v.ReplicasMin.IsNull() && !v.ReplicasMin.IsUnknown() {
		toMarshal["replicasMin"] = v.ReplicasMin
	}
	if !v.ResourceType.IsNull() && !v.ResourceType.IsUnknown() {
		toMarshal["resourceType"] = v.ResourceType
	}

	return json.Marshal(toMarshal)
}

func (v *ScalingStrategyAutomaticValue) UnmarshalJSON(data []byte) error {
	type JsonScalingStrategyAutomaticValue ScalingStrategyAutomaticValue

	var tmp JsonScalingStrategyAutomaticValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.AverageUsageTarget = tmp.AverageUsageTarget
	v.ReplicasMax = tmp.ReplicasMax
	v.ReplicasMin = tmp.ReplicasMin
	v.ResourceType = tmp.ResourceType

	v.state = attr.ValueStateKnown

	return nil
}

func (v *ScalingStrategyAutomaticValue) MergeWith(other *ScalingStrategyAutomaticValue) {

	if (v.AverageUsageTarget.IsUnknown() || v.AverageUsageTarget.IsNull()) && !other.AverageUsageTarget.IsUnknown() {
		v.AverageUsageTarget = other.AverageUsageTarget
	}

	if (v.ReplicasMax.IsUnknown() || v.ReplicasMax.IsNull()) && !other.ReplicasMax.IsUnknown() {
		v.ReplicasMax = other.ReplicasMax
	}

	if (v.ReplicasMin.IsUnknown() || v.ReplicasMin.IsNull()) && !other.ReplicasMin.IsUnknown() {
		v.ReplicasMin = other.ReplicasMin
	}

	if (v.ResourceType.IsUnknown() || v.ResourceType.IsNull()) && !other.ResourceType.IsUnknown() {
		v.ResourceType = other.ResourceType
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v ScalingStrategyAutomaticValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"averageUsageTarget": v.AverageUsageTarget,
		"replicasMax":        v.ReplicasMax,
		"replicasMin":        v.ReplicasMin,
		"resourceType":       v.ResourceType,
	}
}
func (v ScalingStrategyAutomaticValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["average_usage_target"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["replicas_max"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["replicas_min"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["resource_type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.AverageUsageTarget.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["average_usage_target"] = val

		val, err = v.ReplicasMax.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["replicas_max"] = val

		val, err = v.ReplicasMin.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["replicas_min"] = val

		val, err = v.ResourceType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["resource_type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ScalingStrategyAutomaticValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ScalingStrategyAutomaticValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ScalingStrategyAutomaticValue) String() string {
	return "ScalingStrategyAutomaticValue"
}

func (v ScalingStrategyAutomaticValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"average_usage_target": ovhtypes.TfInt64Type{},
			"replicas_max":         ovhtypes.TfInt64Type{},
			"replicas_min":         ovhtypes.TfInt64Type{},
			"resource_type":        ovhtypes.TfStringType{},
		},
		map[string]attr.Value{
			"average_usage_target": v.AverageUsageTarget,
			"replicas_max":         v.ReplicasMax,
			"replicas_min":         v.ReplicasMin,
			"resource_type":        v.ResourceType,
		})

	return objVal, diags
}

func (v ScalingStrategyAutomaticValue) Equal(o attr.Value) bool {
	other, ok := o.(ScalingStrategyAutomaticValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AverageUsageTarget.Equal(other.AverageUsageTarget) {
		return false
	}

	if !v.ReplicasMax.Equal(other.ReplicasMax) {
		return false
	}

	if !v.ReplicasMin.Equal(other.ReplicasMin) {
		return false
	}

	if !v.ResourceType.Equal(other.ResourceType) {
		return false
	}

	return true
}

func (v ScalingStrategyAutomaticValue) Type(ctx context.Context) attr.Type {
	return ScalingStrategyAutomaticType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ScalingStrategyAutomaticValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"average_usage_target": ovhtypes.TfInt64Type{},
		"replicas_max":         ovhtypes.TfInt64Type{},
		"replicas_min":         ovhtypes.TfInt64Type{},
		"resource_type":        ovhtypes.TfStringType{},
	}
}

var _ basetypes.ObjectTypable = ScalingStrategyFixedType{}

type ScalingStrategyFixedType struct {
	basetypes.ObjectType
}

func (t ScalingStrategyFixedType) Equal(o attr.Type) bool {
	other, ok := o.(ScalingStrategyFixedType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ScalingStrategyFixedType) String() string {
	return "ScalingStrategyFixedType"
}

func (t ScalingStrategyFixedType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	replicasAttribute, ok := attributes["replicas"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`replicas is missing from object`)

		return nil, diags
	}

	replicasVal, ok := replicasAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`replicas expected to be ovhtypes.TfInt64Value, was: %T`, replicasAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ScalingStrategyFixedValue{
		Replicas: replicasVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewScalingStrategyFixedValueNull() ScalingStrategyFixedValue {
	return ScalingStrategyFixedValue{
		state: attr.ValueStateNull,
	}
}

func NewScalingStrategyFixedValueUnknown() ScalingStrategyFixedValue {
	return ScalingStrategyFixedValue{
		state: attr.ValueStateUnknown,
	}
}

func NewScalingStrategyFixedValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ScalingStrategyFixedValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ScalingStrategyFixedValue Attribute Value",
				"While creating a ScalingStrategyFixedValue value, a missing attribute value was detected. "+
					"A ScalingStrategyFixedValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ScalingStrategyFixedValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ScalingStrategyFixedValue Attribute Type",
				"While creating a ScalingStrategyFixedValue value, an invalid attribute value was detected. "+
					"A ScalingStrategyFixedValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ScalingStrategyFixedValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ScalingStrategyFixedValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ScalingStrategyFixedValue Attribute Value",
				"While creating a ScalingStrategyFixedValue value, an extra attribute value was detected. "+
					"A ScalingStrategyFixedValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ScalingStrategyFixedValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewScalingStrategyFixedValueUnknown(), diags
	}

	replicasAttribute, ok := attributes["replicas"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`replicas is missing from object`)

		return NewScalingStrategyFixedValueUnknown(), diags
	}

	replicasVal, ok := replicasAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`replicas expected to be ovhtypes.TfInt64Value, was: %T`, replicasAttribute))
	}

	if diags.HasError() {
		return NewScalingStrategyFixedValueUnknown(), diags
	}

	return ScalingStrategyFixedValue{
		Replicas: replicasVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewScalingStrategyFixedValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ScalingStrategyFixedValue {
	object, diags := NewScalingStrategyFixedValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewScalingStrategyFixedValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ScalingStrategyFixedType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewScalingStrategyFixedValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewScalingStrategyFixedValueUnknown(), nil
	}

	if in.IsNull() {
		return NewScalingStrategyFixedValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewScalingStrategyFixedValueMust(ScalingStrategyFixedValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ScalingStrategyFixedType) ValueType(ctx context.Context) attr.Value {
	return ScalingStrategyFixedValue{}
}

var _ basetypes.ObjectValuable = ScalingStrategyFixedValue{}

type ScalingStrategyFixedValue struct {
	Replicas ovhtypes.TfInt64Value `tfsdk:"replicas" json:"replicas"`
	state    attr.ValueState
}

func (v ScalingStrategyFixedValue) ToCreate() *ScalingStrategyFixedValue {
	res := &ScalingStrategyFixedValue{}

	if !v.Replicas.IsNull() {
		res.Replicas = v.Replicas
	}

	res.state = attr.ValueStateKnown

	return res
}

func (v ScalingStrategyFixedValue) MarshalJSON() ([]byte, error) {
	toMarshal := map[string]any{}
	if !v.Replicas.IsNull() && !v.Replicas.IsUnknown() {
		toMarshal["replicas"] = v.Replicas
	}

	return json.Marshal(toMarshal)
}

func (v *ScalingStrategyFixedValue) UnmarshalJSON(data []byte) error {
	type JsonScalingStrategyFixedValue ScalingStrategyFixedValue

	var tmp JsonScalingStrategyFixedValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.Replicas = tmp.Replicas

	v.state = attr.ValueStateKnown

	return nil
}

func (v *ScalingStrategyFixedValue) MergeWith(other *ScalingStrategyFixedValue) {

	if (v.Replicas.IsUnknown() || v.Replicas.IsNull()) && !other.Replicas.IsUnknown() {
		v.Replicas = other.Replicas
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v ScalingStrategyFixedValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"replicas": v.Replicas,
	}
}
func (v ScalingStrategyFixedValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["replicas"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Replicas.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["replicas"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ScalingStrategyFixedValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ScalingStrategyFixedValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ScalingStrategyFixedValue) String() string {
	return "ScalingStrategyFixedValue"
}

func (v ScalingStrategyFixedValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"replicas": ovhtypes.TfInt64Type{},
		},
		map[string]attr.Value{
			"replicas": v.Replicas,
		})

	return objVal, diags
}

func (v ScalingStrategyFixedValue) Equal(o attr.Value) bool {
	other, ok := o.(ScalingStrategyFixedValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Replicas.Equal(other.Replicas) {
		return false
	}

	return true
}

func (v ScalingStrategyFixedValue) Type(ctx context.Context) attr.Type {
	return ScalingStrategyFixedType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ScalingStrategyFixedValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"replicas": ovhtypes.TfInt64Type{},
	}
}

var _ basetypes.ObjectTypable = SpecType{}

type SpecType struct {
	basetypes.ObjectType
}

func (t SpecType) Equal(o attr.Type) bool {
	other, ok := o.(SpecType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SpecType) String() string {
	return "SpecType"
}

func (t SpecType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	commandAttribute, ok := attributes["command"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`command is missing from object`)

		return nil, diags
	}

	commandVal, ok := commandAttribute.(ovhtypes.TfListNestedValue[ovhtypes.TfStringValue])

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`command expected to be ovhtypes.TfListNestedValue[ovhtypes.TfStringValue], was: %T`, commandAttribute))
	}

	defaultHttpPortAttribute, ok := attributes["default_http_port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`default_http_port is missing from object`)

		return nil, diags
	}

	defaultHttpPortVal, ok := defaultHttpPortAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`default_http_port expected to be ovhtypes.TfInt64Value, was: %T`, defaultHttpPortAttribute))
	}

	deploymentStrategyAttribute, ok := attributes["deployment_strategy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`deployment_strategy is missing from object`)

		return nil, diags
	}

	deploymentStrategyVal, ok := deploymentStrategyAttribute.(SpecDeploymentStrategyValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`deployment_strategy expected to be SpecDeploymentStrategyValue, was: %T`, deploymentStrategyAttribute))
	}

	envVarsAttribute, ok := attributes["env_vars"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`env_vars is missing from object`)

		return nil, diags
	}

	envVarsVal, ok := envVarsAttribute.(ovhtypes.TfListNestedValue[SpecEnvVarsValue])

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`env_vars expected to be ovhtypes.TfListNestedValue[SpecEnvVarsValue], was: %T`, envVarsAttribute))
	}

	grpcPortAttribute, ok := attributes["grpc_port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`grpc_port is missing from object`)

		return nil, diags
	}

	grpcPortVal, ok := grpcPortAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`grpc_port expected to be ovhtypes.TfInt64Value, was: %T`, grpcPortAttribute))
	}

	imageAttribute, ok := attributes["image"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`image is missing from object`)

		return nil, diags
	}

	imageVal, ok := imageAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`image expected to be ovhtypes.TfStringValue, was: %T`, imageAttribute))
	}

	labelsAttribute, ok := attributes["labels"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`labels is missing from object`)

		return nil, diags
	}

	labelsVal, ok := labelsAttribute.(ovhtypes.TfMapNestedValue[ovhtypes.TfStringValue])

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`labels expected to be ovhtypes.TfMapNestedValue[ovhtypes.TfStringValue], was: %T`, labelsAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be ovhtypes.TfStringValue, was: %T`, nameAttribute))
	}

	partnerIdAttribute, ok := attributes["partner_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`partner_id is missing from object`)

		return nil, diags
	}

	partnerIdVal, ok := partnerIdAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`partner_id expected to be ovhtypes.TfStringValue, was: %T`, partnerIdAttribute))
	}

	probeAttribute, ok := attributes["probe"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`probe is missing from object`)

		return nil, diags
	}

	probeVal, ok := probeAttribute.(SpecProbeValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`probe expected to be SpecProbeValue, was: %T`, probeAttribute))
	}

	regionAttribute, ok := attributes["region"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`region is missing from object`)

		return nil, diags
	}

	regionVal, ok := regionAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`region expected to be ovhtypes.TfStringValue, was: %T`, regionAttribute))
	}

	resourcesAttribute, ok := attributes["resources"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`resources is missing from object`)

		return nil, diags
	}

	resourcesVal, ok := resourcesAttribute.(SpecResourcesValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`resources expected to be SpecResourcesValue, was: %T`, resourcesAttribute))
	}

	scalingStrategyAttribute, ok := attributes["scaling_strategy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`scaling_strategy is missing from object`)

		return nil, diags
	}

	scalingStrategyVal, ok := scalingStrategyAttribute.(SpecScalingStrategyValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`scaling_strategy expected to be SpecScalingStrategyValue, was: %T`, scalingStrategyAttribute))
	}

	unsecureHttpAttribute, ok := attributes["unsecure_http"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`unsecure_http is missing from object`)

		return nil, diags
	}

	unsecureHttpVal, ok := unsecureHttpAttribute.(ovhtypes.TfBoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`unsecure_http expected to be ovhtypes.TfBoolValue, was: %T`, unsecureHttpAttribute))
	}

	volumesAttribute, ok := attributes["volumes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volumes is missing from object`)

		return nil, diags
	}

	volumesVal, ok := volumesAttribute.(ovhtypes.TfListNestedValue[SpecVolumesValue])

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volumes expected to be ovhtypes.TfListNestedValue[SpecVolumesValue], was: %T`, volumesAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SpecValue{
		Command:            commandVal,
		DefaultHttpPort:    defaultHttpPortVal,
		DeploymentStrategy: deploymentStrategyVal,
		EnvVars:            envVarsVal,
		GrpcPort:           grpcPortVal,
		Image:              imageVal,
		Labels:             labelsVal,
		Name:               nameVal,
		PartnerId:          partnerIdVal,
		Probe:              probeVal,
		Region:             regionVal,
		Resources:          resourcesVal,
		ScalingStrategy:    scalingStrategyVal,
		UnsecureHttp:       unsecureHttpVal,
		Volumes:            volumesVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewSpecValueNull() SpecValue {
	return SpecValue{
		state: attr.ValueStateNull,
	}
}

func NewSpecValueUnknown() SpecValue {
	return SpecValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSpecValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SpecValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SpecValue Attribute Value",
				"While creating a SpecValue value, a missing attribute value was detected. "+
					"A SpecValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpecValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SpecValue Attribute Type",
				"While creating a SpecValue value, an invalid attribute value was detected. "+
					"A SpecValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpecValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SpecValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SpecValue Attribute Value",
				"While creating a SpecValue value, an extra attribute value was detected. "+
					"A SpecValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SpecValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSpecValueUnknown(), diags
	}

	commandAttribute, ok := attributes["command"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`command is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	commandVal, ok := commandAttribute.(ovhtypes.TfListNestedValue[ovhtypes.TfStringValue])

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`command expected to be ovhtypes.TfListNestedValue[ovhtypes.TfStringValue], was: %T`, commandAttribute))
	}

	defaultHttpPortAttribute, ok := attributes["default_http_port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`default_http_port is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	defaultHttpPortVal, ok := defaultHttpPortAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`default_http_port expected to be ovhtypes.TfInt64Value, was: %T`, defaultHttpPortAttribute))
	}

	deploymentStrategyAttribute, ok := attributes["deployment_strategy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`deployment_strategy is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	deploymentStrategyVal, ok := deploymentStrategyAttribute.(SpecDeploymentStrategyValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`deployment_strategy expected to be SpecDeploymentStrategyValue, was: %T`, deploymentStrategyAttribute))
	}

	envVarsAttribute, ok := attributes["env_vars"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`env_vars is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	envVarsVal, ok := envVarsAttribute.(ovhtypes.TfListNestedValue[SpecEnvVarsValue])

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`env_vars expected to be ovhtypes.TfListNestedValue[SpecEnvVarsValue], was: %T`, envVarsAttribute))
	}

	grpcPortAttribute, ok := attributes["grpc_port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`grpc_port is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	grpcPortVal, ok := grpcPortAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`grpc_port expected to be ovhtypes.TfInt64Value, was: %T`, grpcPortAttribute))
	}

	imageAttribute, ok := attributes["image"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`image is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	imageVal, ok := imageAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`image expected to be ovhtypes.TfStringValue, was: %T`, imageAttribute))
	}

	labelsAttribute, ok := attributes["labels"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`labels is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	labelsVal, ok := labelsAttribute.(ovhtypes.TfMapNestedValue[ovhtypes.TfStringValue])

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`labels expected to be ovhtypes.TfMapNestedValue[ovhtypes.TfStringValue], was: %T`, labelsAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be ovhtypes.TfStringValue, was: %T`, nameAttribute))
	}

	partnerIdAttribute, ok := attributes["partner_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`partner_id is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	partnerIdVal, ok := partnerIdAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`partner_id expected to be ovhtypes.TfStringValue, was: %T`, partnerIdAttribute))
	}

	probeAttribute, ok := attributes["probe"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`probe is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	probeVal, ok := probeAttribute.(SpecProbeValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`probe expected to be SpecProbeValue, was: %T`, probeAttribute))
	}

	regionAttribute, ok := attributes["region"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`region is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	regionVal, ok := regionAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`region expected to be ovhtypes.TfStringValue, was: %T`, regionAttribute))
	}

	resourcesAttribute, ok := attributes["resources"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`resources is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	resourcesVal, ok := resourcesAttribute.(SpecResourcesValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`resources expected to be SpecResourcesValue, was: %T`, resourcesAttribute))
	}

	scalingStrategyAttribute, ok := attributes["scaling_strategy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`scaling_strategy is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	scalingStrategyVal, ok := scalingStrategyAttribute.(SpecScalingStrategyValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`scaling_strategy expected to be SpecScalingStrategyValue, was: %T`, scalingStrategyAttribute))
	}

	unsecureHttpAttribute, ok := attributes["unsecure_http"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`unsecure_http is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	unsecureHttpVal, ok := unsecureHttpAttribute.(ovhtypes.TfBoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`unsecure_http expected to be ovhtypes.TfBoolValue, was: %T`, unsecureHttpAttribute))
	}

	volumesAttribute, ok := attributes["volumes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volumes is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	volumesVal, ok := volumesAttribute.(ovhtypes.TfListNestedValue[SpecVolumesValue])

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volumes expected to be ovhtypes.TfListNestedValue[SpecVolumesValue], was: %T`, volumesAttribute))
	}

	if diags.HasError() {
		return NewSpecValueUnknown(), diags
	}

	return SpecValue{
		Command:            commandVal,
		DefaultHttpPort:    defaultHttpPortVal,
		DeploymentStrategy: deploymentStrategyVal,
		EnvVars:            envVarsVal,
		GrpcPort:           grpcPortVal,
		Image:              imageVal,
		Labels:             labelsVal,
		Name:               nameVal,
		PartnerId:          partnerIdVal,
		Probe:              probeVal,
		Region:             regionVal,
		Resources:          resourcesVal,
		ScalingStrategy:    scalingStrategyVal,
		UnsecureHttp:       unsecureHttpVal,
		Volumes:            volumesVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewSpecValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SpecValue {
	object, diags := NewSpecValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSpecValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SpecType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSpecValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSpecValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSpecValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSpecValueMust(SpecValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SpecType) ValueType(ctx context.Context) attr.Value {
	return SpecValue{}
}

var _ basetypes.ObjectValuable = SpecValue{}

type SpecValue struct {
	Command            ovhtypes.TfListNestedValue[ovhtypes.TfStringValue] `tfsdk:"command" json:"command"`
	DefaultHttpPort    ovhtypes.TfInt64Value                              `tfsdk:"default_http_port" json:"defaultHttpPort"`
	DeploymentStrategy SpecDeploymentStrategyValue                        `tfsdk:"deployment_strategy" json:"deploymentStrategy"`
	EnvVars            ovhtypes.TfListNestedValue[SpecEnvVarsValue]       `tfsdk:"env_vars" json:"envVars"`
	GrpcPort           ovhtypes.TfInt64Value                              `tfsdk:"grpc_port" json:"grpcPort"`
	Image              ovhtypes.TfStringValue                             `tfsdk:"image" json:"image"`
	Labels             ovhtypes.TfMapNestedValue[ovhtypes.TfStringValue]  `tfsdk:"labels" json:"labels"`
	Name               ovhtypes.TfStringValue                             `tfsdk:"name" json:"name"`
	PartnerId          ovhtypes.TfStringValue                             `tfsdk:"partner_id" json:"partnerId"`
	Probe              SpecProbeValue                                     `tfsdk:"probe" json:"probe"`
	Region             ovhtypes.TfStringValue                             `tfsdk:"region" json:"region"`
	Resources          SpecResourcesValue                                 `tfsdk:"resources" json:"resources"`
	ScalingStrategy    SpecScalingStrategyValue                           `tfsdk:"scaling_strategy" json:"scalingStrategy"`
	UnsecureHttp       ovhtypes.TfBoolValue                               `tfsdk:"unsecure_http" json:"unsecureHttp"`
	Volumes            ovhtypes.TfListNestedValue[SpecVolumesValue]       `tfsdk:"volumes" json:"volumes"`
	state              attr.ValueState
}

func (v SpecValue) ToCreate() *SpecValue {
	res := &SpecValue{}

	if !v.UnsecureHttp.IsNull() {
		res.UnsecureHttp = v.UnsecureHttp
	}

	res.state = attr.ValueStateKnown

	return res
}

func (v SpecValue) MarshalJSON() ([]byte, error) {
	toMarshal := map[string]any{}
	if !v.UnsecureHttp.IsNull() && !v.UnsecureHttp.IsUnknown() {
		toMarshal["unsecureHttp"] = v.UnsecureHttp
	}

	return json.Marshal(toMarshal)
}

func (v *SpecValue) UnmarshalJSON(data []byte) error {
	type JsonSpecValue SpecValue

	var tmp JsonSpecValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.Command = tmp.Command
	v.DefaultHttpPort = tmp.DefaultHttpPort
	v.DeploymentStrategy = tmp.DeploymentStrategy
	v.EnvVars = tmp.EnvVars
	v.GrpcPort = tmp.GrpcPort
	v.Image = tmp.Image
	v.Labels = tmp.Labels
	v.Name = tmp.Name
	v.PartnerId = tmp.PartnerId
	v.Probe = tmp.Probe
	v.Region = tmp.Region
	v.Resources = tmp.Resources
	v.ScalingStrategy = tmp.ScalingStrategy
	v.UnsecureHttp = tmp.UnsecureHttp
	v.Volumes = tmp.Volumes

	v.state = attr.ValueStateKnown

	return nil
}

func (v *SpecValue) MergeWith(other *SpecValue) {

	if (v.Command.IsUnknown() || v.Command.IsNull()) && !other.Command.IsUnknown() {
		v.Command = other.Command
	}

	if (v.DefaultHttpPort.IsUnknown() || v.DefaultHttpPort.IsNull()) && !other.DefaultHttpPort.IsUnknown() {
		v.DefaultHttpPort = other.DefaultHttpPort
	}

	if v.DeploymentStrategy.IsUnknown() && !other.DeploymentStrategy.IsUnknown() {
		v.DeploymentStrategy = other.DeploymentStrategy
	} else if !other.DeploymentStrategy.IsUnknown() {
		v.DeploymentStrategy.MergeWith(&other.DeploymentStrategy)
	}

	if (v.EnvVars.IsUnknown() || v.EnvVars.IsNull()) && !other.EnvVars.IsUnknown() {
		v.EnvVars = other.EnvVars
	} else if !other.EnvVars.IsUnknown() {
		newSlice := make([]attr.Value, 0)
		elems := v.EnvVars.Elements()
		newElems := other.EnvVars.Elements()

		if len(elems) != len(newElems) {
			v.EnvVars = other.EnvVars
		} else {
			for idx, e := range elems {
				tmp := e.(SpecEnvVarsValue)
				tmp2 := newElems[idx].(SpecEnvVarsValue)
				tmp.MergeWith(&tmp2)
				newSlice = append(newSlice, tmp)
			}

			v.EnvVars = ovhtypes.TfListNestedValue[SpecEnvVarsValue]{
				ListValue: basetypes.NewListValueMust(SpecEnvVarsValue{}.Type(context.Background()), newSlice),
			}
		}
	}

	if (v.GrpcPort.IsUnknown() || v.GrpcPort.IsNull()) && !other.GrpcPort.IsUnknown() {
		v.GrpcPort = other.GrpcPort
	}

	if (v.Image.IsUnknown() || v.Image.IsNull()) && !other.Image.IsUnknown() {
		v.Image = other.Image
	}

	if (v.Labels.IsUnknown() || v.Labels.IsNull()) && !other.Labels.IsUnknown() {
		v.Labels = other.Labels
	}

	if (v.Name.IsUnknown() || v.Name.IsNull()) && !other.Name.IsUnknown() {
		v.Name = other.Name
	}

	if (v.PartnerId.IsUnknown() || v.PartnerId.IsNull()) && !other.PartnerId.IsUnknown() {
		v.PartnerId = other.PartnerId
	}

	if v.Probe.IsUnknown() && !other.Probe.IsUnknown() {
		v.Probe = other.Probe
	} else if !other.Probe.IsUnknown() {
		v.Probe.MergeWith(&other.Probe)
	}

	if (v.Region.IsUnknown() || v.Region.IsNull()) && !other.Region.IsUnknown() {
		v.Region = other.Region
	}

	if v.Resources.IsUnknown() && !other.Resources.IsUnknown() {
		v.Resources = other.Resources
	} else if !other.Resources.IsUnknown() {
		v.Resources.MergeWith(&other.Resources)
	}

	if v.ScalingStrategy.IsUnknown() && !other.ScalingStrategy.IsUnknown() {
		v.ScalingStrategy = other.ScalingStrategy
	} else if !other.ScalingStrategy.IsUnknown() {
		v.ScalingStrategy.MergeWith(&other.ScalingStrategy)
	}

	if (v.UnsecureHttp.IsUnknown() || v.UnsecureHttp.IsNull()) && !other.UnsecureHttp.IsUnknown() {
		v.UnsecureHttp = other.UnsecureHttp
	}

	if (v.Volumes.IsUnknown() || v.Volumes.IsNull()) && !other.Volumes.IsUnknown() {
		v.Volumes = other.Volumes
	} else if !other.Volumes.IsUnknown() {
		newSlice := make([]attr.Value, 0)
		elems := v.Volumes.Elements()
		newElems := other.Volumes.Elements()

		if len(elems) != len(newElems) {
			v.Volumes = other.Volumes
		} else {
			for idx, e := range elems {
				tmp := e.(SpecVolumesValue)
				tmp2 := newElems[idx].(SpecVolumesValue)
				tmp.MergeWith(&tmp2)
				newSlice = append(newSlice, tmp)
			}

			v.Volumes = ovhtypes.TfListNestedValue[SpecVolumesValue]{
				ListValue: basetypes.NewListValueMust(SpecVolumesValue{}.Type(context.Background()), newSlice),
			}
		}
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v SpecValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"command":            v.Command,
		"defaultHttpPort":    v.DefaultHttpPort,
		"deploymentStrategy": v.DeploymentStrategy,
		"envVars":            v.EnvVars,
		"grpcPort":           v.GrpcPort,
		"image":              v.Image,
		"labels":             v.Labels,
		"name":               v.Name,
		"partnerId":          v.PartnerId,
		"probe":              v.Probe,
		"region":             v.Region,
		"resources":          v.Resources,
		"scalingStrategy":    v.ScalingStrategy,
		"unsecureHttp":       v.UnsecureHttp,
		"volumes":            v.Volumes,
	}
}
func (v SpecValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 15)

	var val tftypes.Value
	var err error

	attrTypes["command"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["default_http_port"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["deployment_strategy"] = basetypes.ObjectType{
		AttrTypes: SpecDeploymentStrategyValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["env_vars"] = basetypes.ListType{
		ElemType: SpecEnvVarsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["grpc_port"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["image"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["labels"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["partner_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["probe"] = basetypes.ObjectType{
		AttrTypes: SpecProbeValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["region"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["resources"] = basetypes.ObjectType{
		AttrTypes: SpecResourcesValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["scaling_strategy"] = basetypes.ObjectType{
		AttrTypes: SpecScalingStrategyValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["unsecure_http"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["volumes"] = basetypes.ListType{
		ElemType: SpecVolumesValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 15)

		val, err = v.Command.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["command"] = val

		val, err = v.DefaultHttpPort.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["default_http_port"] = val

		val, err = v.DeploymentStrategy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["deployment_strategy"] = val

		val, err = v.EnvVars.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["env_vars"] = val

		val, err = v.GrpcPort.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["grpc_port"] = val

		val, err = v.Image.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["image"] = val

		val, err = v.Labels.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["labels"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.PartnerId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["partner_id"] = val

		val, err = v.Probe.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["probe"] = val

		val, err = v.Region.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["region"] = val

		val, err = v.Resources.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["resources"] = val

		val, err = v.ScalingStrategy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["scaling_strategy"] = val

		val, err = v.UnsecureHttp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["unsecure_http"] = val

		val, err = v.Volumes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["volumes"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SpecValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SpecValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SpecValue) String() string {
	return "SpecValue"
}

func (v SpecValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"command":           ovhtypes.NewTfListNestedType[ovhtypes.TfStringValue](ctx),
			"default_http_port": ovhtypes.TfInt64Type{},
			"deployment_strategy": SpecDeploymentStrategyType{
				basetypes.ObjectType{
					AttrTypes: SpecDeploymentStrategyValue{}.AttributeTypes(ctx),
				},
			},
			"env_vars":   ovhtypes.NewTfListNestedType[SpecEnvVarsValue](ctx),
			"grpc_port":  ovhtypes.TfInt64Type{},
			"image":      ovhtypes.TfStringType{},
			"labels":     ovhtypes.NewTfMapNestedType[ovhtypes.TfStringValue](ctx),
			"name":       ovhtypes.TfStringType{},
			"partner_id": ovhtypes.TfStringType{},
			"probe": SpecProbeType{
				basetypes.ObjectType{
					AttrTypes: SpecProbeValue{}.AttributeTypes(ctx),
				},
			},
			"region": ovhtypes.TfStringType{},
			"resources": SpecResourcesType{
				basetypes.ObjectType{
					AttrTypes: SpecResourcesValue{}.AttributeTypes(ctx),
				},
			},
			"scaling_strategy": SpecScalingStrategyType{
				basetypes.ObjectType{
					AttrTypes: SpecScalingStrategyValue{}.AttributeTypes(ctx),
				},
			},
			"unsecure_http": ovhtypes.TfBoolType{},
			"volumes":       ovhtypes.NewTfListNestedType[SpecVolumesValue](ctx),
		},
		map[string]attr.Value{
			"command":             v.Command,
			"default_http_port":   v.DefaultHttpPort,
			"deployment_strategy": v.DeploymentStrategy,
			"env_vars":            v.EnvVars,
			"grpc_port":           v.GrpcPort,
			"image":               v.Image,
			"labels":              v.Labels,
			"name":                v.Name,
			"partner_id":          v.PartnerId,
			"probe":               v.Probe,
			"region":              v.Region,
			"resources":           v.Resources,
			"scaling_strategy":    v.ScalingStrategy,
			"unsecure_http":       v.UnsecureHttp,
			"volumes":             v.Volumes,
		})

	return objVal, diags
}

func (v SpecValue) Equal(o attr.Value) bool {
	other, ok := o.(SpecValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Command.Equal(other.Command) {
		return false
	}

	if !v.DefaultHttpPort.Equal(other.DefaultHttpPort) {
		return false
	}

	if !v.DeploymentStrategy.Equal(other.DeploymentStrategy) {
		return false
	}

	if !v.EnvVars.Equal(other.EnvVars) {
		return false
	}

	if !v.GrpcPort.Equal(other.GrpcPort) {
		return false
	}

	if !v.Image.Equal(other.Image) {
		return false
	}

	if !v.Labels.Equal(other.Labels) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.PartnerId.Equal(other.PartnerId) {
		return false
	}

	if !v.Probe.Equal(other.Probe) {
		return false
	}

	if !v.Region.Equal(other.Region) {
		return false
	}

	if !v.Resources.Equal(other.Resources) {
		return false
	}

	if !v.ScalingStrategy.Equal(other.ScalingStrategy) {
		return false
	}

	if !v.UnsecureHttp.Equal(other.UnsecureHttp) {
		return false
	}

	if !v.Volumes.Equal(other.Volumes) {
		return false
	}

	return true
}

func (v SpecValue) Type(ctx context.Context) attr.Type {
	return SpecType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SpecValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"command":             ovhtypes.NewTfListNestedType[ovhtypes.TfStringValue](ctx),
		"default_http_port":   ovhtypes.TfInt64Type{},
		"deployment_strategy": SpecDeploymentStrategyValue{}.Type(ctx),
		"env_vars":            ovhtypes.NewTfListNestedType[SpecEnvVarsValue](ctx),
		"grpc_port":           ovhtypes.TfInt64Type{},
		"image":               ovhtypes.TfStringType{},
		"labels":              ovhtypes.NewTfMapNestedType[ovhtypes.TfStringValue](ctx),
		"name":                ovhtypes.TfStringType{},
		"partner_id":          ovhtypes.TfStringType{},
		"probe":               SpecProbeValue{}.Type(ctx),
		"region":              ovhtypes.TfStringType{},
		"resources":           SpecResourcesValue{}.Type(ctx),
		"scaling_strategy":    SpecScalingStrategyValue{}.Type(ctx),
		"unsecure_http":       ovhtypes.TfBoolType{},
		"volumes":             ovhtypes.NewTfListNestedType[SpecVolumesValue](ctx),
	}
}

var _ basetypes.ObjectTypable = SpecDeploymentStrategyType{}

type SpecDeploymentStrategyType struct {
	basetypes.ObjectType
}

func (t SpecDeploymentStrategyType) Equal(o attr.Type) bool {
	other, ok := o.(SpecDeploymentStrategyType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SpecDeploymentStrategyType) String() string {
	return "SpecDeploymentStrategyType"
}

func (t SpecDeploymentStrategyType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	maxSurgeAttribute, ok := attributes["max_surge"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_surge is missing from object`)

		return nil, diags
	}

	maxSurgeVal, ok := maxSurgeAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_surge expected to be ovhtypes.TfStringValue, was: %T`, maxSurgeAttribute))
	}

	maxUnavailableAttribute, ok := attributes["max_unavailable"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_unavailable is missing from object`)

		return nil, diags
	}

	maxUnavailableVal, ok := maxUnavailableAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_unavailable expected to be ovhtypes.TfStringValue, was: %T`, maxUnavailableAttribute))
	}

	progressDeadlineSecondsAttribute, ok := attributes["progress_deadline_seconds"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`progress_deadline_seconds is missing from object`)

		return nil, diags
	}

	progressDeadlineSecondsVal, ok := progressDeadlineSecondsAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`progress_deadline_seconds expected to be ovhtypes.TfInt64Value, was: %T`, progressDeadlineSecondsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SpecDeploymentStrategyValue{
		MaxSurge:                maxSurgeVal,
		MaxUnavailable:          maxUnavailableVal,
		ProgressDeadlineSeconds: progressDeadlineSecondsVal,
		state:                   attr.ValueStateKnown,
	}, diags
}

func NewSpecDeploymentStrategyValueNull() SpecDeploymentStrategyValue {
	return SpecDeploymentStrategyValue{
		state: attr.ValueStateNull,
	}
}

func NewSpecDeploymentStrategyValueUnknown() SpecDeploymentStrategyValue {
	return SpecDeploymentStrategyValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSpecDeploymentStrategyValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SpecDeploymentStrategyValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SpecDeploymentStrategyValue Attribute Value",
				"While creating a SpecDeploymentStrategyValue value, a missing attribute value was detected. "+
					"A SpecDeploymentStrategyValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpecDeploymentStrategyValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SpecDeploymentStrategyValue Attribute Type",
				"While creating a SpecDeploymentStrategyValue value, an invalid attribute value was detected. "+
					"A SpecDeploymentStrategyValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpecDeploymentStrategyValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SpecDeploymentStrategyValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SpecDeploymentStrategyValue Attribute Value",
				"While creating a SpecDeploymentStrategyValue value, an extra attribute value was detected. "+
					"A SpecDeploymentStrategyValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SpecDeploymentStrategyValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSpecDeploymentStrategyValueUnknown(), diags
	}

	maxSurgeAttribute, ok := attributes["max_surge"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_surge is missing from object`)

		return NewSpecDeploymentStrategyValueUnknown(), diags
	}

	maxSurgeVal, ok := maxSurgeAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_surge expected to be ovhtypes.TfStringValue, was: %T`, maxSurgeAttribute))
	}

	maxUnavailableAttribute, ok := attributes["max_unavailable"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_unavailable is missing from object`)

		return NewSpecDeploymentStrategyValueUnknown(), diags
	}

	maxUnavailableVal, ok := maxUnavailableAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_unavailable expected to be ovhtypes.TfStringValue, was: %T`, maxUnavailableAttribute))
	}

	progressDeadlineSecondsAttribute, ok := attributes["progress_deadline_seconds"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`progress_deadline_seconds is missing from object`)

		return NewSpecDeploymentStrategyValueUnknown(), diags
	}

	progressDeadlineSecondsVal, ok := progressDeadlineSecondsAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`progress_deadline_seconds expected to be ovhtypes.TfInt64Value, was: %T`, progressDeadlineSecondsAttribute))
	}

	if diags.HasError() {
		return NewSpecDeploymentStrategyValueUnknown(), diags
	}

	return SpecDeploymentStrategyValue{
		MaxSurge:                maxSurgeVal,
		MaxUnavailable:          maxUnavailableVal,
		ProgressDeadlineSeconds: progressDeadlineSecondsVal,
		state:                   attr.ValueStateKnown,
	}, diags
}

func NewSpecDeploymentStrategyValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SpecDeploymentStrategyValue {
	object, diags := NewSpecDeploymentStrategyValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSpecDeploymentStrategyValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SpecDeploymentStrategyType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSpecDeploymentStrategyValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSpecDeploymentStrategyValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSpecDeploymentStrategyValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSpecDeploymentStrategyValueMust(SpecDeploymentStrategyValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SpecDeploymentStrategyType) ValueType(ctx context.Context) attr.Value {
	return SpecDeploymentStrategyValue{}
}

var _ basetypes.ObjectValuable = SpecDeploymentStrategyValue{}

type SpecDeploymentStrategyValue struct {
	MaxSurge                ovhtypes.TfStringValue `tfsdk:"max_surge" json:"maxSurge"`
	MaxUnavailable          ovhtypes.TfStringValue `tfsdk:"max_unavailable" json:"maxUnavailable"`
	ProgressDeadlineSeconds ovhtypes.TfInt64Value  `tfsdk:"progress_deadline_seconds" json:"progressDeadlineSeconds"`
	state                   attr.ValueState
}

func (v *SpecDeploymentStrategyValue) UnmarshalJSON(data []byte) error {
	type JsonSpecDeploymentStrategyValue SpecDeploymentStrategyValue

	var tmp JsonSpecDeploymentStrategyValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.MaxSurge = tmp.MaxSurge
	v.MaxUnavailable = tmp.MaxUnavailable
	v.ProgressDeadlineSeconds = tmp.ProgressDeadlineSeconds

	v.state = attr.ValueStateKnown

	return nil
}

func (v *SpecDeploymentStrategyValue) MergeWith(other *SpecDeploymentStrategyValue) {

	if (v.MaxSurge.IsUnknown() || v.MaxSurge.IsNull()) && !other.MaxSurge.IsUnknown() {
		v.MaxSurge = other.MaxSurge
	}

	if (v.MaxUnavailable.IsUnknown() || v.MaxUnavailable.IsNull()) && !other.MaxUnavailable.IsUnknown() {
		v.MaxUnavailable = other.MaxUnavailable
	}

	if (v.ProgressDeadlineSeconds.IsUnknown() || v.ProgressDeadlineSeconds.IsNull()) && !other.ProgressDeadlineSeconds.IsUnknown() {
		v.ProgressDeadlineSeconds = other.ProgressDeadlineSeconds
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v SpecDeploymentStrategyValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"maxSurge":                v.MaxSurge,
		"maxUnavailable":          v.MaxUnavailable,
		"progressDeadlineSeconds": v.ProgressDeadlineSeconds,
	}
}
func (v SpecDeploymentStrategyValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["max_surge"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["max_unavailable"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["progress_deadline_seconds"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.MaxSurge.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_surge"] = val

		val, err = v.MaxUnavailable.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_unavailable"] = val

		val, err = v.ProgressDeadlineSeconds.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["progress_deadline_seconds"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SpecDeploymentStrategyValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SpecDeploymentStrategyValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SpecDeploymentStrategyValue) String() string {
	return "SpecDeploymentStrategyValue"
}

func (v SpecDeploymentStrategyValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"max_surge":                 ovhtypes.TfStringType{},
			"max_unavailable":           ovhtypes.TfStringType{},
			"progress_deadline_seconds": ovhtypes.TfInt64Type{},
		},
		map[string]attr.Value{
			"max_surge":                 v.MaxSurge,
			"max_unavailable":           v.MaxUnavailable,
			"progress_deadline_seconds": v.ProgressDeadlineSeconds,
		})

	return objVal, diags
}

func (v SpecDeploymentStrategyValue) Equal(o attr.Value) bool {
	other, ok := o.(SpecDeploymentStrategyValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.MaxSurge.Equal(other.MaxSurge) {
		return false
	}

	if !v.MaxUnavailable.Equal(other.MaxUnavailable) {
		return false
	}

	if !v.ProgressDeadlineSeconds.Equal(other.ProgressDeadlineSeconds) {
		return false
	}

	return true
}

func (v SpecDeploymentStrategyValue) Type(ctx context.Context) attr.Type {
	return SpecDeploymentStrategyType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SpecDeploymentStrategyValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"max_surge":                 ovhtypes.TfStringType{},
		"max_unavailable":           ovhtypes.TfStringType{},
		"progress_deadline_seconds": ovhtypes.TfInt64Type{},
	}
}

var _ basetypes.ObjectTypable = SpecEnvVarsType{}

type SpecEnvVarsType struct {
	basetypes.ObjectType
}

func (t SpecEnvVarsType) Equal(o attr.Type) bool {
	other, ok := o.(SpecEnvVarsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SpecEnvVarsType) String() string {
	return "SpecEnvVarsType"
}

func (t SpecEnvVarsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be ovhtypes.TfStringValue, was: %T`, nameAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return nil, diags
	}

	valueVal, ok := valueAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be ovhtypes.TfStringValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SpecEnvVarsValue{
		Name:  nameVal,
		Value: valueVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewSpecEnvVarsValueNull() SpecEnvVarsValue {
	return SpecEnvVarsValue{
		state: attr.ValueStateNull,
	}
}

func NewSpecEnvVarsValueUnknown() SpecEnvVarsValue {
	return SpecEnvVarsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSpecEnvVarsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SpecEnvVarsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SpecEnvVarsValue Attribute Value",
				"While creating a SpecEnvVarsValue value, a missing attribute value was detected. "+
					"A SpecEnvVarsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpecEnvVarsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SpecEnvVarsValue Attribute Type",
				"While creating a SpecEnvVarsValue value, an invalid attribute value was detected. "+
					"A SpecEnvVarsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpecEnvVarsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SpecEnvVarsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SpecEnvVarsValue Attribute Value",
				"While creating a SpecEnvVarsValue value, an extra attribute value was detected. "+
					"A SpecEnvVarsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SpecEnvVarsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSpecEnvVarsValueUnknown(), diags
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewSpecEnvVarsValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be ovhtypes.TfStringValue, was: %T`, nameAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return NewSpecEnvVarsValueUnknown(), diags
	}

	valueVal, ok := valueAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be ovhtypes.TfStringValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return NewSpecEnvVarsValueUnknown(), diags
	}

	return SpecEnvVarsValue{
		Name:  nameVal,
		Value: valueVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewSpecEnvVarsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SpecEnvVarsValue {
	object, diags := NewSpecEnvVarsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSpecEnvVarsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SpecEnvVarsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSpecEnvVarsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSpecEnvVarsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSpecEnvVarsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSpecEnvVarsValueMust(SpecEnvVarsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SpecEnvVarsType) ValueType(ctx context.Context) attr.Value {
	return SpecEnvVarsValue{}
}

var _ basetypes.ObjectValuable = SpecEnvVarsValue{}

type SpecEnvVarsValue struct {
	Name  ovhtypes.TfStringValue `tfsdk:"name" json:"name"`
	Value ovhtypes.TfStringValue `tfsdk:"value" json:"value"`
	state attr.ValueState
}

func (v *SpecEnvVarsValue) UnmarshalJSON(data []byte) error {
	type JsonSpecEnvVarsValue SpecEnvVarsValue

	var tmp JsonSpecEnvVarsValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.Name = tmp.Name
	v.Value = tmp.Value

	v.state = attr.ValueStateKnown

	return nil
}

func (v *SpecEnvVarsValue) MergeWith(other *SpecEnvVarsValue) {

	if (v.Name.IsUnknown() || v.Name.IsNull()) && !other.Name.IsUnknown() {
		v.Name = other.Name
	}

	if (v.Value.IsUnknown() || v.Value.IsNull()) && !other.Value.IsUnknown() {
		v.Value = other.Value
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v SpecEnvVarsValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"name":  v.Name,
		"value": v.Value,
	}
}
func (v SpecEnvVarsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["value"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Value.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["value"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SpecEnvVarsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SpecEnvVarsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SpecEnvVarsValue) String() string {
	return "SpecEnvVarsValue"
}

func (v SpecEnvVarsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"name":  ovhtypes.TfStringType{},
			"value": ovhtypes.TfStringType{},
		},
		map[string]attr.Value{
			"name":  v.Name,
			"value": v.Value,
		})

	return objVal, diags
}

func (v SpecEnvVarsValue) Equal(o attr.Value) bool {
	other, ok := o.(SpecEnvVarsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Value.Equal(other.Value) {
		return false
	}

	return true
}

func (v SpecEnvVarsValue) Type(ctx context.Context) attr.Type {
	return SpecEnvVarsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SpecEnvVarsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"name":  ovhtypes.TfStringType{},
		"value": ovhtypes.TfStringType{},
	}
}

var _ basetypes.ObjectTypable = SpecProbeType{}

type SpecProbeType struct {
	basetypes.ObjectType
}

func (t SpecProbeType) Equal(o attr.Type) bool {
	other, ok := o.(SpecProbeType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SpecProbeType) String() string {
	return "SpecProbeType"
}

func (t SpecProbeType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	pathAttribute, ok := attributes["path"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`path is missing from object`)

		return nil, diags
	}

	pathVal, ok := pathAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`path expected to be ovhtypes.TfStringValue, was: %T`, pathAttribute))
	}

	portAttribute, ok := attributes["port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port is missing from object`)

		return nil, diags
	}

	portVal, ok := portAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port expected to be ovhtypes.TfInt64Value, was: %T`, portAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SpecProbeValue{
		Path:  pathVal,
		Port:  portVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewSpecProbeValueNull() SpecProbeValue {
	return SpecProbeValue{
		state: attr.ValueStateNull,
	}
}

func NewSpecProbeValueUnknown() SpecProbeValue {
	return SpecProbeValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSpecProbeValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SpecProbeValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SpecProbeValue Attribute Value",
				"While creating a SpecProbeValue value, a missing attribute value was detected. "+
					"A SpecProbeValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpecProbeValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SpecProbeValue Attribute Type",
				"While creating a SpecProbeValue value, an invalid attribute value was detected. "+
					"A SpecProbeValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpecProbeValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SpecProbeValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SpecProbeValue Attribute Value",
				"While creating a SpecProbeValue value, an extra attribute value was detected. "+
					"A SpecProbeValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SpecProbeValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSpecProbeValueUnknown(), diags
	}

	pathAttribute, ok := attributes["path"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`path is missing from object`)

		return NewSpecProbeValueUnknown(), diags
	}

	pathVal, ok := pathAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`path expected to be ovhtypes.TfStringValue, was: %T`, pathAttribute))
	}

	portAttribute, ok := attributes["port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port is missing from object`)

		return NewSpecProbeValueUnknown(), diags
	}

	portVal, ok := portAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port expected to be ovhtypes.TfInt64Value, was: %T`, portAttribute))
	}

	if diags.HasError() {
		return NewSpecProbeValueUnknown(), diags
	}

	return SpecProbeValue{
		Path:  pathVal,
		Port:  portVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewSpecProbeValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SpecProbeValue {
	object, diags := NewSpecProbeValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSpecProbeValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SpecProbeType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSpecProbeValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSpecProbeValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSpecProbeValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSpecProbeValueMust(SpecProbeValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SpecProbeType) ValueType(ctx context.Context) attr.Value {
	return SpecProbeValue{}
}

var _ basetypes.ObjectValuable = SpecProbeValue{}

type SpecProbeValue struct {
	Path  ovhtypes.TfStringValue `tfsdk:"path" json:"path"`
	Port  ovhtypes.TfInt64Value  `tfsdk:"port" json:"port"`
	state attr.ValueState
}

func (v *SpecProbeValue) UnmarshalJSON(data []byte) error {
	type JsonSpecProbeValue SpecProbeValue

	var tmp JsonSpecProbeValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.Path = tmp.Path
	v.Port = tmp.Port

	v.state = attr.ValueStateKnown

	return nil
}

func (v *SpecProbeValue) MergeWith(other *SpecProbeValue) {

	if (v.Path.IsUnknown() || v.Path.IsNull()) && !other.Path.IsUnknown() {
		v.Path = other.Path
	}

	if (v.Port.IsUnknown() || v.Port.IsNull()) && !other.Port.IsUnknown() {
		v.Port = other.Port
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v SpecProbeValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"path": v.Path,
		"port": v.Port,
	}
}
func (v SpecProbeValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["path"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["port"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Path.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["path"] = val

		val, err = v.Port.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SpecProbeValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SpecProbeValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SpecProbeValue) String() string {
	return "SpecProbeValue"
}

func (v SpecProbeValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"path": ovhtypes.TfStringType{},
			"port": ovhtypes.TfInt64Type{},
		},
		map[string]attr.Value{
			"path": v.Path,
			"port": v.Port,
		})

	return objVal, diags
}

func (v SpecProbeValue) Equal(o attr.Value) bool {
	other, ok := o.(SpecProbeValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Path.Equal(other.Path) {
		return false
	}

	if !v.Port.Equal(other.Port) {
		return false
	}

	return true
}

func (v SpecProbeValue) Type(ctx context.Context) attr.Type {
	return SpecProbeType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SpecProbeValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"path": ovhtypes.TfStringType{},
		"port": ovhtypes.TfInt64Type{},
	}
}

var _ basetypes.ObjectTypable = SpecResourcesType{}

type SpecResourcesType struct {
	basetypes.ObjectType
}

func (t SpecResourcesType) Equal(o attr.Type) bool {
	other, ok := o.(SpecResourcesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SpecResourcesType) String() string {
	return "SpecResourcesType"
}

func (t SpecResourcesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	cpuAttribute, ok := attributes["cpu"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cpu is missing from object`)

		return nil, diags
	}

	cpuVal, ok := cpuAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cpu expected to be ovhtypes.TfInt64Value, was: %T`, cpuAttribute))
	}

	ephemeralStorageAttribute, ok := attributes["ephemeral_storage"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ephemeral_storage is missing from object`)

		return nil, diags
	}

	ephemeralStorageVal, ok := ephemeralStorageAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ephemeral_storage expected to be ovhtypes.TfInt64Value, was: %T`, ephemeralStorageAttribute))
	}

	flavorAttribute, ok := attributes["flavor"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`flavor is missing from object`)

		return nil, diags
	}

	flavorVal, ok := flavorAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`flavor expected to be ovhtypes.TfStringValue, was: %T`, flavorAttribute))
	}

	gpuAttribute, ok := attributes["gpu"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gpu is missing from object`)

		return nil, diags
	}

	gpuVal, ok := gpuAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gpu expected to be ovhtypes.TfInt64Value, was: %T`, gpuAttribute))
	}

	gpuBrandAttribute, ok := attributes["gpu_brand"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gpu_brand is missing from object`)

		return nil, diags
	}

	gpuBrandVal, ok := gpuBrandAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gpu_brand expected to be ovhtypes.TfStringValue, was: %T`, gpuBrandAttribute))
	}

	gpuMemoryAttribute, ok := attributes["gpu_memory"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gpu_memory is missing from object`)

		return nil, diags
	}

	gpuMemoryVal, ok := gpuMemoryAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gpu_memory expected to be ovhtypes.TfInt64Value, was: %T`, gpuMemoryAttribute))
	}

	gpuModelAttribute, ok := attributes["gpu_model"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gpu_model is missing from object`)

		return nil, diags
	}

	gpuModelVal, ok := gpuModelAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gpu_model expected to be ovhtypes.TfStringValue, was: %T`, gpuModelAttribute))
	}

	memoryAttribute, ok := attributes["memory"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`memory is missing from object`)

		return nil, diags
	}

	memoryVal, ok := memoryAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`memory expected to be ovhtypes.TfInt64Value, was: %T`, memoryAttribute))
	}

	privateNetworkAttribute, ok := attributes["private_network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`private_network is missing from object`)

		return nil, diags
	}

	privateNetworkVal, ok := privateNetworkAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`private_network expected to be ovhtypes.TfInt64Value, was: %T`, privateNetworkAttribute))
	}

	publicNetworkAttribute, ok := attributes["public_network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`public_network is missing from object`)

		return nil, diags
	}

	publicNetworkVal, ok := publicNetworkAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`public_network expected to be ovhtypes.TfInt64Value, was: %T`, publicNetworkAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SpecResourcesValue{
		Cpu:              cpuVal,
		EphemeralStorage: ephemeralStorageVal,
		Flavor:           flavorVal,
		Gpu:              gpuVal,
		GpuBrand:         gpuBrandVal,
		GpuMemory:        gpuMemoryVal,
		GpuModel:         gpuModelVal,
		Memory:           memoryVal,
		PrivateNetwork:   privateNetworkVal,
		PublicNetwork:    publicNetworkVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewSpecResourcesValueNull() SpecResourcesValue {
	return SpecResourcesValue{
		state: attr.ValueStateNull,
	}
}

func NewSpecResourcesValueUnknown() SpecResourcesValue {
	return SpecResourcesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSpecResourcesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SpecResourcesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SpecResourcesValue Attribute Value",
				"While creating a SpecResourcesValue value, a missing attribute value was detected. "+
					"A SpecResourcesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpecResourcesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SpecResourcesValue Attribute Type",
				"While creating a SpecResourcesValue value, an invalid attribute value was detected. "+
					"A SpecResourcesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpecResourcesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SpecResourcesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SpecResourcesValue Attribute Value",
				"While creating a SpecResourcesValue value, an extra attribute value was detected. "+
					"A SpecResourcesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SpecResourcesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSpecResourcesValueUnknown(), diags
	}

	cpuAttribute, ok := attributes["cpu"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cpu is missing from object`)

		return NewSpecResourcesValueUnknown(), diags
	}

	cpuVal, ok := cpuAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cpu expected to be ovhtypes.TfInt64Value, was: %T`, cpuAttribute))
	}

	ephemeralStorageAttribute, ok := attributes["ephemeral_storage"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ephemeral_storage is missing from object`)

		return NewSpecResourcesValueUnknown(), diags
	}

	ephemeralStorageVal, ok := ephemeralStorageAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ephemeral_storage expected to be ovhtypes.TfInt64Value, was: %T`, ephemeralStorageAttribute))
	}

	flavorAttribute, ok := attributes["flavor"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`flavor is missing from object`)

		return NewSpecResourcesValueUnknown(), diags
	}

	flavorVal, ok := flavorAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`flavor expected to be ovhtypes.TfStringValue, was: %T`, flavorAttribute))
	}

	gpuAttribute, ok := attributes["gpu"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gpu is missing from object`)

		return NewSpecResourcesValueUnknown(), diags
	}

	gpuVal, ok := gpuAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gpu expected to be ovhtypes.TfInt64Value, was: %T`, gpuAttribute))
	}

	gpuBrandAttribute, ok := attributes["gpu_brand"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gpu_brand is missing from object`)

		return NewSpecResourcesValueUnknown(), diags
	}

	gpuBrandVal, ok := gpuBrandAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gpu_brand expected to be ovhtypes.TfStringValue, was: %T`, gpuBrandAttribute))
	}

	gpuMemoryAttribute, ok := attributes["gpu_memory"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gpu_memory is missing from object`)

		return NewSpecResourcesValueUnknown(), diags
	}

	gpuMemoryVal, ok := gpuMemoryAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gpu_memory expected to be ovhtypes.TfInt64Value, was: %T`, gpuMemoryAttribute))
	}

	gpuModelAttribute, ok := attributes["gpu_model"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gpu_model is missing from object`)

		return NewSpecResourcesValueUnknown(), diags
	}

	gpuModelVal, ok := gpuModelAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gpu_model expected to be ovhtypes.TfStringValue, was: %T`, gpuModelAttribute))
	}

	memoryAttribute, ok := attributes["memory"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`memory is missing from object`)

		return NewSpecResourcesValueUnknown(), diags
	}

	memoryVal, ok := memoryAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`memory expected to be ovhtypes.TfInt64Value, was: %T`, memoryAttribute))
	}

	privateNetworkAttribute, ok := attributes["private_network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`private_network is missing from object`)

		return NewSpecResourcesValueUnknown(), diags
	}

	privateNetworkVal, ok := privateNetworkAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`private_network expected to be ovhtypes.TfInt64Value, was: %T`, privateNetworkAttribute))
	}

	publicNetworkAttribute, ok := attributes["public_network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`public_network is missing from object`)

		return NewSpecResourcesValueUnknown(), diags
	}

	publicNetworkVal, ok := publicNetworkAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`public_network expected to be ovhtypes.TfInt64Value, was: %T`, publicNetworkAttribute))
	}

	if diags.HasError() {
		return NewSpecResourcesValueUnknown(), diags
	}

	return SpecResourcesValue{
		Cpu:              cpuVal,
		EphemeralStorage: ephemeralStorageVal,
		Flavor:           flavorVal,
		Gpu:              gpuVal,
		GpuBrand:         gpuBrandVal,
		GpuMemory:        gpuMemoryVal,
		GpuModel:         gpuModelVal,
		Memory:           memoryVal,
		PrivateNetwork:   privateNetworkVal,
		PublicNetwork:    publicNetworkVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewSpecResourcesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SpecResourcesValue {
	object, diags := NewSpecResourcesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSpecResourcesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SpecResourcesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSpecResourcesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSpecResourcesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSpecResourcesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSpecResourcesValueMust(SpecResourcesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SpecResourcesType) ValueType(ctx context.Context) attr.Value {
	return SpecResourcesValue{}
}

var _ basetypes.ObjectValuable = SpecResourcesValue{}

type SpecResourcesValue struct {
	Cpu              ovhtypes.TfInt64Value  `tfsdk:"cpu" json:"cpu"`
	EphemeralStorage ovhtypes.TfInt64Value  `tfsdk:"ephemeral_storage" json:"ephemeralStorage"`
	Flavor           ovhtypes.TfStringValue `tfsdk:"flavor" json:"flavor"`
	Gpu              ovhtypes.TfInt64Value  `tfsdk:"gpu" json:"gpu"`
	GpuBrand         ovhtypes.TfStringValue `tfsdk:"gpu_brand" json:"gpuBrand"`
	GpuMemory        ovhtypes.TfInt64Value  `tfsdk:"gpu_memory" json:"gpuMemory"`
	GpuModel         ovhtypes.TfStringValue `tfsdk:"gpu_model" json:"gpuModel"`
	Memory           ovhtypes.TfInt64Value  `tfsdk:"memory" json:"memory"`
	PrivateNetwork   ovhtypes.TfInt64Value  `tfsdk:"private_network" json:"privateNetwork"`
	PublicNetwork    ovhtypes.TfInt64Value  `tfsdk:"public_network" json:"publicNetwork"`
	state            attr.ValueState
}

func (v *SpecResourcesValue) UnmarshalJSON(data []byte) error {
	type JsonSpecResourcesValue SpecResourcesValue

	var tmp JsonSpecResourcesValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.Cpu = tmp.Cpu
	v.EphemeralStorage = tmp.EphemeralStorage
	v.Flavor = tmp.Flavor
	v.Gpu = tmp.Gpu
	v.GpuBrand = tmp.GpuBrand
	v.GpuMemory = tmp.GpuMemory
	v.GpuModel = tmp.GpuModel
	v.Memory = tmp.Memory
	v.PrivateNetwork = tmp.PrivateNetwork
	v.PublicNetwork = tmp.PublicNetwork

	v.state = attr.ValueStateKnown

	return nil
}

func (v *SpecResourcesValue) MergeWith(other *SpecResourcesValue) {

	if (v.Cpu.IsUnknown() || v.Cpu.IsNull()) && !other.Cpu.IsUnknown() {
		v.Cpu = other.Cpu
	}

	if (v.EphemeralStorage.IsUnknown() || v.EphemeralStorage.IsNull()) && !other.EphemeralStorage.IsUnknown() {
		v.EphemeralStorage = other.EphemeralStorage
	}

	if (v.Flavor.IsUnknown() || v.Flavor.IsNull()) && !other.Flavor.IsUnknown() {
		v.Flavor = other.Flavor
	}

	if (v.Gpu.IsUnknown() || v.Gpu.IsNull()) && !other.Gpu.IsUnknown() {
		v.Gpu = other.Gpu
	}

	if (v.GpuBrand.IsUnknown() || v.GpuBrand.IsNull()) && !other.GpuBrand.IsUnknown() {
		v.GpuBrand = other.GpuBrand
	}

	if (v.GpuMemory.IsUnknown() || v.GpuMemory.IsNull()) && !other.GpuMemory.IsUnknown() {
		v.GpuMemory = other.GpuMemory
	}

	if (v.GpuModel.IsUnknown() || v.GpuModel.IsNull()) && !other.GpuModel.IsUnknown() {
		v.GpuModel = other.GpuModel
	}

	if (v.Memory.IsUnknown() || v.Memory.IsNull()) && !other.Memory.IsUnknown() {
		v.Memory = other.Memory
	}

	if (v.PrivateNetwork.IsUnknown() || v.PrivateNetwork.IsNull()) && !other.PrivateNetwork.IsUnknown() {
		v.PrivateNetwork = other.PrivateNetwork
	}

	if (v.PublicNetwork.IsUnknown() || v.PublicNetwork.IsNull()) && !other.PublicNetwork.IsUnknown() {
		v.PublicNetwork = other.PublicNetwork
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v SpecResourcesValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"cpu":              v.Cpu,
		"ephemeralStorage": v.EphemeralStorage,
		"flavor":           v.Flavor,
		"gpu":              v.Gpu,
		"gpuBrand":         v.GpuBrand,
		"gpuMemory":        v.GpuMemory,
		"gpuModel":         v.GpuModel,
		"memory":           v.Memory,
		"privateNetwork":   v.PrivateNetwork,
		"publicNetwork":    v.PublicNetwork,
	}
}
func (v SpecResourcesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 10)

	var val tftypes.Value
	var err error

	attrTypes["cpu"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["ephemeral_storage"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["flavor"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["gpu"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["gpu_brand"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["gpu_memory"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["gpu_model"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["memory"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["private_network"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["public_network"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 10)

		val, err = v.Cpu.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cpu"] = val

		val, err = v.EphemeralStorage.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ephemeral_storage"] = val

		val, err = v.Flavor.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["flavor"] = val

		val, err = v.Gpu.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["gpu"] = val

		val, err = v.GpuBrand.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["gpu_brand"] = val

		val, err = v.GpuMemory.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["gpu_memory"] = val

		val, err = v.GpuModel.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["gpu_model"] = val

		val, err = v.Memory.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["memory"] = val

		val, err = v.PrivateNetwork.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["private_network"] = val

		val, err = v.PublicNetwork.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["public_network"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SpecResourcesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SpecResourcesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SpecResourcesValue) String() string {
	return "SpecResourcesValue"
}

func (v SpecResourcesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"cpu":               ovhtypes.TfInt64Type{},
			"ephemeral_storage": ovhtypes.TfInt64Type{},
			"flavor":            ovhtypes.TfStringType{},
			"gpu":               ovhtypes.TfInt64Type{},
			"gpu_brand":         ovhtypes.TfStringType{},
			"gpu_memory":        ovhtypes.TfInt64Type{},
			"gpu_model":         ovhtypes.TfStringType{},
			"memory":            ovhtypes.TfInt64Type{},
			"private_network":   ovhtypes.TfInt64Type{},
			"public_network":    ovhtypes.TfInt64Type{},
		},
		map[string]attr.Value{
			"cpu":               v.Cpu,
			"ephemeral_storage": v.EphemeralStorage,
			"flavor":            v.Flavor,
			"gpu":               v.Gpu,
			"gpu_brand":         v.GpuBrand,
			"gpu_memory":        v.GpuMemory,
			"gpu_model":         v.GpuModel,
			"memory":            v.Memory,
			"private_network":   v.PrivateNetwork,
			"public_network":    v.PublicNetwork,
		})

	return objVal, diags
}

func (v SpecResourcesValue) Equal(o attr.Value) bool {
	other, ok := o.(SpecResourcesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Cpu.Equal(other.Cpu) {
		return false
	}

	if !v.EphemeralStorage.Equal(other.EphemeralStorage) {
		return false
	}

	if !v.Flavor.Equal(other.Flavor) {
		return false
	}

	if !v.Gpu.Equal(other.Gpu) {
		return false
	}

	if !v.GpuBrand.Equal(other.GpuBrand) {
		return false
	}

	if !v.GpuMemory.Equal(other.GpuMemory) {
		return false
	}

	if !v.GpuModel.Equal(other.GpuModel) {
		return false
	}

	if !v.Memory.Equal(other.Memory) {
		return false
	}

	if !v.PrivateNetwork.Equal(other.PrivateNetwork) {
		return false
	}

	if !v.PublicNetwork.Equal(other.PublicNetwork) {
		return false
	}

	return true
}

func (v SpecResourcesValue) Type(ctx context.Context) attr.Type {
	return SpecResourcesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SpecResourcesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"cpu":               ovhtypes.TfInt64Type{},
		"ephemeral_storage": ovhtypes.TfInt64Type{},
		"flavor":            ovhtypes.TfStringType{},
		"gpu":               ovhtypes.TfInt64Type{},
		"gpu_brand":         ovhtypes.TfStringType{},
		"gpu_memory":        ovhtypes.TfInt64Type{},
		"gpu_model":         ovhtypes.TfStringType{},
		"memory":            ovhtypes.TfInt64Type{},
		"private_network":   ovhtypes.TfInt64Type{},
		"public_network":    ovhtypes.TfInt64Type{},
	}
}

var _ basetypes.ObjectTypable = SpecScalingStrategyType{}

type SpecScalingStrategyType struct {
	basetypes.ObjectType
}

func (t SpecScalingStrategyType) Equal(o attr.Type) bool {
	other, ok := o.(SpecScalingStrategyType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SpecScalingStrategyType) String() string {
	return "SpecScalingStrategyType"
}

func (t SpecScalingStrategyType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	automaticAttribute, ok := attributes["automatic"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`automatic is missing from object`)

		return nil, diags
	}

	automaticVal, ok := automaticAttribute.(SpecScalingStrategyAutomaticValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`automatic expected to be SpecScalingStrategyAutomaticValue, was: %T`, automaticAttribute))
	}

	fixedAttribute, ok := attributes["fixed"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fixed is missing from object`)

		return nil, diags
	}

	fixedVal, ok := fixedAttribute.(SpecScalingStrategyFixedValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fixed expected to be SpecScalingStrategyFixedValue, was: %T`, fixedAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SpecScalingStrategyValue{
		Automatic: automaticVal,
		Fixed:     fixedVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewSpecScalingStrategyValueNull() SpecScalingStrategyValue {
	return SpecScalingStrategyValue{
		state: attr.ValueStateNull,
	}
}

func NewSpecScalingStrategyValueUnknown() SpecScalingStrategyValue {
	return SpecScalingStrategyValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSpecScalingStrategyValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SpecScalingStrategyValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SpecScalingStrategyValue Attribute Value",
				"While creating a SpecScalingStrategyValue value, a missing attribute value was detected. "+
					"A SpecScalingStrategyValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpecScalingStrategyValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SpecScalingStrategyValue Attribute Type",
				"While creating a SpecScalingStrategyValue value, an invalid attribute value was detected. "+
					"A SpecScalingStrategyValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpecScalingStrategyValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SpecScalingStrategyValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SpecScalingStrategyValue Attribute Value",
				"While creating a SpecScalingStrategyValue value, an extra attribute value was detected. "+
					"A SpecScalingStrategyValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SpecScalingStrategyValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSpecScalingStrategyValueUnknown(), diags
	}

	automaticAttribute, ok := attributes["automatic"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`automatic is missing from object`)

		return NewSpecScalingStrategyValueUnknown(), diags
	}

	automaticVal, ok := automaticAttribute.(SpecScalingStrategyAutomaticValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`automatic expected to be SpecScalingStrategyAutomaticValue, was: %T`, automaticAttribute))
	}

	fixedAttribute, ok := attributes["fixed"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fixed is missing from object`)

		return NewSpecScalingStrategyValueUnknown(), diags
	}

	fixedVal, ok := fixedAttribute.(SpecScalingStrategyFixedValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fixed expected to be SpecScalingStrategyFixedValue, was: %T`, fixedAttribute))
	}

	if diags.HasError() {
		return NewSpecScalingStrategyValueUnknown(), diags
	}

	return SpecScalingStrategyValue{
		Automatic: automaticVal,
		Fixed:     fixedVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewSpecScalingStrategyValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SpecScalingStrategyValue {
	object, diags := NewSpecScalingStrategyValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSpecScalingStrategyValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SpecScalingStrategyType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSpecScalingStrategyValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSpecScalingStrategyValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSpecScalingStrategyValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSpecScalingStrategyValueMust(SpecScalingStrategyValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SpecScalingStrategyType) ValueType(ctx context.Context) attr.Value {
	return SpecScalingStrategyValue{}
}

var _ basetypes.ObjectValuable = SpecScalingStrategyValue{}

type SpecScalingStrategyValue struct {
	Automatic SpecScalingStrategyAutomaticValue `tfsdk:"automatic" json:"automatic"`
	Fixed     SpecScalingStrategyFixedValue     `tfsdk:"fixed" json:"fixed"`
	state     attr.ValueState
}

func (v *SpecScalingStrategyValue) UnmarshalJSON(data []byte) error {
	type JsonSpecScalingStrategyValue SpecScalingStrategyValue

	var tmp JsonSpecScalingStrategyValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.Automatic = tmp.Automatic
	v.Fixed = tmp.Fixed

	v.state = attr.ValueStateKnown

	return nil
}

func (v *SpecScalingStrategyValue) MergeWith(other *SpecScalingStrategyValue) {

	if v.Automatic.IsUnknown() && !other.Automatic.IsUnknown() {
		v.Automatic = other.Automatic
	} else if !other.Automatic.IsUnknown() {
		v.Automatic.MergeWith(&other.Automatic)
	}

	if v.Fixed.IsUnknown() && !other.Fixed.IsUnknown() {
		v.Fixed = other.Fixed
	} else if !other.Fixed.IsUnknown() {
		v.Fixed.MergeWith(&other.Fixed)
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v SpecScalingStrategyValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"automatic": v.Automatic,
		"fixed":     v.Fixed,
	}
}
func (v SpecScalingStrategyValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["automatic"] = basetypes.ObjectType{
		AttrTypes: SpecScalingStrategyAutomaticValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["fixed"] = basetypes.ObjectType{
		AttrTypes: SpecScalingStrategyFixedValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Automatic.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["automatic"] = val

		val, err = v.Fixed.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["fixed"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SpecScalingStrategyValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SpecScalingStrategyValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SpecScalingStrategyValue) String() string {
	return "SpecScalingStrategyValue"
}

func (v SpecScalingStrategyValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"automatic": SpecScalingStrategyAutomaticType{
				basetypes.ObjectType{
					AttrTypes: SpecScalingStrategyAutomaticValue{}.AttributeTypes(ctx),
				},
			},
			"fixed": SpecScalingStrategyFixedType{
				basetypes.ObjectType{
					AttrTypes: SpecScalingStrategyFixedValue{}.AttributeTypes(ctx),
				},
			},
		},
		map[string]attr.Value{
			"automatic": v.Automatic,
			"fixed":     v.Fixed,
		})

	return objVal, diags
}

func (v SpecScalingStrategyValue) Equal(o attr.Value) bool {
	other, ok := o.(SpecScalingStrategyValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Automatic.Equal(other.Automatic) {
		return false
	}

	if !v.Fixed.Equal(other.Fixed) {
		return false
	}

	return true
}

func (v SpecScalingStrategyValue) Type(ctx context.Context) attr.Type {
	return SpecScalingStrategyType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SpecScalingStrategyValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"automatic": SpecScalingStrategyAutomaticValue{}.Type(ctx),
		"fixed":     SpecScalingStrategyFixedValue{}.Type(ctx),
	}
}

var _ basetypes.ObjectTypable = SpecScalingStrategyAutomaticType{}

type SpecScalingStrategyAutomaticType struct {
	basetypes.ObjectType
}

func (t SpecScalingStrategyAutomaticType) Equal(o attr.Type) bool {
	other, ok := o.(SpecScalingStrategyAutomaticType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SpecScalingStrategyAutomaticType) String() string {
	return "SpecScalingStrategyAutomaticType"
}

func (t SpecScalingStrategyAutomaticType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	averageUsageTargetAttribute, ok := attributes["average_usage_target"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`average_usage_target is missing from object`)

		return nil, diags
	}

	averageUsageTargetVal, ok := averageUsageTargetAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`average_usage_target expected to be ovhtypes.TfInt64Value, was: %T`, averageUsageTargetAttribute))
	}

	replicasMaxAttribute, ok := attributes["replicas_max"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`replicas_max is missing from object`)

		return nil, diags
	}

	replicasMaxVal, ok := replicasMaxAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`replicas_max expected to be ovhtypes.TfInt64Value, was: %T`, replicasMaxAttribute))
	}

	replicasMinAttribute, ok := attributes["replicas_min"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`replicas_min is missing from object`)

		return nil, diags
	}

	replicasMinVal, ok := replicasMinAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`replicas_min expected to be ovhtypes.TfInt64Value, was: %T`, replicasMinAttribute))
	}

	resourceTypeAttribute, ok := attributes["resource_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`resource_type is missing from object`)

		return nil, diags
	}

	resourceTypeVal, ok := resourceTypeAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`resource_type expected to be ovhtypes.TfStringValue, was: %T`, resourceTypeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SpecScalingStrategyAutomaticValue{
		AverageUsageTarget: averageUsageTargetVal,
		ReplicasMax:        replicasMaxVal,
		ReplicasMin:        replicasMinVal,
		ResourceType:       resourceTypeVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewSpecScalingStrategyAutomaticValueNull() SpecScalingStrategyAutomaticValue {
	return SpecScalingStrategyAutomaticValue{
		state: attr.ValueStateNull,
	}
}

func NewSpecScalingStrategyAutomaticValueUnknown() SpecScalingStrategyAutomaticValue {
	return SpecScalingStrategyAutomaticValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSpecScalingStrategyAutomaticValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SpecScalingStrategyAutomaticValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SpecScalingStrategyAutomaticValue Attribute Value",
				"While creating a SpecScalingStrategyAutomaticValue value, a missing attribute value was detected. "+
					"A SpecScalingStrategyAutomaticValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpecScalingStrategyAutomaticValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SpecScalingStrategyAutomaticValue Attribute Type",
				"While creating a SpecScalingStrategyAutomaticValue value, an invalid attribute value was detected. "+
					"A SpecScalingStrategyAutomaticValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpecScalingStrategyAutomaticValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SpecScalingStrategyAutomaticValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SpecScalingStrategyAutomaticValue Attribute Value",
				"While creating a SpecScalingStrategyAutomaticValue value, an extra attribute value was detected. "+
					"A SpecScalingStrategyAutomaticValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SpecScalingStrategyAutomaticValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSpecScalingStrategyAutomaticValueUnknown(), diags
	}

	averageUsageTargetAttribute, ok := attributes["average_usage_target"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`average_usage_target is missing from object`)

		return NewSpecScalingStrategyAutomaticValueUnknown(), diags
	}

	averageUsageTargetVal, ok := averageUsageTargetAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`average_usage_target expected to be ovhtypes.TfInt64Value, was: %T`, averageUsageTargetAttribute))
	}

	replicasMaxAttribute, ok := attributes["replicas_max"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`replicas_max is missing from object`)

		return NewSpecScalingStrategyAutomaticValueUnknown(), diags
	}

	replicasMaxVal, ok := replicasMaxAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`replicas_max expected to be ovhtypes.TfInt64Value, was: %T`, replicasMaxAttribute))
	}

	replicasMinAttribute, ok := attributes["replicas_min"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`replicas_min is missing from object`)

		return NewSpecScalingStrategyAutomaticValueUnknown(), diags
	}

	replicasMinVal, ok := replicasMinAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`replicas_min expected to be ovhtypes.TfInt64Value, was: %T`, replicasMinAttribute))
	}

	resourceTypeAttribute, ok := attributes["resource_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`resource_type is missing from object`)

		return NewSpecScalingStrategyAutomaticValueUnknown(), diags
	}

	resourceTypeVal, ok := resourceTypeAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`resource_type expected to be ovhtypes.TfStringValue, was: %T`, resourceTypeAttribute))
	}

	if diags.HasError() {
		return NewSpecScalingStrategyAutomaticValueUnknown(), diags
	}

	return SpecScalingStrategyAutomaticValue{
		AverageUsageTarget: averageUsageTargetVal,
		ReplicasMax:        replicasMaxVal,
		ReplicasMin:        replicasMinVal,
		ResourceType:       resourceTypeVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewSpecScalingStrategyAutomaticValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SpecScalingStrategyAutomaticValue {
	object, diags := NewSpecScalingStrategyAutomaticValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSpecScalingStrategyAutomaticValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SpecScalingStrategyAutomaticType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSpecScalingStrategyAutomaticValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSpecScalingStrategyAutomaticValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSpecScalingStrategyAutomaticValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSpecScalingStrategyAutomaticValueMust(SpecScalingStrategyAutomaticValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SpecScalingStrategyAutomaticType) ValueType(ctx context.Context) attr.Value {
	return SpecScalingStrategyAutomaticValue{}
}

var _ basetypes.ObjectValuable = SpecScalingStrategyAutomaticValue{}

type SpecScalingStrategyAutomaticValue struct {
	AverageUsageTarget ovhtypes.TfInt64Value  `tfsdk:"average_usage_target" json:"averageUsageTarget"`
	ReplicasMax        ovhtypes.TfInt64Value  `tfsdk:"replicas_max" json:"replicasMax"`
	ReplicasMin        ovhtypes.TfInt64Value  `tfsdk:"replicas_min" json:"replicasMin"`
	ResourceType       ovhtypes.TfStringValue `tfsdk:"resource_type" json:"resourceType"`
	state              attr.ValueState
}

func (v *SpecScalingStrategyAutomaticValue) UnmarshalJSON(data []byte) error {
	type JsonSpecScalingStrategyAutomaticValue SpecScalingStrategyAutomaticValue

	var tmp JsonSpecScalingStrategyAutomaticValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.AverageUsageTarget = tmp.AverageUsageTarget
	v.ReplicasMax = tmp.ReplicasMax
	v.ReplicasMin = tmp.ReplicasMin
	v.ResourceType = tmp.ResourceType

	v.state = attr.ValueStateKnown

	return nil
}

func (v *SpecScalingStrategyAutomaticValue) MergeWith(other *SpecScalingStrategyAutomaticValue) {

	if (v.AverageUsageTarget.IsUnknown() || v.AverageUsageTarget.IsNull()) && !other.AverageUsageTarget.IsUnknown() {
		v.AverageUsageTarget = other.AverageUsageTarget
	}

	if (v.ReplicasMax.IsUnknown() || v.ReplicasMax.IsNull()) && !other.ReplicasMax.IsUnknown() {
		v.ReplicasMax = other.ReplicasMax
	}

	if (v.ReplicasMin.IsUnknown() || v.ReplicasMin.IsNull()) && !other.ReplicasMin.IsUnknown() {
		v.ReplicasMin = other.ReplicasMin
	}

	if (v.ResourceType.IsUnknown() || v.ResourceType.IsNull()) && !other.ResourceType.IsUnknown() {
		v.ResourceType = other.ResourceType
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v SpecScalingStrategyAutomaticValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"averageUsageTarget": v.AverageUsageTarget,
		"replicasMax":        v.ReplicasMax,
		"replicasMin":        v.ReplicasMin,
		"resourceType":       v.ResourceType,
	}
}
func (v SpecScalingStrategyAutomaticValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["average_usage_target"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["replicas_max"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["replicas_min"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["resource_type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.AverageUsageTarget.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["average_usage_target"] = val

		val, err = v.ReplicasMax.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["replicas_max"] = val

		val, err = v.ReplicasMin.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["replicas_min"] = val

		val, err = v.ResourceType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["resource_type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SpecScalingStrategyAutomaticValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SpecScalingStrategyAutomaticValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SpecScalingStrategyAutomaticValue) String() string {
	return "SpecScalingStrategyAutomaticValue"
}

func (v SpecScalingStrategyAutomaticValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"average_usage_target": ovhtypes.TfInt64Type{},
			"replicas_max":         ovhtypes.TfInt64Type{},
			"replicas_min":         ovhtypes.TfInt64Type{},
			"resource_type":        ovhtypes.TfStringType{},
		},
		map[string]attr.Value{
			"average_usage_target": v.AverageUsageTarget,
			"replicas_max":         v.ReplicasMax,
			"replicas_min":         v.ReplicasMin,
			"resource_type":        v.ResourceType,
		})

	return objVal, diags
}

func (v SpecScalingStrategyAutomaticValue) Equal(o attr.Value) bool {
	other, ok := o.(SpecScalingStrategyAutomaticValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AverageUsageTarget.Equal(other.AverageUsageTarget) {
		return false
	}

	if !v.ReplicasMax.Equal(other.ReplicasMax) {
		return false
	}

	if !v.ReplicasMin.Equal(other.ReplicasMin) {
		return false
	}

	if !v.ResourceType.Equal(other.ResourceType) {
		return false
	}

	return true
}

func (v SpecScalingStrategyAutomaticValue) Type(ctx context.Context) attr.Type {
	return SpecScalingStrategyAutomaticType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SpecScalingStrategyAutomaticValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"average_usage_target": ovhtypes.TfInt64Type{},
		"replicas_max":         ovhtypes.TfInt64Type{},
		"replicas_min":         ovhtypes.TfInt64Type{},
		"resource_type":        ovhtypes.TfStringType{},
	}
}

var _ basetypes.ObjectTypable = SpecScalingStrategyFixedType{}

type SpecScalingStrategyFixedType struct {
	basetypes.ObjectType
}

func (t SpecScalingStrategyFixedType) Equal(o attr.Type) bool {
	other, ok := o.(SpecScalingStrategyFixedType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SpecScalingStrategyFixedType) String() string {
	return "SpecScalingStrategyFixedType"
}

func (t SpecScalingStrategyFixedType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	replicasAttribute, ok := attributes["replicas"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`replicas is missing from object`)

		return nil, diags
	}

	replicasVal, ok := replicasAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`replicas expected to be ovhtypes.TfInt64Value, was: %T`, replicasAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SpecScalingStrategyFixedValue{
		Replicas: replicasVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewSpecScalingStrategyFixedValueNull() SpecScalingStrategyFixedValue {
	return SpecScalingStrategyFixedValue{
		state: attr.ValueStateNull,
	}
}

func NewSpecScalingStrategyFixedValueUnknown() SpecScalingStrategyFixedValue {
	return SpecScalingStrategyFixedValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSpecScalingStrategyFixedValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SpecScalingStrategyFixedValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SpecScalingStrategyFixedValue Attribute Value",
				"While creating a SpecScalingStrategyFixedValue value, a missing attribute value was detected. "+
					"A SpecScalingStrategyFixedValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpecScalingStrategyFixedValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SpecScalingStrategyFixedValue Attribute Type",
				"While creating a SpecScalingStrategyFixedValue value, an invalid attribute value was detected. "+
					"A SpecScalingStrategyFixedValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpecScalingStrategyFixedValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SpecScalingStrategyFixedValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SpecScalingStrategyFixedValue Attribute Value",
				"While creating a SpecScalingStrategyFixedValue value, an extra attribute value was detected. "+
					"A SpecScalingStrategyFixedValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SpecScalingStrategyFixedValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSpecScalingStrategyFixedValueUnknown(), diags
	}

	replicasAttribute, ok := attributes["replicas"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`replicas is missing from object`)

		return NewSpecScalingStrategyFixedValueUnknown(), diags
	}

	replicasVal, ok := replicasAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`replicas expected to be ovhtypes.TfInt64Value, was: %T`, replicasAttribute))
	}

	if diags.HasError() {
		return NewSpecScalingStrategyFixedValueUnknown(), diags
	}

	return SpecScalingStrategyFixedValue{
		Replicas: replicasVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewSpecScalingStrategyFixedValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SpecScalingStrategyFixedValue {
	object, diags := NewSpecScalingStrategyFixedValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSpecScalingStrategyFixedValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SpecScalingStrategyFixedType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSpecScalingStrategyFixedValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSpecScalingStrategyFixedValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSpecScalingStrategyFixedValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSpecScalingStrategyFixedValueMust(SpecScalingStrategyFixedValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SpecScalingStrategyFixedType) ValueType(ctx context.Context) attr.Value {
	return SpecScalingStrategyFixedValue{}
}

var _ basetypes.ObjectValuable = SpecScalingStrategyFixedValue{}

type SpecScalingStrategyFixedValue struct {
	Replicas ovhtypes.TfInt64Value `tfsdk:"replicas" json:"replicas"`
	state    attr.ValueState
}

func (v *SpecScalingStrategyFixedValue) UnmarshalJSON(data []byte) error {
	type JsonSpecScalingStrategyFixedValue SpecScalingStrategyFixedValue

	var tmp JsonSpecScalingStrategyFixedValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.Replicas = tmp.Replicas

	v.state = attr.ValueStateKnown

	return nil
}

func (v *SpecScalingStrategyFixedValue) MergeWith(other *SpecScalingStrategyFixedValue) {

	if (v.Replicas.IsUnknown() || v.Replicas.IsNull()) && !other.Replicas.IsUnknown() {
		v.Replicas = other.Replicas
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v SpecScalingStrategyFixedValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"replicas": v.Replicas,
	}
}
func (v SpecScalingStrategyFixedValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["replicas"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Replicas.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["replicas"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SpecScalingStrategyFixedValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SpecScalingStrategyFixedValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SpecScalingStrategyFixedValue) String() string {
	return "SpecScalingStrategyFixedValue"
}

func (v SpecScalingStrategyFixedValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"replicas": ovhtypes.TfInt64Type{},
		},
		map[string]attr.Value{
			"replicas": v.Replicas,
		})

	return objVal, diags
}

func (v SpecScalingStrategyFixedValue) Equal(o attr.Value) bool {
	other, ok := o.(SpecScalingStrategyFixedValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Replicas.Equal(other.Replicas) {
		return false
	}

	return true
}

func (v SpecScalingStrategyFixedValue) Type(ctx context.Context) attr.Type {
	return SpecScalingStrategyFixedType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SpecScalingStrategyFixedValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"replicas": ovhtypes.TfInt64Type{},
	}
}

var _ basetypes.ObjectTypable = SpecVolumesType{}

type SpecVolumesType struct {
	basetypes.ObjectType
}

func (t SpecVolumesType) Equal(o attr.Type) bool {
	other, ok := o.(SpecVolumesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SpecVolumesType) String() string {
	return "SpecVolumesType"
}

func (t SpecVolumesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	cacheAttribute, ok := attributes["cache"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cache is missing from object`)

		return nil, diags
	}

	cacheVal, ok := cacheAttribute.(ovhtypes.TfBoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cache expected to be ovhtypes.TfBoolValue, was: %T`, cacheAttribute))
	}

	containerAttribute, ok := attributes["container"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`container is missing from object`)

		return nil, diags
	}

	containerVal, ok := containerAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`container expected to be ovhtypes.TfStringValue, was: %T`, containerAttribute))
	}

	dataStoreAttribute, ok := attributes["data_store"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`data_store is missing from object`)

		return nil, diags
	}

	dataStoreVal, ok := dataStoreAttribute.(SpecVolumesDataStoreValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`data_store expected to be SpecVolumesDataStoreValue, was: %T`, dataStoreAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be ovhtypes.TfStringValue, was: %T`, idAttribute))
	}

	mountPathAttribute, ok := attributes["mount_path"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mount_path is missing from object`)

		return nil, diags
	}

	mountPathVal, ok := mountPathAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mount_path expected to be ovhtypes.TfStringValue, was: %T`, mountPathAttribute))
	}

	permissionAttribute, ok := attributes["permission"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`permission is missing from object`)

		return nil, diags
	}

	permissionVal, ok := permissionAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`permission expected to be ovhtypes.TfStringValue, was: %T`, permissionAttribute))
	}

	prefixAttribute, ok := attributes["prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix is missing from object`)

		return nil, diags
	}

	prefixVal, ok := prefixAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix expected to be ovhtypes.TfStringValue, was: %T`, prefixAttribute))
	}

	privateSwiftAttribute, ok := attributes["private_swift"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`private_swift is missing from object`)

		return nil, diags
	}

	privateSwiftVal, ok := privateSwiftAttribute.(SpecVolumesPrivateSwiftValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`private_swift expected to be SpecVolumesPrivateSwiftValue, was: %T`, privateSwiftAttribute))
	}

	publicGitAttribute, ok := attributes["public_git"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`public_git is missing from object`)

		return nil, diags
	}

	publicGitVal, ok := publicGitAttribute.(SpecVolumesPublicGitValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`public_git expected to be SpecVolumesPublicGitValue, was: %T`, publicGitAttribute))
	}

	publicSwiftAttribute, ok := attributes["public_swift"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`public_swift is missing from object`)

		return nil, diags
	}

	publicSwiftVal, ok := publicSwiftAttribute.(SpecVolumesPublicSwiftValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`public_swift expected to be SpecVolumesPublicSwiftValue, was: %T`, publicSwiftAttribute))
	}

	regionAttribute, ok := attributes["region"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`region is missing from object`)

		return nil, diags
	}

	regionVal, ok := regionAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`region expected to be ovhtypes.TfStringValue, was: %T`, regionAttribute))
	}

	standaloneAttribute, ok := attributes["standalone"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`standalone is missing from object`)

		return nil, diags
	}

	standaloneVal, ok := standaloneAttribute.(SpecVolumesStandaloneValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`standalone expected to be SpecVolumesStandaloneValue, was: %T`, standaloneAttribute))
	}

	targetDataStoreAttribute, ok := attributes["target_data_store"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`target_data_store is missing from object`)

		return nil, diags
	}

	targetDataStoreVal, ok := targetDataStoreAttribute.(SpecVolumesTargetDataStoreValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`target_data_store expected to be SpecVolumesTargetDataStoreValue, was: %T`, targetDataStoreAttribute))
	}

	targetPrivateSwiftAttribute, ok := attributes["target_private_swift"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`target_private_swift is missing from object`)

		return nil, diags
	}

	targetPrivateSwiftVal, ok := targetPrivateSwiftAttribute.(SpecVolumesTargetPrivateSwiftValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`target_private_swift expected to be SpecVolumesTargetPrivateSwiftValue, was: %T`, targetPrivateSwiftAttribute))
	}

	volumeSourceAttribute, ok := attributes["volume_source"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_source is missing from object`)

		return nil, diags
	}

	volumeSourceVal, ok := volumeSourceAttribute.(SpecVolumesVolumeSourceValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_source expected to be SpecVolumesVolumeSourceValue, was: %T`, volumeSourceAttribute))
	}

	volumeTargetAttribute, ok := attributes["volume_target"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_target is missing from object`)

		return nil, diags
	}

	volumeTargetVal, ok := volumeTargetAttribute.(SpecVolumesVolumeTargetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_target expected to be SpecVolumesVolumeTargetValue, was: %T`, volumeTargetAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SpecVolumesValue{
		Cache:              cacheVal,
		Container:          containerVal,
		DataStore:          dataStoreVal,
		Id:                 idVal,
		MountPath:          mountPathVal,
		Permission:         permissionVal,
		Prefix:             prefixVal,
		PrivateSwift:       privateSwiftVal,
		PublicGit:          publicGitVal,
		PublicSwift:        publicSwiftVal,
		Region:             regionVal,
		Standalone:         standaloneVal,
		TargetDataStore:    targetDataStoreVal,
		TargetPrivateSwift: targetPrivateSwiftVal,
		VolumeSource:       volumeSourceVal,
		VolumeTarget:       volumeTargetVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewSpecVolumesValueNull() SpecVolumesValue {
	return SpecVolumesValue{
		state: attr.ValueStateNull,
	}
}

func NewSpecVolumesValueUnknown() SpecVolumesValue {
	return SpecVolumesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSpecVolumesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SpecVolumesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SpecVolumesValue Attribute Value",
				"While creating a SpecVolumesValue value, a missing attribute value was detected. "+
					"A SpecVolumesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpecVolumesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SpecVolumesValue Attribute Type",
				"While creating a SpecVolumesValue value, an invalid attribute value was detected. "+
					"A SpecVolumesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpecVolumesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SpecVolumesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SpecVolumesValue Attribute Value",
				"While creating a SpecVolumesValue value, an extra attribute value was detected. "+
					"A SpecVolumesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SpecVolumesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSpecVolumesValueUnknown(), diags
	}

	cacheAttribute, ok := attributes["cache"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cache is missing from object`)

		return NewSpecVolumesValueUnknown(), diags
	}

	cacheVal, ok := cacheAttribute.(ovhtypes.TfBoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cache expected to be ovhtypes.TfBoolValue, was: %T`, cacheAttribute))
	}

	containerAttribute, ok := attributes["container"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`container is missing from object`)

		return NewSpecVolumesValueUnknown(), diags
	}

	containerVal, ok := containerAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`container expected to be ovhtypes.TfStringValue, was: %T`, containerAttribute))
	}

	dataStoreAttribute, ok := attributes["data_store"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`data_store is missing from object`)

		return NewSpecVolumesValueUnknown(), diags
	}

	dataStoreVal, ok := dataStoreAttribute.(SpecVolumesDataStoreValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`data_store expected to be SpecVolumesDataStoreValue, was: %T`, dataStoreAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewSpecVolumesValueUnknown(), diags
	}

	idVal, ok := idAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be ovhtypes.TfStringValue, was: %T`, idAttribute))
	}

	mountPathAttribute, ok := attributes["mount_path"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mount_path is missing from object`)

		return NewSpecVolumesValueUnknown(), diags
	}

	mountPathVal, ok := mountPathAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mount_path expected to be ovhtypes.TfStringValue, was: %T`, mountPathAttribute))
	}

	permissionAttribute, ok := attributes["permission"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`permission is missing from object`)

		return NewSpecVolumesValueUnknown(), diags
	}

	permissionVal, ok := permissionAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`permission expected to be ovhtypes.TfStringValue, was: %T`, permissionAttribute))
	}

	prefixAttribute, ok := attributes["prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix is missing from object`)

		return NewSpecVolumesValueUnknown(), diags
	}

	prefixVal, ok := prefixAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix expected to be ovhtypes.TfStringValue, was: %T`, prefixAttribute))
	}

	privateSwiftAttribute, ok := attributes["private_swift"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`private_swift is missing from object`)

		return NewSpecVolumesValueUnknown(), diags
	}

	privateSwiftVal, ok := privateSwiftAttribute.(SpecVolumesPrivateSwiftValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`private_swift expected to be SpecVolumesPrivateSwiftValue, was: %T`, privateSwiftAttribute))
	}

	publicGitAttribute, ok := attributes["public_git"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`public_git is missing from object`)

		return NewSpecVolumesValueUnknown(), diags
	}

	publicGitVal, ok := publicGitAttribute.(SpecVolumesPublicGitValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`public_git expected to be SpecVolumesPublicGitValue, was: %T`, publicGitAttribute))
	}

	publicSwiftAttribute, ok := attributes["public_swift"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`public_swift is missing from object`)

		return NewSpecVolumesValueUnknown(), diags
	}

	publicSwiftVal, ok := publicSwiftAttribute.(SpecVolumesPublicSwiftValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`public_swift expected to be SpecVolumesPublicSwiftValue, was: %T`, publicSwiftAttribute))
	}

	regionAttribute, ok := attributes["region"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`region is missing from object`)

		return NewSpecVolumesValueUnknown(), diags
	}

	regionVal, ok := regionAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`region expected to be ovhtypes.TfStringValue, was: %T`, regionAttribute))
	}

	standaloneAttribute, ok := attributes["standalone"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`standalone is missing from object`)

		return NewSpecVolumesValueUnknown(), diags
	}

	standaloneVal, ok := standaloneAttribute.(SpecVolumesStandaloneValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`standalone expected to be SpecVolumesStandaloneValue, was: %T`, standaloneAttribute))
	}

	targetDataStoreAttribute, ok := attributes["target_data_store"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`target_data_store is missing from object`)

		return NewSpecVolumesValueUnknown(), diags
	}

	targetDataStoreVal, ok := targetDataStoreAttribute.(SpecVolumesTargetDataStoreValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`target_data_store expected to be SpecVolumesTargetDataStoreValue, was: %T`, targetDataStoreAttribute))
	}

	targetPrivateSwiftAttribute, ok := attributes["target_private_swift"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`target_private_swift is missing from object`)

		return NewSpecVolumesValueUnknown(), diags
	}

	targetPrivateSwiftVal, ok := targetPrivateSwiftAttribute.(SpecVolumesTargetPrivateSwiftValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`target_private_swift expected to be SpecVolumesTargetPrivateSwiftValue, was: %T`, targetPrivateSwiftAttribute))
	}

	volumeSourceAttribute, ok := attributes["volume_source"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_source is missing from object`)

		return NewSpecVolumesValueUnknown(), diags
	}

	volumeSourceVal, ok := volumeSourceAttribute.(SpecVolumesVolumeSourceValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_source expected to be SpecVolumesVolumeSourceValue, was: %T`, volumeSourceAttribute))
	}

	volumeTargetAttribute, ok := attributes["volume_target"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_target is missing from object`)

		return NewSpecVolumesValueUnknown(), diags
	}

	volumeTargetVal, ok := volumeTargetAttribute.(SpecVolumesVolumeTargetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_target expected to be SpecVolumesVolumeTargetValue, was: %T`, volumeTargetAttribute))
	}

	if diags.HasError() {
		return NewSpecVolumesValueUnknown(), diags
	}

	return SpecVolumesValue{
		Cache:              cacheVal,
		Container:          containerVal,
		DataStore:          dataStoreVal,
		Id:                 idVal,
		MountPath:          mountPathVal,
		Permission:         permissionVal,
		Prefix:             prefixVal,
		PrivateSwift:       privateSwiftVal,
		PublicGit:          publicGitVal,
		PublicSwift:        publicSwiftVal,
		Region:             regionVal,
		Standalone:         standaloneVal,
		TargetDataStore:    targetDataStoreVal,
		TargetPrivateSwift: targetPrivateSwiftVal,
		VolumeSource:       volumeSourceVal,
		VolumeTarget:       volumeTargetVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewSpecVolumesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SpecVolumesValue {
	object, diags := NewSpecVolumesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSpecVolumesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SpecVolumesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSpecVolumesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSpecVolumesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSpecVolumesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSpecVolumesValueMust(SpecVolumesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SpecVolumesType) ValueType(ctx context.Context) attr.Value {
	return SpecVolumesValue{}
}

var _ basetypes.ObjectValuable = SpecVolumesValue{}

type SpecVolumesValue struct {
	Cache              ovhtypes.TfBoolValue               `tfsdk:"cache" json:"cache"`
	Container          ovhtypes.TfStringValue             `tfsdk:"container" json:"container"`
	DataStore          SpecVolumesDataStoreValue          `tfsdk:"data_store" json:"dataStore"`
	Id                 ovhtypes.TfStringValue             `tfsdk:"id" json:"id"`
	MountPath          ovhtypes.TfStringValue             `tfsdk:"mount_path" json:"mountPath"`
	Permission         ovhtypes.TfStringValue             `tfsdk:"permission" json:"permission"`
	Prefix             ovhtypes.TfStringValue             `tfsdk:"prefix" json:"prefix"`
	PrivateSwift       SpecVolumesPrivateSwiftValue       `tfsdk:"private_swift" json:"privateSwift"`
	PublicGit          SpecVolumesPublicGitValue          `tfsdk:"public_git" json:"publicGit"`
	PublicSwift        SpecVolumesPublicSwiftValue        `tfsdk:"public_swift" json:"publicSwift"`
	Region             ovhtypes.TfStringValue             `tfsdk:"region" json:"region"`
	Standalone         SpecVolumesStandaloneValue         `tfsdk:"standalone" json:"standalone"`
	TargetDataStore    SpecVolumesTargetDataStoreValue    `tfsdk:"target_data_store" json:"targetDataStore"`
	TargetPrivateSwift SpecVolumesTargetPrivateSwiftValue `tfsdk:"target_private_swift" json:"targetPrivateSwift"`
	VolumeSource       SpecVolumesVolumeSourceValue       `tfsdk:"volume_source" json:"volumeSource"`
	VolumeTarget       SpecVolumesVolumeTargetValue       `tfsdk:"volume_target" json:"volumeTarget"`
	state              attr.ValueState
}

func (v SpecVolumesValue) ToCreate() *SpecVolumesValue {
	res := &SpecVolumesValue{}

	if !v.Cache.IsNull() {
		res.Cache = v.Cache
	}

	res.state = attr.ValueStateKnown

	return res
}

func (v SpecVolumesValue) MarshalJSON() ([]byte, error) {
	toMarshal := map[string]any{}
	if !v.Cache.IsNull() && !v.Cache.IsUnknown() {
		toMarshal["cache"] = v.Cache
	}

	return json.Marshal(toMarshal)
}

func (v *SpecVolumesValue) UnmarshalJSON(data []byte) error {
	type JsonSpecVolumesValue SpecVolumesValue

	var tmp JsonSpecVolumesValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.Cache = tmp.Cache
	v.Container = tmp.Container
	v.DataStore = tmp.DataStore
	v.Id = tmp.Id
	v.MountPath = tmp.MountPath
	v.Permission = tmp.Permission
	v.Prefix = tmp.Prefix
	v.PrivateSwift = tmp.PrivateSwift
	v.PublicGit = tmp.PublicGit
	v.PublicSwift = tmp.PublicSwift
	v.Region = tmp.Region
	v.Standalone = tmp.Standalone
	v.TargetDataStore = tmp.TargetDataStore
	v.TargetPrivateSwift = tmp.TargetPrivateSwift
	v.VolumeSource = tmp.VolumeSource
	v.VolumeTarget = tmp.VolumeTarget

	v.state = attr.ValueStateKnown

	return nil
}

func (v *SpecVolumesValue) MergeWith(other *SpecVolumesValue) {

	if (v.Cache.IsUnknown() || v.Cache.IsNull()) && !other.Cache.IsUnknown() {
		v.Cache = other.Cache
	}

	if (v.Container.IsUnknown() || v.Container.IsNull()) && !other.Container.IsUnknown() {
		v.Container = other.Container
	}

	if v.DataStore.IsUnknown() && !other.DataStore.IsUnknown() {
		v.DataStore = other.DataStore
	} else if !other.DataStore.IsUnknown() {
		v.DataStore.MergeWith(&other.DataStore)
	}

	if (v.Id.IsUnknown() || v.Id.IsNull()) && !other.Id.IsUnknown() {
		v.Id = other.Id
	}

	if (v.MountPath.IsUnknown() || v.MountPath.IsNull()) && !other.MountPath.IsUnknown() {
		v.MountPath = other.MountPath
	}

	if (v.Permission.IsUnknown() || v.Permission.IsNull()) && !other.Permission.IsUnknown() {
		v.Permission = other.Permission
	}

	if (v.Prefix.IsUnknown() || v.Prefix.IsNull()) && !other.Prefix.IsUnknown() {
		v.Prefix = other.Prefix
	}

	if v.PrivateSwift.IsUnknown() && !other.PrivateSwift.IsUnknown() {
		v.PrivateSwift = other.PrivateSwift
	} else if !other.PrivateSwift.IsUnknown() {
		v.PrivateSwift.MergeWith(&other.PrivateSwift)
	}

	if v.PublicGit.IsUnknown() && !other.PublicGit.IsUnknown() {
		v.PublicGit = other.PublicGit
	} else if !other.PublicGit.IsUnknown() {
		v.PublicGit.MergeWith(&other.PublicGit)
	}

	if v.PublicSwift.IsUnknown() && !other.PublicSwift.IsUnknown() {
		v.PublicSwift = other.PublicSwift
	} else if !other.PublicSwift.IsUnknown() {
		v.PublicSwift.MergeWith(&other.PublicSwift)
	}

	if (v.Region.IsUnknown() || v.Region.IsNull()) && !other.Region.IsUnknown() {
		v.Region = other.Region
	}

	if v.Standalone.IsUnknown() && !other.Standalone.IsUnknown() {
		v.Standalone = other.Standalone
	} else if !other.Standalone.IsUnknown() {
		v.Standalone.MergeWith(&other.Standalone)
	}

	if v.TargetDataStore.IsUnknown() && !other.TargetDataStore.IsUnknown() {
		v.TargetDataStore = other.TargetDataStore
	} else if !other.TargetDataStore.IsUnknown() {
		v.TargetDataStore.MergeWith(&other.TargetDataStore)
	}

	if v.TargetPrivateSwift.IsUnknown() && !other.TargetPrivateSwift.IsUnknown() {
		v.TargetPrivateSwift = other.TargetPrivateSwift
	} else if !other.TargetPrivateSwift.IsUnknown() {
		v.TargetPrivateSwift.MergeWith(&other.TargetPrivateSwift)
	}

	if v.VolumeSource.IsUnknown() && !other.VolumeSource.IsUnknown() {
		v.VolumeSource = other.VolumeSource
	} else if !other.VolumeSource.IsUnknown() {
		v.VolumeSource.MergeWith(&other.VolumeSource)
	}

	if v.VolumeTarget.IsUnknown() && !other.VolumeTarget.IsUnknown() {
		v.VolumeTarget = other.VolumeTarget
	} else if !other.VolumeTarget.IsUnknown() {
		v.VolumeTarget.MergeWith(&other.VolumeTarget)
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v SpecVolumesValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"cache":              v.Cache,
		"container":          v.Container,
		"dataStore":          v.DataStore,
		"id":                 v.Id,
		"mountPath":          v.MountPath,
		"permission":         v.Permission,
		"prefix":             v.Prefix,
		"privateSwift":       v.PrivateSwift,
		"publicGit":          v.PublicGit,
		"publicSwift":        v.PublicSwift,
		"region":             v.Region,
		"standalone":         v.Standalone,
		"targetDataStore":    v.TargetDataStore,
		"targetPrivateSwift": v.TargetPrivateSwift,
		"volumeSource":       v.VolumeSource,
		"volumeTarget":       v.VolumeTarget,
	}
}
func (v SpecVolumesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 16)

	var val tftypes.Value
	var err error

	attrTypes["cache"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["container"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["data_store"] = basetypes.ObjectType{
		AttrTypes: SpecVolumesDataStoreValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["mount_path"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["permission"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["prefix"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["private_swift"] = basetypes.ObjectType{
		AttrTypes: SpecVolumesPrivateSwiftValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["public_git"] = basetypes.ObjectType{
		AttrTypes: SpecVolumesPublicGitValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["public_swift"] = basetypes.ObjectType{
		AttrTypes: SpecVolumesPublicSwiftValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["region"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["standalone"] = basetypes.ObjectType{
		AttrTypes: SpecVolumesStandaloneValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["target_data_store"] = basetypes.ObjectType{
		AttrTypes: SpecVolumesTargetDataStoreValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["target_private_swift"] = basetypes.ObjectType{
		AttrTypes: SpecVolumesTargetPrivateSwiftValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["volume_source"] = basetypes.ObjectType{
		AttrTypes: SpecVolumesVolumeSourceValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["volume_target"] = basetypes.ObjectType{
		AttrTypes: SpecVolumesVolumeTargetValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 16)

		val, err = v.Cache.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cache"] = val

		val, err = v.Container.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["container"] = val

		val, err = v.DataStore.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["data_store"] = val

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.MountPath.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mount_path"] = val

		val, err = v.Permission.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["permission"] = val

		val, err = v.Prefix.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["prefix"] = val

		val, err = v.PrivateSwift.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["private_swift"] = val

		val, err = v.PublicGit.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["public_git"] = val

		val, err = v.PublicSwift.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["public_swift"] = val

		val, err = v.Region.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["region"] = val

		val, err = v.Standalone.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["standalone"] = val

		val, err = v.TargetDataStore.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["target_data_store"] = val

		val, err = v.TargetPrivateSwift.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["target_private_swift"] = val

		val, err = v.VolumeSource.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["volume_source"] = val

		val, err = v.VolumeTarget.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["volume_target"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SpecVolumesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SpecVolumesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SpecVolumesValue) String() string {
	return "SpecVolumesValue"
}

func (v SpecVolumesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"cache":     ovhtypes.TfBoolType{},
			"container": ovhtypes.TfStringType{},
			"data_store": SpecVolumesDataStoreType{
				basetypes.ObjectType{
					AttrTypes: SpecVolumesDataStoreValue{}.AttributeTypes(ctx),
				},
			},
			"id":         ovhtypes.TfStringType{},
			"mount_path": ovhtypes.TfStringType{},
			"permission": ovhtypes.TfStringType{},
			"prefix":     ovhtypes.TfStringType{},
			"private_swift": SpecVolumesPrivateSwiftType{
				basetypes.ObjectType{
					AttrTypes: SpecVolumesPrivateSwiftValue{}.AttributeTypes(ctx),
				},
			},
			"public_git": SpecVolumesPublicGitType{
				basetypes.ObjectType{
					AttrTypes: SpecVolumesPublicGitValue{}.AttributeTypes(ctx),
				},
			},
			"public_swift": SpecVolumesPublicSwiftType{
				basetypes.ObjectType{
					AttrTypes: SpecVolumesPublicSwiftValue{}.AttributeTypes(ctx),
				},
			},
			"region": ovhtypes.TfStringType{},
			"standalone": SpecVolumesStandaloneType{
				basetypes.ObjectType{
					AttrTypes: SpecVolumesStandaloneValue{}.AttributeTypes(ctx),
				},
			},
			"target_data_store": SpecVolumesTargetDataStoreType{
				basetypes.ObjectType{
					AttrTypes: SpecVolumesTargetDataStoreValue{}.AttributeTypes(ctx),
				},
			},
			"target_private_swift": SpecVolumesTargetPrivateSwiftType{
				basetypes.ObjectType{
					AttrTypes: SpecVolumesTargetPrivateSwiftValue{}.AttributeTypes(ctx),
				},
			},
			"volume_source": SpecVolumesVolumeSourceType{
				basetypes.ObjectType{
					AttrTypes: SpecVolumesVolumeSourceValue{}.AttributeTypes(ctx),
				},
			},
			"volume_target": SpecVolumesVolumeTargetType{
				basetypes.ObjectType{
					AttrTypes: SpecVolumesVolumeTargetValue{}.AttributeTypes(ctx),
				},
			},
		},
		map[string]attr.Value{
			"cache":                v.Cache,
			"container":            v.Container,
			"data_store":           v.DataStore,
			"id":                   v.Id,
			"mount_path":           v.MountPath,
			"permission":           v.Permission,
			"prefix":               v.Prefix,
			"private_swift":        v.PrivateSwift,
			"public_git":           v.PublicGit,
			"public_swift":         v.PublicSwift,
			"region":               v.Region,
			"standalone":           v.Standalone,
			"target_data_store":    v.TargetDataStore,
			"target_private_swift": v.TargetPrivateSwift,
			"volume_source":        v.VolumeSource,
			"volume_target":        v.VolumeTarget,
		})

	return objVal, diags
}

func (v SpecVolumesValue) Equal(o attr.Value) bool {
	other, ok := o.(SpecVolumesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Cache.Equal(other.Cache) {
		return false
	}

	if !v.Container.Equal(other.Container) {
		return false
	}

	if !v.DataStore.Equal(other.DataStore) {
		return false
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.MountPath.Equal(other.MountPath) {
		return false
	}

	if !v.Permission.Equal(other.Permission) {
		return false
	}

	if !v.Prefix.Equal(other.Prefix) {
		return false
	}

	if !v.PrivateSwift.Equal(other.PrivateSwift) {
		return false
	}

	if !v.PublicGit.Equal(other.PublicGit) {
		return false
	}

	if !v.PublicSwift.Equal(other.PublicSwift) {
		return false
	}

	if !v.Region.Equal(other.Region) {
		return false
	}

	if !v.Standalone.Equal(other.Standalone) {
		return false
	}

	if !v.TargetDataStore.Equal(other.TargetDataStore) {
		return false
	}

	if !v.TargetPrivateSwift.Equal(other.TargetPrivateSwift) {
		return false
	}

	if !v.VolumeSource.Equal(other.VolumeSource) {
		return false
	}

	if !v.VolumeTarget.Equal(other.VolumeTarget) {
		return false
	}

	return true
}

func (v SpecVolumesValue) Type(ctx context.Context) attr.Type {
	return SpecVolumesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SpecVolumesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"cache":                ovhtypes.TfBoolType{},
		"container":            ovhtypes.TfStringType{},
		"data_store":           SpecVolumesDataStoreValue{}.Type(ctx),
		"id":                   ovhtypes.TfStringType{},
		"mount_path":           ovhtypes.TfStringType{},
		"permission":           ovhtypes.TfStringType{},
		"prefix":               ovhtypes.TfStringType{},
		"private_swift":        SpecVolumesPrivateSwiftValue{}.Type(ctx),
		"public_git":           SpecVolumesPublicGitValue{}.Type(ctx),
		"public_swift":         SpecVolumesPublicSwiftValue{}.Type(ctx),
		"region":               ovhtypes.TfStringType{},
		"standalone":           SpecVolumesStandaloneValue{}.Type(ctx),
		"target_data_store":    SpecVolumesTargetDataStoreValue{}.Type(ctx),
		"target_private_swift": SpecVolumesTargetPrivateSwiftValue{}.Type(ctx),
		"volume_source":        SpecVolumesVolumeSourceValue{}.Type(ctx),
		"volume_target":        SpecVolumesVolumeTargetValue{}.Type(ctx),
	}
}

var _ basetypes.ObjectTypable = SpecVolumesDataStoreType{}

type SpecVolumesDataStoreType struct {
	basetypes.ObjectType
}

func (t SpecVolumesDataStoreType) Equal(o attr.Type) bool {
	other, ok := o.(SpecVolumesDataStoreType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SpecVolumesDataStoreType) String() string {
	return "SpecVolumesDataStoreType"
}

func (t SpecVolumesDataStoreType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	aliasAttribute, ok := attributes["alias"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`alias is missing from object`)

		return nil, diags
	}

	aliasVal, ok := aliasAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`alias expected to be ovhtypes.TfStringValue, was: %T`, aliasAttribute))
	}

	archiveAttribute, ok := attributes["archive"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`archive is missing from object`)

		return nil, diags
	}

	archiveVal, ok := archiveAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`archive expected to be ovhtypes.TfStringValue, was: %T`, archiveAttribute))
	}

	containerAttribute, ok := attributes["container"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`container is missing from object`)

		return nil, diags
	}

	containerVal, ok := containerAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`container expected to be ovhtypes.TfStringValue, was: %T`, containerAttribute))
	}

	internalAttribute, ok := attributes["internal"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`internal is missing from object`)

		return nil, diags
	}

	internalVal, ok := internalAttribute.(ovhtypes.TfBoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`internal expected to be ovhtypes.TfBoolValue, was: %T`, internalAttribute))
	}

	prefixAttribute, ok := attributes["prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix is missing from object`)

		return nil, diags
	}

	prefixVal, ok := prefixAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix expected to be ovhtypes.TfStringValue, was: %T`, prefixAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SpecVolumesDataStoreValue{
		Alias:     aliasVal,
		Archive:   archiveVal,
		Container: containerVal,
		Internal:  internalVal,
		Prefix:    prefixVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewSpecVolumesDataStoreValueNull() SpecVolumesDataStoreValue {
	return SpecVolumesDataStoreValue{
		state: attr.ValueStateNull,
	}
}

func NewSpecVolumesDataStoreValueUnknown() SpecVolumesDataStoreValue {
	return SpecVolumesDataStoreValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSpecVolumesDataStoreValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SpecVolumesDataStoreValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SpecVolumesDataStoreValue Attribute Value",
				"While creating a SpecVolumesDataStoreValue value, a missing attribute value was detected. "+
					"A SpecVolumesDataStoreValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpecVolumesDataStoreValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SpecVolumesDataStoreValue Attribute Type",
				"While creating a SpecVolumesDataStoreValue value, an invalid attribute value was detected. "+
					"A SpecVolumesDataStoreValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpecVolumesDataStoreValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SpecVolumesDataStoreValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SpecVolumesDataStoreValue Attribute Value",
				"While creating a SpecVolumesDataStoreValue value, an extra attribute value was detected. "+
					"A SpecVolumesDataStoreValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SpecVolumesDataStoreValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSpecVolumesDataStoreValueUnknown(), diags
	}

	aliasAttribute, ok := attributes["alias"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`alias is missing from object`)

		return NewSpecVolumesDataStoreValueUnknown(), diags
	}

	aliasVal, ok := aliasAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`alias expected to be ovhtypes.TfStringValue, was: %T`, aliasAttribute))
	}

	archiveAttribute, ok := attributes["archive"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`archive is missing from object`)

		return NewSpecVolumesDataStoreValueUnknown(), diags
	}

	archiveVal, ok := archiveAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`archive expected to be ovhtypes.TfStringValue, was: %T`, archiveAttribute))
	}

	containerAttribute, ok := attributes["container"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`container is missing from object`)

		return NewSpecVolumesDataStoreValueUnknown(), diags
	}

	containerVal, ok := containerAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`container expected to be ovhtypes.TfStringValue, was: %T`, containerAttribute))
	}

	internalAttribute, ok := attributes["internal"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`internal is missing from object`)

		return NewSpecVolumesDataStoreValueUnknown(), diags
	}

	internalVal, ok := internalAttribute.(ovhtypes.TfBoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`internal expected to be ovhtypes.TfBoolValue, was: %T`, internalAttribute))
	}

	prefixAttribute, ok := attributes["prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix is missing from object`)

		return NewSpecVolumesDataStoreValueUnknown(), diags
	}

	prefixVal, ok := prefixAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix expected to be ovhtypes.TfStringValue, was: %T`, prefixAttribute))
	}

	if diags.HasError() {
		return NewSpecVolumesDataStoreValueUnknown(), diags
	}

	return SpecVolumesDataStoreValue{
		Alias:     aliasVal,
		Archive:   archiveVal,
		Container: containerVal,
		Internal:  internalVal,
		Prefix:    prefixVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewSpecVolumesDataStoreValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SpecVolumesDataStoreValue {
	object, diags := NewSpecVolumesDataStoreValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSpecVolumesDataStoreValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SpecVolumesDataStoreType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSpecVolumesDataStoreValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSpecVolumesDataStoreValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSpecVolumesDataStoreValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSpecVolumesDataStoreValueMust(SpecVolumesDataStoreValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SpecVolumesDataStoreType) ValueType(ctx context.Context) attr.Value {
	return SpecVolumesDataStoreValue{}
}

var _ basetypes.ObjectValuable = SpecVolumesDataStoreValue{}

type SpecVolumesDataStoreValue struct {
	Alias     ovhtypes.TfStringValue `tfsdk:"alias" json:"alias"`
	Archive   ovhtypes.TfStringValue `tfsdk:"archive" json:"archive"`
	Container ovhtypes.TfStringValue `tfsdk:"container" json:"container"`
	Internal  ovhtypes.TfBoolValue   `tfsdk:"internal" json:"internal"`
	Prefix    ovhtypes.TfStringValue `tfsdk:"prefix" json:"prefix"`
	state     attr.ValueState
}

func (v SpecVolumesDataStoreValue) ToCreate() *SpecVolumesDataStoreValue {
	res := &SpecVolumesDataStoreValue{}

	if !v.Internal.IsNull() {
		res.Internal = v.Internal
	}

	res.state = attr.ValueStateKnown

	return res
}

func (v SpecVolumesDataStoreValue) MarshalJSON() ([]byte, error) {
	toMarshal := map[string]any{}
	if !v.Internal.IsNull() && !v.Internal.IsUnknown() {
		toMarshal["internal"] = v.Internal
	}

	return json.Marshal(toMarshal)
}

func (v *SpecVolumesDataStoreValue) UnmarshalJSON(data []byte) error {
	type JsonSpecVolumesDataStoreValue SpecVolumesDataStoreValue

	var tmp JsonSpecVolumesDataStoreValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.Alias = tmp.Alias
	v.Archive = tmp.Archive
	v.Container = tmp.Container
	v.Internal = tmp.Internal
	v.Prefix = tmp.Prefix

	v.state = attr.ValueStateKnown

	return nil
}

func (v *SpecVolumesDataStoreValue) MergeWith(other *SpecVolumesDataStoreValue) {

	if (v.Alias.IsUnknown() || v.Alias.IsNull()) && !other.Alias.IsUnknown() {
		v.Alias = other.Alias
	}

	if (v.Archive.IsUnknown() || v.Archive.IsNull()) && !other.Archive.IsUnknown() {
		v.Archive = other.Archive
	}

	if (v.Container.IsUnknown() || v.Container.IsNull()) && !other.Container.IsUnknown() {
		v.Container = other.Container
	}

	if (v.Internal.IsUnknown() || v.Internal.IsNull()) && !other.Internal.IsUnknown() {
		v.Internal = other.Internal
	}

	if (v.Prefix.IsUnknown() || v.Prefix.IsNull()) && !other.Prefix.IsUnknown() {
		v.Prefix = other.Prefix
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v SpecVolumesDataStoreValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"alias":     v.Alias,
		"archive":   v.Archive,
		"container": v.Container,
		"internal":  v.Internal,
		"prefix":    v.Prefix,
	}
}
func (v SpecVolumesDataStoreValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["alias"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["archive"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["container"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["internal"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["prefix"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.Alias.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["alias"] = val

		val, err = v.Archive.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["archive"] = val

		val, err = v.Container.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["container"] = val

		val, err = v.Internal.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["internal"] = val

		val, err = v.Prefix.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["prefix"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SpecVolumesDataStoreValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SpecVolumesDataStoreValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SpecVolumesDataStoreValue) String() string {
	return "SpecVolumesDataStoreValue"
}

func (v SpecVolumesDataStoreValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"alias":     ovhtypes.TfStringType{},
			"archive":   ovhtypes.TfStringType{},
			"container": ovhtypes.TfStringType{},
			"internal":  ovhtypes.TfBoolType{},
			"prefix":    ovhtypes.TfStringType{},
		},
		map[string]attr.Value{
			"alias":     v.Alias,
			"archive":   v.Archive,
			"container": v.Container,
			"internal":  v.Internal,
			"prefix":    v.Prefix,
		})

	return objVal, diags
}

func (v SpecVolumesDataStoreValue) Equal(o attr.Value) bool {
	other, ok := o.(SpecVolumesDataStoreValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Alias.Equal(other.Alias) {
		return false
	}

	if !v.Archive.Equal(other.Archive) {
		return false
	}

	if !v.Container.Equal(other.Container) {
		return false
	}

	if !v.Internal.Equal(other.Internal) {
		return false
	}

	if !v.Prefix.Equal(other.Prefix) {
		return false
	}

	return true
}

func (v SpecVolumesDataStoreValue) Type(ctx context.Context) attr.Type {
	return SpecVolumesDataStoreType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SpecVolumesDataStoreValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"alias":     ovhtypes.TfStringType{},
		"archive":   ovhtypes.TfStringType{},
		"container": ovhtypes.TfStringType{},
		"internal":  ovhtypes.TfBoolType{},
		"prefix":    ovhtypes.TfStringType{},
	}
}

var _ basetypes.ObjectTypable = SpecVolumesPrivateSwiftType{}

type SpecVolumesPrivateSwiftType struct {
	basetypes.ObjectType
}

func (t SpecVolumesPrivateSwiftType) Equal(o attr.Type) bool {
	other, ok := o.(SpecVolumesPrivateSwiftType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SpecVolumesPrivateSwiftType) String() string {
	return "SpecVolumesPrivateSwiftType"
}

func (t SpecVolumesPrivateSwiftType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	archiveAttribute, ok := attributes["archive"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`archive is missing from object`)

		return nil, diags
	}

	archiveVal, ok := archiveAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`archive expected to be ovhtypes.TfStringValue, was: %T`, archiveAttribute))
	}

	containerAttribute, ok := attributes["container"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`container is missing from object`)

		return nil, diags
	}

	containerVal, ok := containerAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`container expected to be ovhtypes.TfStringValue, was: %T`, containerAttribute))
	}

	internalAttribute, ok := attributes["internal"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`internal is missing from object`)

		return nil, diags
	}

	internalVal, ok := internalAttribute.(ovhtypes.TfBoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`internal expected to be ovhtypes.TfBoolValue, was: %T`, internalAttribute))
	}

	prefixAttribute, ok := attributes["prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix is missing from object`)

		return nil, diags
	}

	prefixVal, ok := prefixAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix expected to be ovhtypes.TfStringValue, was: %T`, prefixAttribute))
	}

	regionAttribute, ok := attributes["region"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`region is missing from object`)

		return nil, diags
	}

	regionVal, ok := regionAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`region expected to be ovhtypes.TfStringValue, was: %T`, regionAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SpecVolumesPrivateSwiftValue{
		Archive:   archiveVal,
		Container: containerVal,
		Internal:  internalVal,
		Prefix:    prefixVal,
		Region:    regionVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewSpecVolumesPrivateSwiftValueNull() SpecVolumesPrivateSwiftValue {
	return SpecVolumesPrivateSwiftValue{
		state: attr.ValueStateNull,
	}
}

func NewSpecVolumesPrivateSwiftValueUnknown() SpecVolumesPrivateSwiftValue {
	return SpecVolumesPrivateSwiftValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSpecVolumesPrivateSwiftValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SpecVolumesPrivateSwiftValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SpecVolumesPrivateSwiftValue Attribute Value",
				"While creating a SpecVolumesPrivateSwiftValue value, a missing attribute value was detected. "+
					"A SpecVolumesPrivateSwiftValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpecVolumesPrivateSwiftValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SpecVolumesPrivateSwiftValue Attribute Type",
				"While creating a SpecVolumesPrivateSwiftValue value, an invalid attribute value was detected. "+
					"A SpecVolumesPrivateSwiftValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpecVolumesPrivateSwiftValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SpecVolumesPrivateSwiftValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SpecVolumesPrivateSwiftValue Attribute Value",
				"While creating a SpecVolumesPrivateSwiftValue value, an extra attribute value was detected. "+
					"A SpecVolumesPrivateSwiftValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SpecVolumesPrivateSwiftValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSpecVolumesPrivateSwiftValueUnknown(), diags
	}

	archiveAttribute, ok := attributes["archive"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`archive is missing from object`)

		return NewSpecVolumesPrivateSwiftValueUnknown(), diags
	}

	archiveVal, ok := archiveAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`archive expected to be ovhtypes.TfStringValue, was: %T`, archiveAttribute))
	}

	containerAttribute, ok := attributes["container"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`container is missing from object`)

		return NewSpecVolumesPrivateSwiftValueUnknown(), diags
	}

	containerVal, ok := containerAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`container expected to be ovhtypes.TfStringValue, was: %T`, containerAttribute))
	}

	internalAttribute, ok := attributes["internal"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`internal is missing from object`)

		return NewSpecVolumesPrivateSwiftValueUnknown(), diags
	}

	internalVal, ok := internalAttribute.(ovhtypes.TfBoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`internal expected to be ovhtypes.TfBoolValue, was: %T`, internalAttribute))
	}

	prefixAttribute, ok := attributes["prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix is missing from object`)

		return NewSpecVolumesPrivateSwiftValueUnknown(), diags
	}

	prefixVal, ok := prefixAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix expected to be ovhtypes.TfStringValue, was: %T`, prefixAttribute))
	}

	regionAttribute, ok := attributes["region"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`region is missing from object`)

		return NewSpecVolumesPrivateSwiftValueUnknown(), diags
	}

	regionVal, ok := regionAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`region expected to be ovhtypes.TfStringValue, was: %T`, regionAttribute))
	}

	if diags.HasError() {
		return NewSpecVolumesPrivateSwiftValueUnknown(), diags
	}

	return SpecVolumesPrivateSwiftValue{
		Archive:   archiveVal,
		Container: containerVal,
		Internal:  internalVal,
		Prefix:    prefixVal,
		Region:    regionVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewSpecVolumesPrivateSwiftValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SpecVolumesPrivateSwiftValue {
	object, diags := NewSpecVolumesPrivateSwiftValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSpecVolumesPrivateSwiftValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SpecVolumesPrivateSwiftType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSpecVolumesPrivateSwiftValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSpecVolumesPrivateSwiftValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSpecVolumesPrivateSwiftValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSpecVolumesPrivateSwiftValueMust(SpecVolumesPrivateSwiftValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SpecVolumesPrivateSwiftType) ValueType(ctx context.Context) attr.Value {
	return SpecVolumesPrivateSwiftValue{}
}

var _ basetypes.ObjectValuable = SpecVolumesPrivateSwiftValue{}

type SpecVolumesPrivateSwiftValue struct {
	Archive   ovhtypes.TfStringValue `tfsdk:"archive" json:"archive"`
	Container ovhtypes.TfStringValue `tfsdk:"container" json:"container"`
	Internal  ovhtypes.TfBoolValue   `tfsdk:"internal" json:"internal"`
	Prefix    ovhtypes.TfStringValue `tfsdk:"prefix" json:"prefix"`
	Region    ovhtypes.TfStringValue `tfsdk:"region" json:"region"`
	state     attr.ValueState
}

func (v SpecVolumesPrivateSwiftValue) ToCreate() *SpecVolumesPrivateSwiftValue {
	res := &SpecVolumesPrivateSwiftValue{}

	if !v.Internal.IsNull() {
		res.Internal = v.Internal
	}

	res.state = attr.ValueStateKnown

	return res
}

func (v SpecVolumesPrivateSwiftValue) MarshalJSON() ([]byte, error) {
	toMarshal := map[string]any{}
	if !v.Internal.IsNull() && !v.Internal.IsUnknown() {
		toMarshal["internal"] = v.Internal
	}

	return json.Marshal(toMarshal)
}

func (v *SpecVolumesPrivateSwiftValue) UnmarshalJSON(data []byte) error {
	type JsonSpecVolumesPrivateSwiftValue SpecVolumesPrivateSwiftValue

	var tmp JsonSpecVolumesPrivateSwiftValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.Archive = tmp.Archive
	v.Container = tmp.Container
	v.Internal = tmp.Internal
	v.Prefix = tmp.Prefix
	v.Region = tmp.Region

	v.state = attr.ValueStateKnown

	return nil
}

func (v *SpecVolumesPrivateSwiftValue) MergeWith(other *SpecVolumesPrivateSwiftValue) {

	if (v.Archive.IsUnknown() || v.Archive.IsNull()) && !other.Archive.IsUnknown() {
		v.Archive = other.Archive
	}

	if (v.Container.IsUnknown() || v.Container.IsNull()) && !other.Container.IsUnknown() {
		v.Container = other.Container
	}

	if (v.Internal.IsUnknown() || v.Internal.IsNull()) && !other.Internal.IsUnknown() {
		v.Internal = other.Internal
	}

	if (v.Prefix.IsUnknown() || v.Prefix.IsNull()) && !other.Prefix.IsUnknown() {
		v.Prefix = other.Prefix
	}

	if (v.Region.IsUnknown() || v.Region.IsNull()) && !other.Region.IsUnknown() {
		v.Region = other.Region
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v SpecVolumesPrivateSwiftValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"archive":   v.Archive,
		"container": v.Container,
		"internal":  v.Internal,
		"prefix":    v.Prefix,
		"region":    v.Region,
	}
}
func (v SpecVolumesPrivateSwiftValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["archive"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["container"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["internal"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["prefix"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["region"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.Archive.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["archive"] = val

		val, err = v.Container.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["container"] = val

		val, err = v.Internal.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["internal"] = val

		val, err = v.Prefix.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["prefix"] = val

		val, err = v.Region.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["region"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SpecVolumesPrivateSwiftValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SpecVolumesPrivateSwiftValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SpecVolumesPrivateSwiftValue) String() string {
	return "SpecVolumesPrivateSwiftValue"
}

func (v SpecVolumesPrivateSwiftValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"archive":   ovhtypes.TfStringType{},
			"container": ovhtypes.TfStringType{},
			"internal":  ovhtypes.TfBoolType{},
			"prefix":    ovhtypes.TfStringType{},
			"region":    ovhtypes.TfStringType{},
		},
		map[string]attr.Value{
			"archive":   v.Archive,
			"container": v.Container,
			"internal":  v.Internal,
			"prefix":    v.Prefix,
			"region":    v.Region,
		})

	return objVal, diags
}

func (v SpecVolumesPrivateSwiftValue) Equal(o attr.Value) bool {
	other, ok := o.(SpecVolumesPrivateSwiftValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Archive.Equal(other.Archive) {
		return false
	}

	if !v.Container.Equal(other.Container) {
		return false
	}

	if !v.Internal.Equal(other.Internal) {
		return false
	}

	if !v.Prefix.Equal(other.Prefix) {
		return false
	}

	if !v.Region.Equal(other.Region) {
		return false
	}

	return true
}

func (v SpecVolumesPrivateSwiftValue) Type(ctx context.Context) attr.Type {
	return SpecVolumesPrivateSwiftType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SpecVolumesPrivateSwiftValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"archive":   ovhtypes.TfStringType{},
		"container": ovhtypes.TfStringType{},
		"internal":  ovhtypes.TfBoolType{},
		"prefix":    ovhtypes.TfStringType{},
		"region":    ovhtypes.TfStringType{},
	}
}

var _ basetypes.ObjectTypable = SpecVolumesPublicGitType{}

type SpecVolumesPublicGitType struct {
	basetypes.ObjectType
}

func (t SpecVolumesPublicGitType) Equal(o attr.Type) bool {
	other, ok := o.(SpecVolumesPublicGitType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SpecVolumesPublicGitType) String() string {
	return "SpecVolumesPublicGitType"
}

func (t SpecVolumesPublicGitType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return nil, diags
	}

	urlVal, ok := urlAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be ovhtypes.TfStringValue, was: %T`, urlAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SpecVolumesPublicGitValue{
		Url:   urlVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewSpecVolumesPublicGitValueNull() SpecVolumesPublicGitValue {
	return SpecVolumesPublicGitValue{
		state: attr.ValueStateNull,
	}
}

func NewSpecVolumesPublicGitValueUnknown() SpecVolumesPublicGitValue {
	return SpecVolumesPublicGitValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSpecVolumesPublicGitValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SpecVolumesPublicGitValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SpecVolumesPublicGitValue Attribute Value",
				"While creating a SpecVolumesPublicGitValue value, a missing attribute value was detected. "+
					"A SpecVolumesPublicGitValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpecVolumesPublicGitValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SpecVolumesPublicGitValue Attribute Type",
				"While creating a SpecVolumesPublicGitValue value, an invalid attribute value was detected. "+
					"A SpecVolumesPublicGitValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpecVolumesPublicGitValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SpecVolumesPublicGitValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SpecVolumesPublicGitValue Attribute Value",
				"While creating a SpecVolumesPublicGitValue value, an extra attribute value was detected. "+
					"A SpecVolumesPublicGitValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SpecVolumesPublicGitValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSpecVolumesPublicGitValueUnknown(), diags
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return NewSpecVolumesPublicGitValueUnknown(), diags
	}

	urlVal, ok := urlAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be ovhtypes.TfStringValue, was: %T`, urlAttribute))
	}

	if diags.HasError() {
		return NewSpecVolumesPublicGitValueUnknown(), diags
	}

	return SpecVolumesPublicGitValue{
		Url:   urlVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewSpecVolumesPublicGitValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SpecVolumesPublicGitValue {
	object, diags := NewSpecVolumesPublicGitValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSpecVolumesPublicGitValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SpecVolumesPublicGitType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSpecVolumesPublicGitValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSpecVolumesPublicGitValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSpecVolumesPublicGitValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSpecVolumesPublicGitValueMust(SpecVolumesPublicGitValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SpecVolumesPublicGitType) ValueType(ctx context.Context) attr.Value {
	return SpecVolumesPublicGitValue{}
}

var _ basetypes.ObjectValuable = SpecVolumesPublicGitValue{}

type SpecVolumesPublicGitValue struct {
	Url   ovhtypes.TfStringValue `tfsdk:"url" json:"url"`
	state attr.ValueState
}

func (v *SpecVolumesPublicGitValue) UnmarshalJSON(data []byte) error {
	type JsonSpecVolumesPublicGitValue SpecVolumesPublicGitValue

	var tmp JsonSpecVolumesPublicGitValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.Url = tmp.Url

	v.state = attr.ValueStateKnown

	return nil
}

func (v *SpecVolumesPublicGitValue) MergeWith(other *SpecVolumesPublicGitValue) {

	if (v.Url.IsUnknown() || v.Url.IsNull()) && !other.Url.IsUnknown() {
		v.Url = other.Url
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v SpecVolumesPublicGitValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"url": v.Url,
	}
}
func (v SpecVolumesPublicGitValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["url"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Url.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["url"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SpecVolumesPublicGitValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SpecVolumesPublicGitValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SpecVolumesPublicGitValue) String() string {
	return "SpecVolumesPublicGitValue"
}

func (v SpecVolumesPublicGitValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"url": ovhtypes.TfStringType{},
		},
		map[string]attr.Value{
			"url": v.Url,
		})

	return objVal, diags
}

func (v SpecVolumesPublicGitValue) Equal(o attr.Value) bool {
	other, ok := o.(SpecVolumesPublicGitValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Url.Equal(other.Url) {
		return false
	}

	return true
}

func (v SpecVolumesPublicGitValue) Type(ctx context.Context) attr.Type {
	return SpecVolumesPublicGitType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SpecVolumesPublicGitValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"url": ovhtypes.TfStringType{},
	}
}

var _ basetypes.ObjectTypable = SpecVolumesPublicSwiftType{}

type SpecVolumesPublicSwiftType struct {
	basetypes.ObjectType
}

func (t SpecVolumesPublicSwiftType) Equal(o attr.Type) bool {
	other, ok := o.(SpecVolumesPublicSwiftType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SpecVolumesPublicSwiftType) String() string {
	return "SpecVolumesPublicSwiftType"
}

func (t SpecVolumesPublicSwiftType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return nil, diags
	}

	urlVal, ok := urlAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be ovhtypes.TfStringValue, was: %T`, urlAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SpecVolumesPublicSwiftValue{
		Url:   urlVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewSpecVolumesPublicSwiftValueNull() SpecVolumesPublicSwiftValue {
	return SpecVolumesPublicSwiftValue{
		state: attr.ValueStateNull,
	}
}

func NewSpecVolumesPublicSwiftValueUnknown() SpecVolumesPublicSwiftValue {
	return SpecVolumesPublicSwiftValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSpecVolumesPublicSwiftValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SpecVolumesPublicSwiftValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SpecVolumesPublicSwiftValue Attribute Value",
				"While creating a SpecVolumesPublicSwiftValue value, a missing attribute value was detected. "+
					"A SpecVolumesPublicSwiftValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpecVolumesPublicSwiftValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SpecVolumesPublicSwiftValue Attribute Type",
				"While creating a SpecVolumesPublicSwiftValue value, an invalid attribute value was detected. "+
					"A SpecVolumesPublicSwiftValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpecVolumesPublicSwiftValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SpecVolumesPublicSwiftValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SpecVolumesPublicSwiftValue Attribute Value",
				"While creating a SpecVolumesPublicSwiftValue value, an extra attribute value was detected. "+
					"A SpecVolumesPublicSwiftValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SpecVolumesPublicSwiftValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSpecVolumesPublicSwiftValueUnknown(), diags
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return NewSpecVolumesPublicSwiftValueUnknown(), diags
	}

	urlVal, ok := urlAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be ovhtypes.TfStringValue, was: %T`, urlAttribute))
	}

	if diags.HasError() {
		return NewSpecVolumesPublicSwiftValueUnknown(), diags
	}

	return SpecVolumesPublicSwiftValue{
		Url:   urlVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewSpecVolumesPublicSwiftValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SpecVolumesPublicSwiftValue {
	object, diags := NewSpecVolumesPublicSwiftValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSpecVolumesPublicSwiftValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SpecVolumesPublicSwiftType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSpecVolumesPublicSwiftValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSpecVolumesPublicSwiftValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSpecVolumesPublicSwiftValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSpecVolumesPublicSwiftValueMust(SpecVolumesPublicSwiftValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SpecVolumesPublicSwiftType) ValueType(ctx context.Context) attr.Value {
	return SpecVolumesPublicSwiftValue{}
}

var _ basetypes.ObjectValuable = SpecVolumesPublicSwiftValue{}

type SpecVolumesPublicSwiftValue struct {
	Url   ovhtypes.TfStringValue `tfsdk:"url" json:"url"`
	state attr.ValueState
}

func (v *SpecVolumesPublicSwiftValue) UnmarshalJSON(data []byte) error {
	type JsonSpecVolumesPublicSwiftValue SpecVolumesPublicSwiftValue

	var tmp JsonSpecVolumesPublicSwiftValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.Url = tmp.Url

	v.state = attr.ValueStateKnown

	return nil
}

func (v *SpecVolumesPublicSwiftValue) MergeWith(other *SpecVolumesPublicSwiftValue) {

	if (v.Url.IsUnknown() || v.Url.IsNull()) && !other.Url.IsUnknown() {
		v.Url = other.Url
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v SpecVolumesPublicSwiftValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"url": v.Url,
	}
}
func (v SpecVolumesPublicSwiftValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["url"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Url.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["url"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SpecVolumesPublicSwiftValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SpecVolumesPublicSwiftValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SpecVolumesPublicSwiftValue) String() string {
	return "SpecVolumesPublicSwiftValue"
}

func (v SpecVolumesPublicSwiftValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"url": ovhtypes.TfStringType{},
		},
		map[string]attr.Value{
			"url": v.Url,
		})

	return objVal, diags
}

func (v SpecVolumesPublicSwiftValue) Equal(o attr.Value) bool {
	other, ok := o.(SpecVolumesPublicSwiftValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Url.Equal(other.Url) {
		return false
	}

	return true
}

func (v SpecVolumesPublicSwiftValue) Type(ctx context.Context) attr.Type {
	return SpecVolumesPublicSwiftType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SpecVolumesPublicSwiftValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"url": ovhtypes.TfStringType{},
	}
}

var _ basetypes.ObjectTypable = SpecVolumesStandaloneType{}

type SpecVolumesStandaloneType struct {
	basetypes.ObjectType
}

func (t SpecVolumesStandaloneType) Equal(o attr.Type) bool {
	other, ok := o.(SpecVolumesStandaloneType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SpecVolumesStandaloneType) String() string {
	return "SpecVolumesStandaloneType"
}

func (t SpecVolumesStandaloneType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be ovhtypes.TfStringValue, was: %T`, nameAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SpecVolumesStandaloneValue{
		Name:  nameVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewSpecVolumesStandaloneValueNull() SpecVolumesStandaloneValue {
	return SpecVolumesStandaloneValue{
		state: attr.ValueStateNull,
	}
}

func NewSpecVolumesStandaloneValueUnknown() SpecVolumesStandaloneValue {
	return SpecVolumesStandaloneValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSpecVolumesStandaloneValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SpecVolumesStandaloneValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SpecVolumesStandaloneValue Attribute Value",
				"While creating a SpecVolumesStandaloneValue value, a missing attribute value was detected. "+
					"A SpecVolumesStandaloneValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpecVolumesStandaloneValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SpecVolumesStandaloneValue Attribute Type",
				"While creating a SpecVolumesStandaloneValue value, an invalid attribute value was detected. "+
					"A SpecVolumesStandaloneValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpecVolumesStandaloneValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SpecVolumesStandaloneValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SpecVolumesStandaloneValue Attribute Value",
				"While creating a SpecVolumesStandaloneValue value, an extra attribute value was detected. "+
					"A SpecVolumesStandaloneValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SpecVolumesStandaloneValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSpecVolumesStandaloneValueUnknown(), diags
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewSpecVolumesStandaloneValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be ovhtypes.TfStringValue, was: %T`, nameAttribute))
	}

	if diags.HasError() {
		return NewSpecVolumesStandaloneValueUnknown(), diags
	}

	return SpecVolumesStandaloneValue{
		Name:  nameVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewSpecVolumesStandaloneValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SpecVolumesStandaloneValue {
	object, diags := NewSpecVolumesStandaloneValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSpecVolumesStandaloneValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SpecVolumesStandaloneType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSpecVolumesStandaloneValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSpecVolumesStandaloneValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSpecVolumesStandaloneValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSpecVolumesStandaloneValueMust(SpecVolumesStandaloneValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SpecVolumesStandaloneType) ValueType(ctx context.Context) attr.Value {
	return SpecVolumesStandaloneValue{}
}

var _ basetypes.ObjectValuable = SpecVolumesStandaloneValue{}

type SpecVolumesStandaloneValue struct {
	Name  ovhtypes.TfStringValue `tfsdk:"name" json:"name"`
	state attr.ValueState
}

func (v *SpecVolumesStandaloneValue) UnmarshalJSON(data []byte) error {
	type JsonSpecVolumesStandaloneValue SpecVolumesStandaloneValue

	var tmp JsonSpecVolumesStandaloneValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.Name = tmp.Name

	v.state = attr.ValueStateKnown

	return nil
}

func (v *SpecVolumesStandaloneValue) MergeWith(other *SpecVolumesStandaloneValue) {

	if (v.Name.IsUnknown() || v.Name.IsNull()) && !other.Name.IsUnknown() {
		v.Name = other.Name
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v SpecVolumesStandaloneValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"name": v.Name,
	}
}
func (v SpecVolumesStandaloneValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SpecVolumesStandaloneValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SpecVolumesStandaloneValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SpecVolumesStandaloneValue) String() string {
	return "SpecVolumesStandaloneValue"
}

func (v SpecVolumesStandaloneValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"name": ovhtypes.TfStringType{},
		},
		map[string]attr.Value{
			"name": v.Name,
		})

	return objVal, diags
}

func (v SpecVolumesStandaloneValue) Equal(o attr.Value) bool {
	other, ok := o.(SpecVolumesStandaloneValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	return true
}

func (v SpecVolumesStandaloneValue) Type(ctx context.Context) attr.Type {
	return SpecVolumesStandaloneType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SpecVolumesStandaloneValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"name": ovhtypes.TfStringType{},
	}
}

var _ basetypes.ObjectTypable = SpecVolumesTargetDataStoreType{}

type SpecVolumesTargetDataStoreType struct {
	basetypes.ObjectType
}

func (t SpecVolumesTargetDataStoreType) Equal(o attr.Type) bool {
	other, ok := o.(SpecVolumesTargetDataStoreType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SpecVolumesTargetDataStoreType) String() string {
	return "SpecVolumesTargetDataStoreType"
}

func (t SpecVolumesTargetDataStoreType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	aliasAttribute, ok := attributes["alias"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`alias is missing from object`)

		return nil, diags
	}

	aliasVal, ok := aliasAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`alias expected to be ovhtypes.TfStringValue, was: %T`, aliasAttribute))
	}

	archiveAttribute, ok := attributes["archive"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`archive is missing from object`)

		return nil, diags
	}

	archiveVal, ok := archiveAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`archive expected to be ovhtypes.TfStringValue, was: %T`, archiveAttribute))
	}

	containerAttribute, ok := attributes["container"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`container is missing from object`)

		return nil, diags
	}

	containerVal, ok := containerAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`container expected to be ovhtypes.TfStringValue, was: %T`, containerAttribute))
	}

	internalAttribute, ok := attributes["internal"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`internal is missing from object`)

		return nil, diags
	}

	internalVal, ok := internalAttribute.(ovhtypes.TfBoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`internal expected to be ovhtypes.TfBoolValue, was: %T`, internalAttribute))
	}

	prefixAttribute, ok := attributes["prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix is missing from object`)

		return nil, diags
	}

	prefixVal, ok := prefixAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix expected to be ovhtypes.TfStringValue, was: %T`, prefixAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SpecVolumesTargetDataStoreValue{
		Alias:     aliasVal,
		Archive:   archiveVal,
		Container: containerVal,
		Internal:  internalVal,
		Prefix:    prefixVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewSpecVolumesTargetDataStoreValueNull() SpecVolumesTargetDataStoreValue {
	return SpecVolumesTargetDataStoreValue{
		state: attr.ValueStateNull,
	}
}

func NewSpecVolumesTargetDataStoreValueUnknown() SpecVolumesTargetDataStoreValue {
	return SpecVolumesTargetDataStoreValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSpecVolumesTargetDataStoreValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SpecVolumesTargetDataStoreValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SpecVolumesTargetDataStoreValue Attribute Value",
				"While creating a SpecVolumesTargetDataStoreValue value, a missing attribute value was detected. "+
					"A SpecVolumesTargetDataStoreValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpecVolumesTargetDataStoreValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SpecVolumesTargetDataStoreValue Attribute Type",
				"While creating a SpecVolumesTargetDataStoreValue value, an invalid attribute value was detected. "+
					"A SpecVolumesTargetDataStoreValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpecVolumesTargetDataStoreValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SpecVolumesTargetDataStoreValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SpecVolumesTargetDataStoreValue Attribute Value",
				"While creating a SpecVolumesTargetDataStoreValue value, an extra attribute value was detected. "+
					"A SpecVolumesTargetDataStoreValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SpecVolumesTargetDataStoreValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSpecVolumesTargetDataStoreValueUnknown(), diags
	}

	aliasAttribute, ok := attributes["alias"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`alias is missing from object`)

		return NewSpecVolumesTargetDataStoreValueUnknown(), diags
	}

	aliasVal, ok := aliasAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`alias expected to be ovhtypes.TfStringValue, was: %T`, aliasAttribute))
	}

	archiveAttribute, ok := attributes["archive"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`archive is missing from object`)

		return NewSpecVolumesTargetDataStoreValueUnknown(), diags
	}

	archiveVal, ok := archiveAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`archive expected to be ovhtypes.TfStringValue, was: %T`, archiveAttribute))
	}

	containerAttribute, ok := attributes["container"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`container is missing from object`)

		return NewSpecVolumesTargetDataStoreValueUnknown(), diags
	}

	containerVal, ok := containerAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`container expected to be ovhtypes.TfStringValue, was: %T`, containerAttribute))
	}

	internalAttribute, ok := attributes["internal"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`internal is missing from object`)

		return NewSpecVolumesTargetDataStoreValueUnknown(), diags
	}

	internalVal, ok := internalAttribute.(ovhtypes.TfBoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`internal expected to be ovhtypes.TfBoolValue, was: %T`, internalAttribute))
	}

	prefixAttribute, ok := attributes["prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix is missing from object`)

		return NewSpecVolumesTargetDataStoreValueUnknown(), diags
	}

	prefixVal, ok := prefixAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix expected to be ovhtypes.TfStringValue, was: %T`, prefixAttribute))
	}

	if diags.HasError() {
		return NewSpecVolumesTargetDataStoreValueUnknown(), diags
	}

	return SpecVolumesTargetDataStoreValue{
		Alias:     aliasVal,
		Archive:   archiveVal,
		Container: containerVal,
		Internal:  internalVal,
		Prefix:    prefixVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewSpecVolumesTargetDataStoreValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SpecVolumesTargetDataStoreValue {
	object, diags := NewSpecVolumesTargetDataStoreValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSpecVolumesTargetDataStoreValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SpecVolumesTargetDataStoreType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSpecVolumesTargetDataStoreValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSpecVolumesTargetDataStoreValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSpecVolumesTargetDataStoreValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSpecVolumesTargetDataStoreValueMust(SpecVolumesTargetDataStoreValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SpecVolumesTargetDataStoreType) ValueType(ctx context.Context) attr.Value {
	return SpecVolumesTargetDataStoreValue{}
}

var _ basetypes.ObjectValuable = SpecVolumesTargetDataStoreValue{}

type SpecVolumesTargetDataStoreValue struct {
	Alias     ovhtypes.TfStringValue `tfsdk:"alias" json:"alias"`
	Archive   ovhtypes.TfStringValue `tfsdk:"archive" json:"archive"`
	Container ovhtypes.TfStringValue `tfsdk:"container" json:"container"`
	Internal  ovhtypes.TfBoolValue   `tfsdk:"internal" json:"internal"`
	Prefix    ovhtypes.TfStringValue `tfsdk:"prefix" json:"prefix"`
	state     attr.ValueState
}

func (v SpecVolumesTargetDataStoreValue) ToCreate() *SpecVolumesTargetDataStoreValue {
	res := &SpecVolumesTargetDataStoreValue{}

	if !v.Internal.IsNull() {
		res.Internal = v.Internal
	}

	res.state = attr.ValueStateKnown

	return res
}

func (v SpecVolumesTargetDataStoreValue) MarshalJSON() ([]byte, error) {
	toMarshal := map[string]any{}
	if !v.Internal.IsNull() && !v.Internal.IsUnknown() {
		toMarshal["internal"] = v.Internal
	}

	return json.Marshal(toMarshal)
}

func (v *SpecVolumesTargetDataStoreValue) UnmarshalJSON(data []byte) error {
	type JsonSpecVolumesTargetDataStoreValue SpecVolumesTargetDataStoreValue

	var tmp JsonSpecVolumesTargetDataStoreValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.Alias = tmp.Alias
	v.Archive = tmp.Archive
	v.Container = tmp.Container
	v.Internal = tmp.Internal
	v.Prefix = tmp.Prefix

	v.state = attr.ValueStateKnown

	return nil
}

func (v *SpecVolumesTargetDataStoreValue) MergeWith(other *SpecVolumesTargetDataStoreValue) {

	if (v.Alias.IsUnknown() || v.Alias.IsNull()) && !other.Alias.IsUnknown() {
		v.Alias = other.Alias
	}

	if (v.Archive.IsUnknown() || v.Archive.IsNull()) && !other.Archive.IsUnknown() {
		v.Archive = other.Archive
	}

	if (v.Container.IsUnknown() || v.Container.IsNull()) && !other.Container.IsUnknown() {
		v.Container = other.Container
	}

	if (v.Internal.IsUnknown() || v.Internal.IsNull()) && !other.Internal.IsUnknown() {
		v.Internal = other.Internal
	}

	if (v.Prefix.IsUnknown() || v.Prefix.IsNull()) && !other.Prefix.IsUnknown() {
		v.Prefix = other.Prefix
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v SpecVolumesTargetDataStoreValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"alias":     v.Alias,
		"archive":   v.Archive,
		"container": v.Container,
		"internal":  v.Internal,
		"prefix":    v.Prefix,
	}
}
func (v SpecVolumesTargetDataStoreValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["alias"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["archive"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["container"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["internal"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["prefix"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.Alias.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["alias"] = val

		val, err = v.Archive.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["archive"] = val

		val, err = v.Container.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["container"] = val

		val, err = v.Internal.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["internal"] = val

		val, err = v.Prefix.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["prefix"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SpecVolumesTargetDataStoreValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SpecVolumesTargetDataStoreValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SpecVolumesTargetDataStoreValue) String() string {
	return "SpecVolumesTargetDataStoreValue"
}

func (v SpecVolumesTargetDataStoreValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"alias":     ovhtypes.TfStringType{},
			"archive":   ovhtypes.TfStringType{},
			"container": ovhtypes.TfStringType{},
			"internal":  ovhtypes.TfBoolType{},
			"prefix":    ovhtypes.TfStringType{},
		},
		map[string]attr.Value{
			"alias":     v.Alias,
			"archive":   v.Archive,
			"container": v.Container,
			"internal":  v.Internal,
			"prefix":    v.Prefix,
		})

	return objVal, diags
}

func (v SpecVolumesTargetDataStoreValue) Equal(o attr.Value) bool {
	other, ok := o.(SpecVolumesTargetDataStoreValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Alias.Equal(other.Alias) {
		return false
	}

	if !v.Archive.Equal(other.Archive) {
		return false
	}

	if !v.Container.Equal(other.Container) {
		return false
	}

	if !v.Internal.Equal(other.Internal) {
		return false
	}

	if !v.Prefix.Equal(other.Prefix) {
		return false
	}

	return true
}

func (v SpecVolumesTargetDataStoreValue) Type(ctx context.Context) attr.Type {
	return SpecVolumesTargetDataStoreType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SpecVolumesTargetDataStoreValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"alias":     ovhtypes.TfStringType{},
		"archive":   ovhtypes.TfStringType{},
		"container": ovhtypes.TfStringType{},
		"internal":  ovhtypes.TfBoolType{},
		"prefix":    ovhtypes.TfStringType{},
	}
}

var _ basetypes.ObjectTypable = SpecVolumesTargetPrivateSwiftType{}

type SpecVolumesTargetPrivateSwiftType struct {
	basetypes.ObjectType
}

func (t SpecVolumesTargetPrivateSwiftType) Equal(o attr.Type) bool {
	other, ok := o.(SpecVolumesTargetPrivateSwiftType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SpecVolumesTargetPrivateSwiftType) String() string {
	return "SpecVolumesTargetPrivateSwiftType"
}

func (t SpecVolumesTargetPrivateSwiftType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	archiveAttribute, ok := attributes["archive"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`archive is missing from object`)

		return nil, diags
	}

	archiveVal, ok := archiveAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`archive expected to be ovhtypes.TfStringValue, was: %T`, archiveAttribute))
	}

	containerAttribute, ok := attributes["container"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`container is missing from object`)

		return nil, diags
	}

	containerVal, ok := containerAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`container expected to be ovhtypes.TfStringValue, was: %T`, containerAttribute))
	}

	internalAttribute, ok := attributes["internal"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`internal is missing from object`)

		return nil, diags
	}

	internalVal, ok := internalAttribute.(ovhtypes.TfBoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`internal expected to be ovhtypes.TfBoolValue, was: %T`, internalAttribute))
	}

	prefixAttribute, ok := attributes["prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix is missing from object`)

		return nil, diags
	}

	prefixVal, ok := prefixAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix expected to be ovhtypes.TfStringValue, was: %T`, prefixAttribute))
	}

	regionAttribute, ok := attributes["region"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`region is missing from object`)

		return nil, diags
	}

	regionVal, ok := regionAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`region expected to be ovhtypes.TfStringValue, was: %T`, regionAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SpecVolumesTargetPrivateSwiftValue{
		Archive:   archiveVal,
		Container: containerVal,
		Internal:  internalVal,
		Prefix:    prefixVal,
		Region:    regionVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewSpecVolumesTargetPrivateSwiftValueNull() SpecVolumesTargetPrivateSwiftValue {
	return SpecVolumesTargetPrivateSwiftValue{
		state: attr.ValueStateNull,
	}
}

func NewSpecVolumesTargetPrivateSwiftValueUnknown() SpecVolumesTargetPrivateSwiftValue {
	return SpecVolumesTargetPrivateSwiftValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSpecVolumesTargetPrivateSwiftValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SpecVolumesTargetPrivateSwiftValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SpecVolumesTargetPrivateSwiftValue Attribute Value",
				"While creating a SpecVolumesTargetPrivateSwiftValue value, a missing attribute value was detected. "+
					"A SpecVolumesTargetPrivateSwiftValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpecVolumesTargetPrivateSwiftValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SpecVolumesTargetPrivateSwiftValue Attribute Type",
				"While creating a SpecVolumesTargetPrivateSwiftValue value, an invalid attribute value was detected. "+
					"A SpecVolumesTargetPrivateSwiftValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpecVolumesTargetPrivateSwiftValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SpecVolumesTargetPrivateSwiftValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SpecVolumesTargetPrivateSwiftValue Attribute Value",
				"While creating a SpecVolumesTargetPrivateSwiftValue value, an extra attribute value was detected. "+
					"A SpecVolumesTargetPrivateSwiftValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SpecVolumesTargetPrivateSwiftValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSpecVolumesTargetPrivateSwiftValueUnknown(), diags
	}

	archiveAttribute, ok := attributes["archive"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`archive is missing from object`)

		return NewSpecVolumesTargetPrivateSwiftValueUnknown(), diags
	}

	archiveVal, ok := archiveAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`archive expected to be ovhtypes.TfStringValue, was: %T`, archiveAttribute))
	}

	containerAttribute, ok := attributes["container"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`container is missing from object`)

		return NewSpecVolumesTargetPrivateSwiftValueUnknown(), diags
	}

	containerVal, ok := containerAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`container expected to be ovhtypes.TfStringValue, was: %T`, containerAttribute))
	}

	internalAttribute, ok := attributes["internal"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`internal is missing from object`)

		return NewSpecVolumesTargetPrivateSwiftValueUnknown(), diags
	}

	internalVal, ok := internalAttribute.(ovhtypes.TfBoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`internal expected to be ovhtypes.TfBoolValue, was: %T`, internalAttribute))
	}

	prefixAttribute, ok := attributes["prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix is missing from object`)

		return NewSpecVolumesTargetPrivateSwiftValueUnknown(), diags
	}

	prefixVal, ok := prefixAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix expected to be ovhtypes.TfStringValue, was: %T`, prefixAttribute))
	}

	regionAttribute, ok := attributes["region"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`region is missing from object`)

		return NewSpecVolumesTargetPrivateSwiftValueUnknown(), diags
	}

	regionVal, ok := regionAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`region expected to be ovhtypes.TfStringValue, was: %T`, regionAttribute))
	}

	if diags.HasError() {
		return NewSpecVolumesTargetPrivateSwiftValueUnknown(), diags
	}

	return SpecVolumesTargetPrivateSwiftValue{
		Archive:   archiveVal,
		Container: containerVal,
		Internal:  internalVal,
		Prefix:    prefixVal,
		Region:    regionVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewSpecVolumesTargetPrivateSwiftValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SpecVolumesTargetPrivateSwiftValue {
	object, diags := NewSpecVolumesTargetPrivateSwiftValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSpecVolumesTargetPrivateSwiftValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SpecVolumesTargetPrivateSwiftType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSpecVolumesTargetPrivateSwiftValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSpecVolumesTargetPrivateSwiftValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSpecVolumesTargetPrivateSwiftValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSpecVolumesTargetPrivateSwiftValueMust(SpecVolumesTargetPrivateSwiftValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SpecVolumesTargetPrivateSwiftType) ValueType(ctx context.Context) attr.Value {
	return SpecVolumesTargetPrivateSwiftValue{}
}

var _ basetypes.ObjectValuable = SpecVolumesTargetPrivateSwiftValue{}

type SpecVolumesTargetPrivateSwiftValue struct {
	Archive   ovhtypes.TfStringValue `tfsdk:"archive" json:"archive"`
	Container ovhtypes.TfStringValue `tfsdk:"container" json:"container"`
	Internal  ovhtypes.TfBoolValue   `tfsdk:"internal" json:"internal"`
	Prefix    ovhtypes.TfStringValue `tfsdk:"prefix" json:"prefix"`
	Region    ovhtypes.TfStringValue `tfsdk:"region" json:"region"`
	state     attr.ValueState
}

func (v SpecVolumesTargetPrivateSwiftValue) ToCreate() *SpecVolumesTargetPrivateSwiftValue {
	res := &SpecVolumesTargetPrivateSwiftValue{}

	if !v.Internal.IsNull() {
		res.Internal = v.Internal
	}

	res.state = attr.ValueStateKnown

	return res
}

func (v SpecVolumesTargetPrivateSwiftValue) MarshalJSON() ([]byte, error) {
	toMarshal := map[string]any{}
	if !v.Internal.IsNull() && !v.Internal.IsUnknown() {
		toMarshal["internal"] = v.Internal
	}

	return json.Marshal(toMarshal)
}

func (v *SpecVolumesTargetPrivateSwiftValue) UnmarshalJSON(data []byte) error {
	type JsonSpecVolumesTargetPrivateSwiftValue SpecVolumesTargetPrivateSwiftValue

	var tmp JsonSpecVolumesTargetPrivateSwiftValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.Archive = tmp.Archive
	v.Container = tmp.Container
	v.Internal = tmp.Internal
	v.Prefix = tmp.Prefix
	v.Region = tmp.Region

	v.state = attr.ValueStateKnown

	return nil
}

func (v *SpecVolumesTargetPrivateSwiftValue) MergeWith(other *SpecVolumesTargetPrivateSwiftValue) {

	if (v.Archive.IsUnknown() || v.Archive.IsNull()) && !other.Archive.IsUnknown() {
		v.Archive = other.Archive
	}

	if (v.Container.IsUnknown() || v.Container.IsNull()) && !other.Container.IsUnknown() {
		v.Container = other.Container
	}

	if (v.Internal.IsUnknown() || v.Internal.IsNull()) && !other.Internal.IsUnknown() {
		v.Internal = other.Internal
	}

	if (v.Prefix.IsUnknown() || v.Prefix.IsNull()) && !other.Prefix.IsUnknown() {
		v.Prefix = other.Prefix
	}

	if (v.Region.IsUnknown() || v.Region.IsNull()) && !other.Region.IsUnknown() {
		v.Region = other.Region
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v SpecVolumesTargetPrivateSwiftValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"archive":   v.Archive,
		"container": v.Container,
		"internal":  v.Internal,
		"prefix":    v.Prefix,
		"region":    v.Region,
	}
}
func (v SpecVolumesTargetPrivateSwiftValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["archive"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["container"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["internal"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["prefix"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["region"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.Archive.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["archive"] = val

		val, err = v.Container.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["container"] = val

		val, err = v.Internal.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["internal"] = val

		val, err = v.Prefix.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["prefix"] = val

		val, err = v.Region.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["region"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SpecVolumesTargetPrivateSwiftValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SpecVolumesTargetPrivateSwiftValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SpecVolumesTargetPrivateSwiftValue) String() string {
	return "SpecVolumesTargetPrivateSwiftValue"
}

func (v SpecVolumesTargetPrivateSwiftValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"archive":   ovhtypes.TfStringType{},
			"container": ovhtypes.TfStringType{},
			"internal":  ovhtypes.TfBoolType{},
			"prefix":    ovhtypes.TfStringType{},
			"region":    ovhtypes.TfStringType{},
		},
		map[string]attr.Value{
			"archive":   v.Archive,
			"container": v.Container,
			"internal":  v.Internal,
			"prefix":    v.Prefix,
			"region":    v.Region,
		})

	return objVal, diags
}

func (v SpecVolumesTargetPrivateSwiftValue) Equal(o attr.Value) bool {
	other, ok := o.(SpecVolumesTargetPrivateSwiftValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Archive.Equal(other.Archive) {
		return false
	}

	if !v.Container.Equal(other.Container) {
		return false
	}

	if !v.Internal.Equal(other.Internal) {
		return false
	}

	if !v.Prefix.Equal(other.Prefix) {
		return false
	}

	if !v.Region.Equal(other.Region) {
		return false
	}

	return true
}

func (v SpecVolumesTargetPrivateSwiftValue) Type(ctx context.Context) attr.Type {
	return SpecVolumesTargetPrivateSwiftType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SpecVolumesTargetPrivateSwiftValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"archive":   ovhtypes.TfStringType{},
		"container": ovhtypes.TfStringType{},
		"internal":  ovhtypes.TfBoolType{},
		"prefix":    ovhtypes.TfStringType{},
		"region":    ovhtypes.TfStringType{},
	}
}

var _ basetypes.ObjectTypable = SpecVolumesVolumeSourceType{}

type SpecVolumesVolumeSourceType struct {
	basetypes.ObjectType
}

func (t SpecVolumesVolumeSourceType) Equal(o attr.Type) bool {
	other, ok := o.(SpecVolumesVolumeSourceType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SpecVolumesVolumeSourceType) String() string {
	return "SpecVolumesVolumeSourceType"
}

func (t SpecVolumesVolumeSourceType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	dataStoreAttribute, ok := attributes["data_store"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`data_store is missing from object`)

		return nil, diags
	}

	dataStoreVal, ok := dataStoreAttribute.(SpecVolumesVolumeSourceDataStoreValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`data_store expected to be SpecVolumesVolumeSourceDataStoreValue, was: %T`, dataStoreAttribute))
	}

	publicGitAttribute, ok := attributes["public_git"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`public_git is missing from object`)

		return nil, diags
	}

	publicGitVal, ok := publicGitAttribute.(SpecVolumesVolumeSourcePublicGitValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`public_git expected to be SpecVolumesVolumeSourcePublicGitValue, was: %T`, publicGitAttribute))
	}

	publicSwiftAttribute, ok := attributes["public_swift"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`public_swift is missing from object`)

		return nil, diags
	}

	publicSwiftVal, ok := publicSwiftAttribute.(SpecVolumesVolumeSourcePublicSwiftValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`public_swift expected to be SpecVolumesVolumeSourcePublicSwiftValue, was: %T`, publicSwiftAttribute))
	}

	standaloneAttribute, ok := attributes["standalone"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`standalone is missing from object`)

		return nil, diags
	}

	standaloneVal, ok := standaloneAttribute.(SpecVolumesVolumeSourceStandaloneValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`standalone expected to be SpecVolumesVolumeSourceStandaloneValue, was: %T`, standaloneAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SpecVolumesVolumeSourceValue{
		DataStore:   dataStoreVal,
		PublicGit:   publicGitVal,
		PublicSwift: publicSwiftVal,
		Standalone:  standaloneVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewSpecVolumesVolumeSourceValueNull() SpecVolumesVolumeSourceValue {
	return SpecVolumesVolumeSourceValue{
		state: attr.ValueStateNull,
	}
}

func NewSpecVolumesVolumeSourceValueUnknown() SpecVolumesVolumeSourceValue {
	return SpecVolumesVolumeSourceValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSpecVolumesVolumeSourceValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SpecVolumesVolumeSourceValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SpecVolumesVolumeSourceValue Attribute Value",
				"While creating a SpecVolumesVolumeSourceValue value, a missing attribute value was detected. "+
					"A SpecVolumesVolumeSourceValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpecVolumesVolumeSourceValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SpecVolumesVolumeSourceValue Attribute Type",
				"While creating a SpecVolumesVolumeSourceValue value, an invalid attribute value was detected. "+
					"A SpecVolumesVolumeSourceValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpecVolumesVolumeSourceValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SpecVolumesVolumeSourceValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SpecVolumesVolumeSourceValue Attribute Value",
				"While creating a SpecVolumesVolumeSourceValue value, an extra attribute value was detected. "+
					"A SpecVolumesVolumeSourceValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SpecVolumesVolumeSourceValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSpecVolumesVolumeSourceValueUnknown(), diags
	}

	dataStoreAttribute, ok := attributes["data_store"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`data_store is missing from object`)

		return NewSpecVolumesVolumeSourceValueUnknown(), diags
	}

	dataStoreVal, ok := dataStoreAttribute.(SpecVolumesVolumeSourceDataStoreValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`data_store expected to be SpecVolumesVolumeSourceDataStoreValue, was: %T`, dataStoreAttribute))
	}

	publicGitAttribute, ok := attributes["public_git"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`public_git is missing from object`)

		return NewSpecVolumesVolumeSourceValueUnknown(), diags
	}

	publicGitVal, ok := publicGitAttribute.(SpecVolumesVolumeSourcePublicGitValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`public_git expected to be SpecVolumesVolumeSourcePublicGitValue, was: %T`, publicGitAttribute))
	}

	publicSwiftAttribute, ok := attributes["public_swift"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`public_swift is missing from object`)

		return NewSpecVolumesVolumeSourceValueUnknown(), diags
	}

	publicSwiftVal, ok := publicSwiftAttribute.(SpecVolumesVolumeSourcePublicSwiftValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`public_swift expected to be SpecVolumesVolumeSourcePublicSwiftValue, was: %T`, publicSwiftAttribute))
	}

	standaloneAttribute, ok := attributes["standalone"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`standalone is missing from object`)

		return NewSpecVolumesVolumeSourceValueUnknown(), diags
	}

	standaloneVal, ok := standaloneAttribute.(SpecVolumesVolumeSourceStandaloneValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`standalone expected to be SpecVolumesVolumeSourceStandaloneValue, was: %T`, standaloneAttribute))
	}

	if diags.HasError() {
		return NewSpecVolumesVolumeSourceValueUnknown(), diags
	}

	return SpecVolumesVolumeSourceValue{
		DataStore:   dataStoreVal,
		PublicGit:   publicGitVal,
		PublicSwift: publicSwiftVal,
		Standalone:  standaloneVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewSpecVolumesVolumeSourceValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SpecVolumesVolumeSourceValue {
	object, diags := NewSpecVolumesVolumeSourceValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSpecVolumesVolumeSourceValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SpecVolumesVolumeSourceType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSpecVolumesVolumeSourceValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSpecVolumesVolumeSourceValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSpecVolumesVolumeSourceValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSpecVolumesVolumeSourceValueMust(SpecVolumesVolumeSourceValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SpecVolumesVolumeSourceType) ValueType(ctx context.Context) attr.Value {
	return SpecVolumesVolumeSourceValue{}
}

var _ basetypes.ObjectValuable = SpecVolumesVolumeSourceValue{}

type SpecVolumesVolumeSourceValue struct {
	DataStore   SpecVolumesVolumeSourceDataStoreValue   `tfsdk:"data_store" json:"dataStore"`
	PublicGit   SpecVolumesVolumeSourcePublicGitValue   `tfsdk:"public_git" json:"publicGit"`
	PublicSwift SpecVolumesVolumeSourcePublicSwiftValue `tfsdk:"public_swift" json:"publicSwift"`
	Standalone  SpecVolumesVolumeSourceStandaloneValue  `tfsdk:"standalone" json:"standalone"`
	state       attr.ValueState
}

func (v *SpecVolumesVolumeSourceValue) UnmarshalJSON(data []byte) error {
	type JsonSpecVolumesVolumeSourceValue SpecVolumesVolumeSourceValue

	var tmp JsonSpecVolumesVolumeSourceValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.DataStore = tmp.DataStore
	v.PublicGit = tmp.PublicGit
	v.PublicSwift = tmp.PublicSwift
	v.Standalone = tmp.Standalone

	v.state = attr.ValueStateKnown

	return nil
}

func (v *SpecVolumesVolumeSourceValue) MergeWith(other *SpecVolumesVolumeSourceValue) {

	if v.DataStore.IsUnknown() && !other.DataStore.IsUnknown() {
		v.DataStore = other.DataStore
	} else if !other.DataStore.IsUnknown() {
		v.DataStore.MergeWith(&other.DataStore)
	}

	if v.PublicGit.IsUnknown() && !other.PublicGit.IsUnknown() {
		v.PublicGit = other.PublicGit
	} else if !other.PublicGit.IsUnknown() {
		v.PublicGit.MergeWith(&other.PublicGit)
	}

	if v.PublicSwift.IsUnknown() && !other.PublicSwift.IsUnknown() {
		v.PublicSwift = other.PublicSwift
	} else if !other.PublicSwift.IsUnknown() {
		v.PublicSwift.MergeWith(&other.PublicSwift)
	}

	if v.Standalone.IsUnknown() && !other.Standalone.IsUnknown() {
		v.Standalone = other.Standalone
	} else if !other.Standalone.IsUnknown() {
		v.Standalone.MergeWith(&other.Standalone)
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v SpecVolumesVolumeSourceValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"dataStore":   v.DataStore,
		"publicGit":   v.PublicGit,
		"publicSwift": v.PublicSwift,
		"standalone":  v.Standalone,
	}
}
func (v SpecVolumesVolumeSourceValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["data_store"] = basetypes.ObjectType{
		AttrTypes: SpecVolumesVolumeSourceDataStoreValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["public_git"] = basetypes.ObjectType{
		AttrTypes: SpecVolumesVolumeSourcePublicGitValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["public_swift"] = basetypes.ObjectType{
		AttrTypes: SpecVolumesVolumeSourcePublicSwiftValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["standalone"] = basetypes.ObjectType{
		AttrTypes: SpecVolumesVolumeSourceStandaloneValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.DataStore.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["data_store"] = val

		val, err = v.PublicGit.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["public_git"] = val

		val, err = v.PublicSwift.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["public_swift"] = val

		val, err = v.Standalone.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["standalone"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SpecVolumesVolumeSourceValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SpecVolumesVolumeSourceValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SpecVolumesVolumeSourceValue) String() string {
	return "SpecVolumesVolumeSourceValue"
}

func (v SpecVolumesVolumeSourceValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"data_store": SpecVolumesVolumeSourceDataStoreType{
				basetypes.ObjectType{
					AttrTypes: SpecVolumesVolumeSourceDataStoreValue{}.AttributeTypes(ctx),
				},
			},
			"public_git": SpecVolumesVolumeSourcePublicGitType{
				basetypes.ObjectType{
					AttrTypes: SpecVolumesVolumeSourcePublicGitValue{}.AttributeTypes(ctx),
				},
			},
			"public_swift": SpecVolumesVolumeSourcePublicSwiftType{
				basetypes.ObjectType{
					AttrTypes: SpecVolumesVolumeSourcePublicSwiftValue{}.AttributeTypes(ctx),
				},
			},
			"standalone": SpecVolumesVolumeSourceStandaloneType{
				basetypes.ObjectType{
					AttrTypes: SpecVolumesVolumeSourceStandaloneValue{}.AttributeTypes(ctx),
				},
			},
		},
		map[string]attr.Value{
			"data_store":   v.DataStore,
			"public_git":   v.PublicGit,
			"public_swift": v.PublicSwift,
			"standalone":   v.Standalone,
		})

	return objVal, diags
}

func (v SpecVolumesVolumeSourceValue) Equal(o attr.Value) bool {
	other, ok := o.(SpecVolumesVolumeSourceValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.DataStore.Equal(other.DataStore) {
		return false
	}

	if !v.PublicGit.Equal(other.PublicGit) {
		return false
	}

	if !v.PublicSwift.Equal(other.PublicSwift) {
		return false
	}

	if !v.Standalone.Equal(other.Standalone) {
		return false
	}

	return true
}

func (v SpecVolumesVolumeSourceValue) Type(ctx context.Context) attr.Type {
	return SpecVolumesVolumeSourceType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SpecVolumesVolumeSourceValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"data_store":   SpecVolumesVolumeSourceDataStoreValue{}.Type(ctx),
		"public_git":   SpecVolumesVolumeSourcePublicGitValue{}.Type(ctx),
		"public_swift": SpecVolumesVolumeSourcePublicSwiftValue{}.Type(ctx),
		"standalone":   SpecVolumesVolumeSourceStandaloneValue{}.Type(ctx),
	}
}

var _ basetypes.ObjectTypable = SpecVolumesVolumeSourceDataStoreType{}

type SpecVolumesVolumeSourceDataStoreType struct {
	basetypes.ObjectType
}

func (t SpecVolumesVolumeSourceDataStoreType) Equal(o attr.Type) bool {
	other, ok := o.(SpecVolumesVolumeSourceDataStoreType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SpecVolumesVolumeSourceDataStoreType) String() string {
	return "SpecVolumesVolumeSourceDataStoreType"
}

func (t SpecVolumesVolumeSourceDataStoreType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	aliasAttribute, ok := attributes["alias"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`alias is missing from object`)

		return nil, diags
	}

	aliasVal, ok := aliasAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`alias expected to be ovhtypes.TfStringValue, was: %T`, aliasAttribute))
	}

	archiveAttribute, ok := attributes["archive"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`archive is missing from object`)

		return nil, diags
	}

	archiveVal, ok := archiveAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`archive expected to be ovhtypes.TfStringValue, was: %T`, archiveAttribute))
	}

	containerAttribute, ok := attributes["container"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`container is missing from object`)

		return nil, diags
	}

	containerVal, ok := containerAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`container expected to be ovhtypes.TfStringValue, was: %T`, containerAttribute))
	}

	internalAttribute, ok := attributes["internal"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`internal is missing from object`)

		return nil, diags
	}

	internalVal, ok := internalAttribute.(ovhtypes.TfBoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`internal expected to be ovhtypes.TfBoolValue, was: %T`, internalAttribute))
	}

	prefixAttribute, ok := attributes["prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix is missing from object`)

		return nil, diags
	}

	prefixVal, ok := prefixAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix expected to be ovhtypes.TfStringValue, was: %T`, prefixAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SpecVolumesVolumeSourceDataStoreValue{
		Alias:     aliasVal,
		Archive:   archiveVal,
		Container: containerVal,
		Internal:  internalVal,
		Prefix:    prefixVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewSpecVolumesVolumeSourceDataStoreValueNull() SpecVolumesVolumeSourceDataStoreValue {
	return SpecVolumesVolumeSourceDataStoreValue{
		state: attr.ValueStateNull,
	}
}

func NewSpecVolumesVolumeSourceDataStoreValueUnknown() SpecVolumesVolumeSourceDataStoreValue {
	return SpecVolumesVolumeSourceDataStoreValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSpecVolumesVolumeSourceDataStoreValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SpecVolumesVolumeSourceDataStoreValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SpecVolumesVolumeSourceDataStoreValue Attribute Value",
				"While creating a SpecVolumesVolumeSourceDataStoreValue value, a missing attribute value was detected. "+
					"A SpecVolumesVolumeSourceDataStoreValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpecVolumesVolumeSourceDataStoreValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SpecVolumesVolumeSourceDataStoreValue Attribute Type",
				"While creating a SpecVolumesVolumeSourceDataStoreValue value, an invalid attribute value was detected. "+
					"A SpecVolumesVolumeSourceDataStoreValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpecVolumesVolumeSourceDataStoreValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SpecVolumesVolumeSourceDataStoreValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SpecVolumesVolumeSourceDataStoreValue Attribute Value",
				"While creating a SpecVolumesVolumeSourceDataStoreValue value, an extra attribute value was detected. "+
					"A SpecVolumesVolumeSourceDataStoreValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SpecVolumesVolumeSourceDataStoreValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSpecVolumesVolumeSourceDataStoreValueUnknown(), diags
	}

	aliasAttribute, ok := attributes["alias"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`alias is missing from object`)

		return NewSpecVolumesVolumeSourceDataStoreValueUnknown(), diags
	}

	aliasVal, ok := aliasAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`alias expected to be ovhtypes.TfStringValue, was: %T`, aliasAttribute))
	}

	archiveAttribute, ok := attributes["archive"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`archive is missing from object`)

		return NewSpecVolumesVolumeSourceDataStoreValueUnknown(), diags
	}

	archiveVal, ok := archiveAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`archive expected to be ovhtypes.TfStringValue, was: %T`, archiveAttribute))
	}

	containerAttribute, ok := attributes["container"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`container is missing from object`)

		return NewSpecVolumesVolumeSourceDataStoreValueUnknown(), diags
	}

	containerVal, ok := containerAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`container expected to be ovhtypes.TfStringValue, was: %T`, containerAttribute))
	}

	internalAttribute, ok := attributes["internal"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`internal is missing from object`)

		return NewSpecVolumesVolumeSourceDataStoreValueUnknown(), diags
	}

	internalVal, ok := internalAttribute.(ovhtypes.TfBoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`internal expected to be ovhtypes.TfBoolValue, was: %T`, internalAttribute))
	}

	prefixAttribute, ok := attributes["prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix is missing from object`)

		return NewSpecVolumesVolumeSourceDataStoreValueUnknown(), diags
	}

	prefixVal, ok := prefixAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix expected to be ovhtypes.TfStringValue, was: %T`, prefixAttribute))
	}

	if diags.HasError() {
		return NewSpecVolumesVolumeSourceDataStoreValueUnknown(), diags
	}

	return SpecVolumesVolumeSourceDataStoreValue{
		Alias:     aliasVal,
		Archive:   archiveVal,
		Container: containerVal,
		Internal:  internalVal,
		Prefix:    prefixVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewSpecVolumesVolumeSourceDataStoreValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SpecVolumesVolumeSourceDataStoreValue {
	object, diags := NewSpecVolumesVolumeSourceDataStoreValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSpecVolumesVolumeSourceDataStoreValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SpecVolumesVolumeSourceDataStoreType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSpecVolumesVolumeSourceDataStoreValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSpecVolumesVolumeSourceDataStoreValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSpecVolumesVolumeSourceDataStoreValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSpecVolumesVolumeSourceDataStoreValueMust(SpecVolumesVolumeSourceDataStoreValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SpecVolumesVolumeSourceDataStoreType) ValueType(ctx context.Context) attr.Value {
	return SpecVolumesVolumeSourceDataStoreValue{}
}

var _ basetypes.ObjectValuable = SpecVolumesVolumeSourceDataStoreValue{}

type SpecVolumesVolumeSourceDataStoreValue struct {
	Alias     ovhtypes.TfStringValue `tfsdk:"alias" json:"alias"`
	Archive   ovhtypes.TfStringValue `tfsdk:"archive" json:"archive"`
	Container ovhtypes.TfStringValue `tfsdk:"container" json:"container"`
	Internal  ovhtypes.TfBoolValue   `tfsdk:"internal" json:"internal"`
	Prefix    ovhtypes.TfStringValue `tfsdk:"prefix" json:"prefix"`
	state     attr.ValueState
}

func (v SpecVolumesVolumeSourceDataStoreValue) ToCreate() *SpecVolumesVolumeSourceDataStoreValue {
	res := &SpecVolumesVolumeSourceDataStoreValue{}

	if !v.Internal.IsNull() {
		res.Internal = v.Internal
	}

	res.state = attr.ValueStateKnown

	return res
}

func (v SpecVolumesVolumeSourceDataStoreValue) MarshalJSON() ([]byte, error) {
	toMarshal := map[string]any{}
	if !v.Internal.IsNull() && !v.Internal.IsUnknown() {
		toMarshal["internal"] = v.Internal
	}

	return json.Marshal(toMarshal)
}

func (v *SpecVolumesVolumeSourceDataStoreValue) UnmarshalJSON(data []byte) error {
	type JsonSpecVolumesVolumeSourceDataStoreValue SpecVolumesVolumeSourceDataStoreValue

	var tmp JsonSpecVolumesVolumeSourceDataStoreValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.Alias = tmp.Alias
	v.Archive = tmp.Archive
	v.Container = tmp.Container
	v.Internal = tmp.Internal
	v.Prefix = tmp.Prefix

	v.state = attr.ValueStateKnown

	return nil
}

func (v *SpecVolumesVolumeSourceDataStoreValue) MergeWith(other *SpecVolumesVolumeSourceDataStoreValue) {

	if (v.Alias.IsUnknown() || v.Alias.IsNull()) && !other.Alias.IsUnknown() {
		v.Alias = other.Alias
	}

	if (v.Archive.IsUnknown() || v.Archive.IsNull()) && !other.Archive.IsUnknown() {
		v.Archive = other.Archive
	}

	if (v.Container.IsUnknown() || v.Container.IsNull()) && !other.Container.IsUnknown() {
		v.Container = other.Container
	}

	if (v.Internal.IsUnknown() || v.Internal.IsNull()) && !other.Internal.IsUnknown() {
		v.Internal = other.Internal
	}

	if (v.Prefix.IsUnknown() || v.Prefix.IsNull()) && !other.Prefix.IsUnknown() {
		v.Prefix = other.Prefix
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v SpecVolumesVolumeSourceDataStoreValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"alias":     v.Alias,
		"archive":   v.Archive,
		"container": v.Container,
		"internal":  v.Internal,
		"prefix":    v.Prefix,
	}
}
func (v SpecVolumesVolumeSourceDataStoreValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["alias"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["archive"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["container"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["internal"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["prefix"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.Alias.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["alias"] = val

		val, err = v.Archive.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["archive"] = val

		val, err = v.Container.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["container"] = val

		val, err = v.Internal.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["internal"] = val

		val, err = v.Prefix.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["prefix"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SpecVolumesVolumeSourceDataStoreValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SpecVolumesVolumeSourceDataStoreValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SpecVolumesVolumeSourceDataStoreValue) String() string {
	return "SpecVolumesVolumeSourceDataStoreValue"
}

func (v SpecVolumesVolumeSourceDataStoreValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"alias":     ovhtypes.TfStringType{},
			"archive":   ovhtypes.TfStringType{},
			"container": ovhtypes.TfStringType{},
			"internal":  ovhtypes.TfBoolType{},
			"prefix":    ovhtypes.TfStringType{},
		},
		map[string]attr.Value{
			"alias":     v.Alias,
			"archive":   v.Archive,
			"container": v.Container,
			"internal":  v.Internal,
			"prefix":    v.Prefix,
		})

	return objVal, diags
}

func (v SpecVolumesVolumeSourceDataStoreValue) Equal(o attr.Value) bool {
	other, ok := o.(SpecVolumesVolumeSourceDataStoreValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Alias.Equal(other.Alias) {
		return false
	}

	if !v.Archive.Equal(other.Archive) {
		return false
	}

	if !v.Container.Equal(other.Container) {
		return false
	}

	if !v.Internal.Equal(other.Internal) {
		return false
	}

	if !v.Prefix.Equal(other.Prefix) {
		return false
	}

	return true
}

func (v SpecVolumesVolumeSourceDataStoreValue) Type(ctx context.Context) attr.Type {
	return SpecVolumesVolumeSourceDataStoreType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SpecVolumesVolumeSourceDataStoreValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"alias":     ovhtypes.TfStringType{},
		"archive":   ovhtypes.TfStringType{},
		"container": ovhtypes.TfStringType{},
		"internal":  ovhtypes.TfBoolType{},
		"prefix":    ovhtypes.TfStringType{},
	}
}

var _ basetypes.ObjectTypable = SpecVolumesVolumeSourcePublicGitType{}

type SpecVolumesVolumeSourcePublicGitType struct {
	basetypes.ObjectType
}

func (t SpecVolumesVolumeSourcePublicGitType) Equal(o attr.Type) bool {
	other, ok := o.(SpecVolumesVolumeSourcePublicGitType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SpecVolumesVolumeSourcePublicGitType) String() string {
	return "SpecVolumesVolumeSourcePublicGitType"
}

func (t SpecVolumesVolumeSourcePublicGitType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return nil, diags
	}

	urlVal, ok := urlAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be ovhtypes.TfStringValue, was: %T`, urlAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SpecVolumesVolumeSourcePublicGitValue{
		Url:   urlVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewSpecVolumesVolumeSourcePublicGitValueNull() SpecVolumesVolumeSourcePublicGitValue {
	return SpecVolumesVolumeSourcePublicGitValue{
		state: attr.ValueStateNull,
	}
}

func NewSpecVolumesVolumeSourcePublicGitValueUnknown() SpecVolumesVolumeSourcePublicGitValue {
	return SpecVolumesVolumeSourcePublicGitValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSpecVolumesVolumeSourcePublicGitValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SpecVolumesVolumeSourcePublicGitValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SpecVolumesVolumeSourcePublicGitValue Attribute Value",
				"While creating a SpecVolumesVolumeSourcePublicGitValue value, a missing attribute value was detected. "+
					"A SpecVolumesVolumeSourcePublicGitValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpecVolumesVolumeSourcePublicGitValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SpecVolumesVolumeSourcePublicGitValue Attribute Type",
				"While creating a SpecVolumesVolumeSourcePublicGitValue value, an invalid attribute value was detected. "+
					"A SpecVolumesVolumeSourcePublicGitValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpecVolumesVolumeSourcePublicGitValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SpecVolumesVolumeSourcePublicGitValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SpecVolumesVolumeSourcePublicGitValue Attribute Value",
				"While creating a SpecVolumesVolumeSourcePublicGitValue value, an extra attribute value was detected. "+
					"A SpecVolumesVolumeSourcePublicGitValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SpecVolumesVolumeSourcePublicGitValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSpecVolumesVolumeSourcePublicGitValueUnknown(), diags
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return NewSpecVolumesVolumeSourcePublicGitValueUnknown(), diags
	}

	urlVal, ok := urlAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be ovhtypes.TfStringValue, was: %T`, urlAttribute))
	}

	if diags.HasError() {
		return NewSpecVolumesVolumeSourcePublicGitValueUnknown(), diags
	}

	return SpecVolumesVolumeSourcePublicGitValue{
		Url:   urlVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewSpecVolumesVolumeSourcePublicGitValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SpecVolumesVolumeSourcePublicGitValue {
	object, diags := NewSpecVolumesVolumeSourcePublicGitValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSpecVolumesVolumeSourcePublicGitValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SpecVolumesVolumeSourcePublicGitType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSpecVolumesVolumeSourcePublicGitValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSpecVolumesVolumeSourcePublicGitValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSpecVolumesVolumeSourcePublicGitValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSpecVolumesVolumeSourcePublicGitValueMust(SpecVolumesVolumeSourcePublicGitValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SpecVolumesVolumeSourcePublicGitType) ValueType(ctx context.Context) attr.Value {
	return SpecVolumesVolumeSourcePublicGitValue{}
}

var _ basetypes.ObjectValuable = SpecVolumesVolumeSourcePublicGitValue{}

type SpecVolumesVolumeSourcePublicGitValue struct {
	Url   ovhtypes.TfStringValue `tfsdk:"url" json:"url"`
	state attr.ValueState
}

func (v *SpecVolumesVolumeSourcePublicGitValue) UnmarshalJSON(data []byte) error {
	type JsonSpecVolumesVolumeSourcePublicGitValue SpecVolumesVolumeSourcePublicGitValue

	var tmp JsonSpecVolumesVolumeSourcePublicGitValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.Url = tmp.Url

	v.state = attr.ValueStateKnown

	return nil
}

func (v *SpecVolumesVolumeSourcePublicGitValue) MergeWith(other *SpecVolumesVolumeSourcePublicGitValue) {

	if (v.Url.IsUnknown() || v.Url.IsNull()) && !other.Url.IsUnknown() {
		v.Url = other.Url
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v SpecVolumesVolumeSourcePublicGitValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"url": v.Url,
	}
}
func (v SpecVolumesVolumeSourcePublicGitValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["url"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Url.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["url"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SpecVolumesVolumeSourcePublicGitValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SpecVolumesVolumeSourcePublicGitValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SpecVolumesVolumeSourcePublicGitValue) String() string {
	return "SpecVolumesVolumeSourcePublicGitValue"
}

func (v SpecVolumesVolumeSourcePublicGitValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"url": ovhtypes.TfStringType{},
		},
		map[string]attr.Value{
			"url": v.Url,
		})

	return objVal, diags
}

func (v SpecVolumesVolumeSourcePublicGitValue) Equal(o attr.Value) bool {
	other, ok := o.(SpecVolumesVolumeSourcePublicGitValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Url.Equal(other.Url) {
		return false
	}

	return true
}

func (v SpecVolumesVolumeSourcePublicGitValue) Type(ctx context.Context) attr.Type {
	return SpecVolumesVolumeSourcePublicGitType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SpecVolumesVolumeSourcePublicGitValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"url": ovhtypes.TfStringType{},
	}
}

var _ basetypes.ObjectTypable = SpecVolumesVolumeSourcePublicSwiftType{}

type SpecVolumesVolumeSourcePublicSwiftType struct {
	basetypes.ObjectType
}

func (t SpecVolumesVolumeSourcePublicSwiftType) Equal(o attr.Type) bool {
	other, ok := o.(SpecVolumesVolumeSourcePublicSwiftType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SpecVolumesVolumeSourcePublicSwiftType) String() string {
	return "SpecVolumesVolumeSourcePublicSwiftType"
}

func (t SpecVolumesVolumeSourcePublicSwiftType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return nil, diags
	}

	urlVal, ok := urlAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be ovhtypes.TfStringValue, was: %T`, urlAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SpecVolumesVolumeSourcePublicSwiftValue{
		Url:   urlVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewSpecVolumesVolumeSourcePublicSwiftValueNull() SpecVolumesVolumeSourcePublicSwiftValue {
	return SpecVolumesVolumeSourcePublicSwiftValue{
		state: attr.ValueStateNull,
	}
}

func NewSpecVolumesVolumeSourcePublicSwiftValueUnknown() SpecVolumesVolumeSourcePublicSwiftValue {
	return SpecVolumesVolumeSourcePublicSwiftValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSpecVolumesVolumeSourcePublicSwiftValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SpecVolumesVolumeSourcePublicSwiftValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SpecVolumesVolumeSourcePublicSwiftValue Attribute Value",
				"While creating a SpecVolumesVolumeSourcePublicSwiftValue value, a missing attribute value was detected. "+
					"A SpecVolumesVolumeSourcePublicSwiftValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpecVolumesVolumeSourcePublicSwiftValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SpecVolumesVolumeSourcePublicSwiftValue Attribute Type",
				"While creating a SpecVolumesVolumeSourcePublicSwiftValue value, an invalid attribute value was detected. "+
					"A SpecVolumesVolumeSourcePublicSwiftValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpecVolumesVolumeSourcePublicSwiftValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SpecVolumesVolumeSourcePublicSwiftValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SpecVolumesVolumeSourcePublicSwiftValue Attribute Value",
				"While creating a SpecVolumesVolumeSourcePublicSwiftValue value, an extra attribute value was detected. "+
					"A SpecVolumesVolumeSourcePublicSwiftValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SpecVolumesVolumeSourcePublicSwiftValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSpecVolumesVolumeSourcePublicSwiftValueUnknown(), diags
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return NewSpecVolumesVolumeSourcePublicSwiftValueUnknown(), diags
	}

	urlVal, ok := urlAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be ovhtypes.TfStringValue, was: %T`, urlAttribute))
	}

	if diags.HasError() {
		return NewSpecVolumesVolumeSourcePublicSwiftValueUnknown(), diags
	}

	return SpecVolumesVolumeSourcePublicSwiftValue{
		Url:   urlVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewSpecVolumesVolumeSourcePublicSwiftValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SpecVolumesVolumeSourcePublicSwiftValue {
	object, diags := NewSpecVolumesVolumeSourcePublicSwiftValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSpecVolumesVolumeSourcePublicSwiftValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SpecVolumesVolumeSourcePublicSwiftType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSpecVolumesVolumeSourcePublicSwiftValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSpecVolumesVolumeSourcePublicSwiftValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSpecVolumesVolumeSourcePublicSwiftValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSpecVolumesVolumeSourcePublicSwiftValueMust(SpecVolumesVolumeSourcePublicSwiftValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SpecVolumesVolumeSourcePublicSwiftType) ValueType(ctx context.Context) attr.Value {
	return SpecVolumesVolumeSourcePublicSwiftValue{}
}

var _ basetypes.ObjectValuable = SpecVolumesVolumeSourcePublicSwiftValue{}

type SpecVolumesVolumeSourcePublicSwiftValue struct {
	Url   ovhtypes.TfStringValue `tfsdk:"url" json:"url"`
	state attr.ValueState
}

func (v *SpecVolumesVolumeSourcePublicSwiftValue) UnmarshalJSON(data []byte) error {
	type JsonSpecVolumesVolumeSourcePublicSwiftValue SpecVolumesVolumeSourcePublicSwiftValue

	var tmp JsonSpecVolumesVolumeSourcePublicSwiftValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.Url = tmp.Url

	v.state = attr.ValueStateKnown

	return nil
}

func (v *SpecVolumesVolumeSourcePublicSwiftValue) MergeWith(other *SpecVolumesVolumeSourcePublicSwiftValue) {

	if (v.Url.IsUnknown() || v.Url.IsNull()) && !other.Url.IsUnknown() {
		v.Url = other.Url
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v SpecVolumesVolumeSourcePublicSwiftValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"url": v.Url,
	}
}
func (v SpecVolumesVolumeSourcePublicSwiftValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["url"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Url.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["url"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SpecVolumesVolumeSourcePublicSwiftValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SpecVolumesVolumeSourcePublicSwiftValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SpecVolumesVolumeSourcePublicSwiftValue) String() string {
	return "SpecVolumesVolumeSourcePublicSwiftValue"
}

func (v SpecVolumesVolumeSourcePublicSwiftValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"url": ovhtypes.TfStringType{},
		},
		map[string]attr.Value{
			"url": v.Url,
		})

	return objVal, diags
}

func (v SpecVolumesVolumeSourcePublicSwiftValue) Equal(o attr.Value) bool {
	other, ok := o.(SpecVolumesVolumeSourcePublicSwiftValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Url.Equal(other.Url) {
		return false
	}

	return true
}

func (v SpecVolumesVolumeSourcePublicSwiftValue) Type(ctx context.Context) attr.Type {
	return SpecVolumesVolumeSourcePublicSwiftType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SpecVolumesVolumeSourcePublicSwiftValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"url": ovhtypes.TfStringType{},
	}
}

var _ basetypes.ObjectTypable = SpecVolumesVolumeSourceStandaloneType{}

type SpecVolumesVolumeSourceStandaloneType struct {
	basetypes.ObjectType
}

func (t SpecVolumesVolumeSourceStandaloneType) Equal(o attr.Type) bool {
	other, ok := o.(SpecVolumesVolumeSourceStandaloneType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SpecVolumesVolumeSourceStandaloneType) String() string {
	return "SpecVolumesVolumeSourceStandaloneType"
}

func (t SpecVolumesVolumeSourceStandaloneType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be ovhtypes.TfStringValue, was: %T`, nameAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SpecVolumesVolumeSourceStandaloneValue{
		Name:  nameVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewSpecVolumesVolumeSourceStandaloneValueNull() SpecVolumesVolumeSourceStandaloneValue {
	return SpecVolumesVolumeSourceStandaloneValue{
		state: attr.ValueStateNull,
	}
}

func NewSpecVolumesVolumeSourceStandaloneValueUnknown() SpecVolumesVolumeSourceStandaloneValue {
	return SpecVolumesVolumeSourceStandaloneValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSpecVolumesVolumeSourceStandaloneValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SpecVolumesVolumeSourceStandaloneValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SpecVolumesVolumeSourceStandaloneValue Attribute Value",
				"While creating a SpecVolumesVolumeSourceStandaloneValue value, a missing attribute value was detected. "+
					"A SpecVolumesVolumeSourceStandaloneValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpecVolumesVolumeSourceStandaloneValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SpecVolumesVolumeSourceStandaloneValue Attribute Type",
				"While creating a SpecVolumesVolumeSourceStandaloneValue value, an invalid attribute value was detected. "+
					"A SpecVolumesVolumeSourceStandaloneValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpecVolumesVolumeSourceStandaloneValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SpecVolumesVolumeSourceStandaloneValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SpecVolumesVolumeSourceStandaloneValue Attribute Value",
				"While creating a SpecVolumesVolumeSourceStandaloneValue value, an extra attribute value was detected. "+
					"A SpecVolumesVolumeSourceStandaloneValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SpecVolumesVolumeSourceStandaloneValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSpecVolumesVolumeSourceStandaloneValueUnknown(), diags
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewSpecVolumesVolumeSourceStandaloneValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be ovhtypes.TfStringValue, was: %T`, nameAttribute))
	}

	if diags.HasError() {
		return NewSpecVolumesVolumeSourceStandaloneValueUnknown(), diags
	}

	return SpecVolumesVolumeSourceStandaloneValue{
		Name:  nameVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewSpecVolumesVolumeSourceStandaloneValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SpecVolumesVolumeSourceStandaloneValue {
	object, diags := NewSpecVolumesVolumeSourceStandaloneValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSpecVolumesVolumeSourceStandaloneValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SpecVolumesVolumeSourceStandaloneType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSpecVolumesVolumeSourceStandaloneValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSpecVolumesVolumeSourceStandaloneValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSpecVolumesVolumeSourceStandaloneValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSpecVolumesVolumeSourceStandaloneValueMust(SpecVolumesVolumeSourceStandaloneValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SpecVolumesVolumeSourceStandaloneType) ValueType(ctx context.Context) attr.Value {
	return SpecVolumesVolumeSourceStandaloneValue{}
}

var _ basetypes.ObjectValuable = SpecVolumesVolumeSourceStandaloneValue{}

type SpecVolumesVolumeSourceStandaloneValue struct {
	Name  ovhtypes.TfStringValue `tfsdk:"name" json:"name"`
	state attr.ValueState
}

func (v *SpecVolumesVolumeSourceStandaloneValue) UnmarshalJSON(data []byte) error {
	type JsonSpecVolumesVolumeSourceStandaloneValue SpecVolumesVolumeSourceStandaloneValue

	var tmp JsonSpecVolumesVolumeSourceStandaloneValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.Name = tmp.Name

	v.state = attr.ValueStateKnown

	return nil
}

func (v *SpecVolumesVolumeSourceStandaloneValue) MergeWith(other *SpecVolumesVolumeSourceStandaloneValue) {

	if (v.Name.IsUnknown() || v.Name.IsNull()) && !other.Name.IsUnknown() {
		v.Name = other.Name
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v SpecVolumesVolumeSourceStandaloneValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"name": v.Name,
	}
}
func (v SpecVolumesVolumeSourceStandaloneValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SpecVolumesVolumeSourceStandaloneValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SpecVolumesVolumeSourceStandaloneValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SpecVolumesVolumeSourceStandaloneValue) String() string {
	return "SpecVolumesVolumeSourceStandaloneValue"
}

func (v SpecVolumesVolumeSourceStandaloneValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"name": ovhtypes.TfStringType{},
		},
		map[string]attr.Value{
			"name": v.Name,
		})

	return objVal, diags
}

func (v SpecVolumesVolumeSourceStandaloneValue) Equal(o attr.Value) bool {
	other, ok := o.(SpecVolumesVolumeSourceStandaloneValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	return true
}

func (v SpecVolumesVolumeSourceStandaloneValue) Type(ctx context.Context) attr.Type {
	return SpecVolumesVolumeSourceStandaloneType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SpecVolumesVolumeSourceStandaloneValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"name": ovhtypes.TfStringType{},
	}
}

var _ basetypes.ObjectTypable = SpecVolumesVolumeTargetType{}

type SpecVolumesVolumeTargetType struct {
	basetypes.ObjectType
}

func (t SpecVolumesVolumeTargetType) Equal(o attr.Type) bool {
	other, ok := o.(SpecVolumesVolumeTargetType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SpecVolumesVolumeTargetType) String() string {
	return "SpecVolumesVolumeTargetType"
}

func (t SpecVolumesVolumeTargetType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	targetDataStoreAttribute, ok := attributes["target_data_store"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`target_data_store is missing from object`)

		return nil, diags
	}

	targetDataStoreVal, ok := targetDataStoreAttribute.(SpecVolumesVolumeTargetTargetDataStoreValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`target_data_store expected to be SpecVolumesVolumeTargetTargetDataStoreValue, was: %T`, targetDataStoreAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SpecVolumesVolumeTargetValue{
		TargetDataStore: targetDataStoreVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewSpecVolumesVolumeTargetValueNull() SpecVolumesVolumeTargetValue {
	return SpecVolumesVolumeTargetValue{
		state: attr.ValueStateNull,
	}
}

func NewSpecVolumesVolumeTargetValueUnknown() SpecVolumesVolumeTargetValue {
	return SpecVolumesVolumeTargetValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSpecVolumesVolumeTargetValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SpecVolumesVolumeTargetValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SpecVolumesVolumeTargetValue Attribute Value",
				"While creating a SpecVolumesVolumeTargetValue value, a missing attribute value was detected. "+
					"A SpecVolumesVolumeTargetValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpecVolumesVolumeTargetValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SpecVolumesVolumeTargetValue Attribute Type",
				"While creating a SpecVolumesVolumeTargetValue value, an invalid attribute value was detected. "+
					"A SpecVolumesVolumeTargetValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpecVolumesVolumeTargetValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SpecVolumesVolumeTargetValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SpecVolumesVolumeTargetValue Attribute Value",
				"While creating a SpecVolumesVolumeTargetValue value, an extra attribute value was detected. "+
					"A SpecVolumesVolumeTargetValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SpecVolumesVolumeTargetValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSpecVolumesVolumeTargetValueUnknown(), diags
	}

	targetDataStoreAttribute, ok := attributes["target_data_store"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`target_data_store is missing from object`)

		return NewSpecVolumesVolumeTargetValueUnknown(), diags
	}

	targetDataStoreVal, ok := targetDataStoreAttribute.(SpecVolumesVolumeTargetTargetDataStoreValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`target_data_store expected to be SpecVolumesVolumeTargetTargetDataStoreValue, was: %T`, targetDataStoreAttribute))
	}

	if diags.HasError() {
		return NewSpecVolumesVolumeTargetValueUnknown(), diags
	}

	return SpecVolumesVolumeTargetValue{
		TargetDataStore: targetDataStoreVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewSpecVolumesVolumeTargetValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SpecVolumesVolumeTargetValue {
	object, diags := NewSpecVolumesVolumeTargetValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSpecVolumesVolumeTargetValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SpecVolumesVolumeTargetType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSpecVolumesVolumeTargetValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSpecVolumesVolumeTargetValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSpecVolumesVolumeTargetValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSpecVolumesVolumeTargetValueMust(SpecVolumesVolumeTargetValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SpecVolumesVolumeTargetType) ValueType(ctx context.Context) attr.Value {
	return SpecVolumesVolumeTargetValue{}
}

var _ basetypes.ObjectValuable = SpecVolumesVolumeTargetValue{}

type SpecVolumesVolumeTargetValue struct {
	TargetDataStore SpecVolumesVolumeTargetTargetDataStoreValue `tfsdk:"target_data_store" json:"targetDataStore"`
	state           attr.ValueState
}

func (v *SpecVolumesVolumeTargetValue) UnmarshalJSON(data []byte) error {
	type JsonSpecVolumesVolumeTargetValue SpecVolumesVolumeTargetValue

	var tmp JsonSpecVolumesVolumeTargetValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.TargetDataStore = tmp.TargetDataStore

	v.state = attr.ValueStateKnown

	return nil
}

func (v *SpecVolumesVolumeTargetValue) MergeWith(other *SpecVolumesVolumeTargetValue) {

	if v.TargetDataStore.IsUnknown() && !other.TargetDataStore.IsUnknown() {
		v.TargetDataStore = other.TargetDataStore
	} else if !other.TargetDataStore.IsUnknown() {
		v.TargetDataStore.MergeWith(&other.TargetDataStore)
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v SpecVolumesVolumeTargetValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"targetDataStore": v.TargetDataStore,
	}
}
func (v SpecVolumesVolumeTargetValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["target_data_store"] = basetypes.ObjectType{
		AttrTypes: SpecVolumesVolumeTargetTargetDataStoreValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.TargetDataStore.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["target_data_store"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SpecVolumesVolumeTargetValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SpecVolumesVolumeTargetValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SpecVolumesVolumeTargetValue) String() string {
	return "SpecVolumesVolumeTargetValue"
}

func (v SpecVolumesVolumeTargetValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"target_data_store": SpecVolumesVolumeTargetTargetDataStoreType{
				basetypes.ObjectType{
					AttrTypes: SpecVolumesVolumeTargetTargetDataStoreValue{}.AttributeTypes(ctx),
				},
			},
		},
		map[string]attr.Value{
			"target_data_store": v.TargetDataStore,
		})

	return objVal, diags
}

func (v SpecVolumesVolumeTargetValue) Equal(o attr.Value) bool {
	other, ok := o.(SpecVolumesVolumeTargetValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.TargetDataStore.Equal(other.TargetDataStore) {
		return false
	}

	return true
}

func (v SpecVolumesVolumeTargetValue) Type(ctx context.Context) attr.Type {
	return SpecVolumesVolumeTargetType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SpecVolumesVolumeTargetValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"target_data_store": SpecVolumesVolumeTargetTargetDataStoreValue{}.Type(ctx),
	}
}

var _ basetypes.ObjectTypable = SpecVolumesVolumeTargetTargetDataStoreType{}

type SpecVolumesVolumeTargetTargetDataStoreType struct {
	basetypes.ObjectType
}

func (t SpecVolumesVolumeTargetTargetDataStoreType) Equal(o attr.Type) bool {
	other, ok := o.(SpecVolumesVolumeTargetTargetDataStoreType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SpecVolumesVolumeTargetTargetDataStoreType) String() string {
	return "SpecVolumesVolumeTargetTargetDataStoreType"
}

func (t SpecVolumesVolumeTargetTargetDataStoreType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	aliasAttribute, ok := attributes["alias"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`alias is missing from object`)

		return nil, diags
	}

	aliasVal, ok := aliasAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`alias expected to be ovhtypes.TfStringValue, was: %T`, aliasAttribute))
	}

	archiveAttribute, ok := attributes["archive"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`archive is missing from object`)

		return nil, diags
	}

	archiveVal, ok := archiveAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`archive expected to be ovhtypes.TfStringValue, was: %T`, archiveAttribute))
	}

	containerAttribute, ok := attributes["container"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`container is missing from object`)

		return nil, diags
	}

	containerVal, ok := containerAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`container expected to be ovhtypes.TfStringValue, was: %T`, containerAttribute))
	}

	internalAttribute, ok := attributes["internal"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`internal is missing from object`)

		return nil, diags
	}

	internalVal, ok := internalAttribute.(ovhtypes.TfBoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`internal expected to be ovhtypes.TfBoolValue, was: %T`, internalAttribute))
	}

	prefixAttribute, ok := attributes["prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix is missing from object`)

		return nil, diags
	}

	prefixVal, ok := prefixAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix expected to be ovhtypes.TfStringValue, was: %T`, prefixAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SpecVolumesVolumeTargetTargetDataStoreValue{
		Alias:     aliasVal,
		Archive:   archiveVal,
		Container: containerVal,
		Internal:  internalVal,
		Prefix:    prefixVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewSpecVolumesVolumeTargetTargetDataStoreValueNull() SpecVolumesVolumeTargetTargetDataStoreValue {
	return SpecVolumesVolumeTargetTargetDataStoreValue{
		state: attr.ValueStateNull,
	}
}

func NewSpecVolumesVolumeTargetTargetDataStoreValueUnknown() SpecVolumesVolumeTargetTargetDataStoreValue {
	return SpecVolumesVolumeTargetTargetDataStoreValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSpecVolumesVolumeTargetTargetDataStoreValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SpecVolumesVolumeTargetTargetDataStoreValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SpecVolumesVolumeTargetTargetDataStoreValue Attribute Value",
				"While creating a SpecVolumesVolumeTargetTargetDataStoreValue value, a missing attribute value was detected. "+
					"A SpecVolumesVolumeTargetTargetDataStoreValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpecVolumesVolumeTargetTargetDataStoreValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SpecVolumesVolumeTargetTargetDataStoreValue Attribute Type",
				"While creating a SpecVolumesVolumeTargetTargetDataStoreValue value, an invalid attribute value was detected. "+
					"A SpecVolumesVolumeTargetTargetDataStoreValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpecVolumesVolumeTargetTargetDataStoreValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SpecVolumesVolumeTargetTargetDataStoreValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SpecVolumesVolumeTargetTargetDataStoreValue Attribute Value",
				"While creating a SpecVolumesVolumeTargetTargetDataStoreValue value, an extra attribute value was detected. "+
					"A SpecVolumesVolumeTargetTargetDataStoreValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SpecVolumesVolumeTargetTargetDataStoreValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSpecVolumesVolumeTargetTargetDataStoreValueUnknown(), diags
	}

	aliasAttribute, ok := attributes["alias"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`alias is missing from object`)

		return NewSpecVolumesVolumeTargetTargetDataStoreValueUnknown(), diags
	}

	aliasVal, ok := aliasAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`alias expected to be ovhtypes.TfStringValue, was: %T`, aliasAttribute))
	}

	archiveAttribute, ok := attributes["archive"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`archive is missing from object`)

		return NewSpecVolumesVolumeTargetTargetDataStoreValueUnknown(), diags
	}

	archiveVal, ok := archiveAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`archive expected to be ovhtypes.TfStringValue, was: %T`, archiveAttribute))
	}

	containerAttribute, ok := attributes["container"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`container is missing from object`)

		return NewSpecVolumesVolumeTargetTargetDataStoreValueUnknown(), diags
	}

	containerVal, ok := containerAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`container expected to be ovhtypes.TfStringValue, was: %T`, containerAttribute))
	}

	internalAttribute, ok := attributes["internal"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`internal is missing from object`)

		return NewSpecVolumesVolumeTargetTargetDataStoreValueUnknown(), diags
	}

	internalVal, ok := internalAttribute.(ovhtypes.TfBoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`internal expected to be ovhtypes.TfBoolValue, was: %T`, internalAttribute))
	}

	prefixAttribute, ok := attributes["prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix is missing from object`)

		return NewSpecVolumesVolumeTargetTargetDataStoreValueUnknown(), diags
	}

	prefixVal, ok := prefixAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix expected to be ovhtypes.TfStringValue, was: %T`, prefixAttribute))
	}

	if diags.HasError() {
		return NewSpecVolumesVolumeTargetTargetDataStoreValueUnknown(), diags
	}

	return SpecVolumesVolumeTargetTargetDataStoreValue{
		Alias:     aliasVal,
		Archive:   archiveVal,
		Container: containerVal,
		Internal:  internalVal,
		Prefix:    prefixVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewSpecVolumesVolumeTargetTargetDataStoreValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SpecVolumesVolumeTargetTargetDataStoreValue {
	object, diags := NewSpecVolumesVolumeTargetTargetDataStoreValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSpecVolumesVolumeTargetTargetDataStoreValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SpecVolumesVolumeTargetTargetDataStoreType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSpecVolumesVolumeTargetTargetDataStoreValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSpecVolumesVolumeTargetTargetDataStoreValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSpecVolumesVolumeTargetTargetDataStoreValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSpecVolumesVolumeTargetTargetDataStoreValueMust(SpecVolumesVolumeTargetTargetDataStoreValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SpecVolumesVolumeTargetTargetDataStoreType) ValueType(ctx context.Context) attr.Value {
	return SpecVolumesVolumeTargetTargetDataStoreValue{}
}

var _ basetypes.ObjectValuable = SpecVolumesVolumeTargetTargetDataStoreValue{}

type SpecVolumesVolumeTargetTargetDataStoreValue struct {
	Alias     ovhtypes.TfStringValue `tfsdk:"alias" json:"alias"`
	Archive   ovhtypes.TfStringValue `tfsdk:"archive" json:"archive"`
	Container ovhtypes.TfStringValue `tfsdk:"container" json:"container"`
	Internal  ovhtypes.TfBoolValue   `tfsdk:"internal" json:"internal"`
	Prefix    ovhtypes.TfStringValue `tfsdk:"prefix" json:"prefix"`
	state     attr.ValueState
}

func (v SpecVolumesVolumeTargetTargetDataStoreValue) ToCreate() *SpecVolumesVolumeTargetTargetDataStoreValue {
	res := &SpecVolumesVolumeTargetTargetDataStoreValue{}

	if !v.Internal.IsNull() {
		res.Internal = v.Internal
	}

	res.state = attr.ValueStateKnown

	return res
}

func (v SpecVolumesVolumeTargetTargetDataStoreValue) MarshalJSON() ([]byte, error) {
	toMarshal := map[string]any{}
	if !v.Internal.IsNull() && !v.Internal.IsUnknown() {
		toMarshal["internal"] = v.Internal
	}

	return json.Marshal(toMarshal)
}

func (v *SpecVolumesVolumeTargetTargetDataStoreValue) UnmarshalJSON(data []byte) error {
	type JsonSpecVolumesVolumeTargetTargetDataStoreValue SpecVolumesVolumeTargetTargetDataStoreValue

	var tmp JsonSpecVolumesVolumeTargetTargetDataStoreValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.Alias = tmp.Alias
	v.Archive = tmp.Archive
	v.Container = tmp.Container
	v.Internal = tmp.Internal
	v.Prefix = tmp.Prefix

	v.state = attr.ValueStateKnown

	return nil
}

func (v *SpecVolumesVolumeTargetTargetDataStoreValue) MergeWith(other *SpecVolumesVolumeTargetTargetDataStoreValue) {

	if (v.Alias.IsUnknown() || v.Alias.IsNull()) && !other.Alias.IsUnknown() {
		v.Alias = other.Alias
	}

	if (v.Archive.IsUnknown() || v.Archive.IsNull()) && !other.Archive.IsUnknown() {
		v.Archive = other.Archive
	}

	if (v.Container.IsUnknown() || v.Container.IsNull()) && !other.Container.IsUnknown() {
		v.Container = other.Container
	}

	if (v.Internal.IsUnknown() || v.Internal.IsNull()) && !other.Internal.IsUnknown() {
		v.Internal = other.Internal
	}

	if (v.Prefix.IsUnknown() || v.Prefix.IsNull()) && !other.Prefix.IsUnknown() {
		v.Prefix = other.Prefix
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v SpecVolumesVolumeTargetTargetDataStoreValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"alias":     v.Alias,
		"archive":   v.Archive,
		"container": v.Container,
		"internal":  v.Internal,
		"prefix":    v.Prefix,
	}
}
func (v SpecVolumesVolumeTargetTargetDataStoreValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["alias"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["archive"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["container"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["internal"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["prefix"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.Alias.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["alias"] = val

		val, err = v.Archive.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["archive"] = val

		val, err = v.Container.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["container"] = val

		val, err = v.Internal.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["internal"] = val

		val, err = v.Prefix.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["prefix"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SpecVolumesVolumeTargetTargetDataStoreValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SpecVolumesVolumeTargetTargetDataStoreValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SpecVolumesVolumeTargetTargetDataStoreValue) String() string {
	return "SpecVolumesVolumeTargetTargetDataStoreValue"
}

func (v SpecVolumesVolumeTargetTargetDataStoreValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"alias":     ovhtypes.TfStringType{},
			"archive":   ovhtypes.TfStringType{},
			"container": ovhtypes.TfStringType{},
			"internal":  ovhtypes.TfBoolType{},
			"prefix":    ovhtypes.TfStringType{},
		},
		map[string]attr.Value{
			"alias":     v.Alias,
			"archive":   v.Archive,
			"container": v.Container,
			"internal":  v.Internal,
			"prefix":    v.Prefix,
		})

	return objVal, diags
}

func (v SpecVolumesVolumeTargetTargetDataStoreValue) Equal(o attr.Value) bool {
	other, ok := o.(SpecVolumesVolumeTargetTargetDataStoreValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Alias.Equal(other.Alias) {
		return false
	}

	if !v.Archive.Equal(other.Archive) {
		return false
	}

	if !v.Container.Equal(other.Container) {
		return false
	}

	if !v.Internal.Equal(other.Internal) {
		return false
	}

	if !v.Prefix.Equal(other.Prefix) {
		return false
	}

	return true
}

func (v SpecVolumesVolumeTargetTargetDataStoreValue) Type(ctx context.Context) attr.Type {
	return SpecVolumesVolumeTargetTargetDataStoreType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SpecVolumesVolumeTargetTargetDataStoreValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"alias":     ovhtypes.TfStringType{},
		"archive":   ovhtypes.TfStringType{},
		"container": ovhtypes.TfStringType{},
		"internal":  ovhtypes.TfBoolType{},
		"prefix":    ovhtypes.TfStringType{},
	}
}

var _ basetypes.ObjectTypable = StatusType{}

type StatusType struct {
	basetypes.ObjectType
}

func (t StatusType) Equal(o attr.Type) bool {
	other, ok := o.(StatusType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t StatusType) String() string {
	return "StatusType"
}

func (t StatusType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	availableReplicasAttribute, ok := attributes["available_replicas"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`available_replicas is missing from object`)

		return nil, diags
	}

	availableReplicasVal, ok := availableReplicasAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`available_replicas expected to be ovhtypes.TfInt64Value, was: %T`, availableReplicasAttribute))
	}

	dataSyncAttribute, ok := attributes["data_sync"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`data_sync is missing from object`)

		return nil, diags
	}

	dataSyncVal, ok := dataSyncAttribute.(ovhtypes.TfListNestedValue[StatusDataSyncValue])

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`data_sync expected to be ovhtypes.TfListNestedValue[StatusDataSyncValue], was: %T`, dataSyncAttribute))
	}

	grpcAddressAttribute, ok := attributes["grpc_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`grpc_address is missing from object`)

		return nil, diags
	}

	grpcAddressVal, ok := grpcAddressAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`grpc_address expected to be ovhtypes.TfStringValue, was: %T`, grpcAddressAttribute))
	}

	historyAttribute, ok := attributes["history"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`history is missing from object`)

		return nil, diags
	}

	historyVal, ok := historyAttribute.(ovhtypes.TfListNestedValue[StatusHistoryValue])

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`history expected to be ovhtypes.TfListNestedValue[StatusHistoryValue], was: %T`, historyAttribute))
	}

	infoAttribute, ok := attributes["info"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`info is missing from object`)

		return nil, diags
	}

	infoVal, ok := infoAttribute.(StatusInfoValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`info expected to be StatusInfoValue, was: %T`, infoAttribute))
	}

	infoUrlAttribute, ok := attributes["info_url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`info_url is missing from object`)

		return nil, diags
	}

	infoUrlVal, ok := infoUrlAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`info_url expected to be ovhtypes.TfStringValue, was: %T`, infoUrlAttribute))
	}

	internalServiceIpAttribute, ok := attributes["internal_service_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`internal_service_ip is missing from object`)

		return nil, diags
	}

	internalServiceIpVal, ok := internalServiceIpAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`internal_service_ip expected to be ovhtypes.TfStringValue, was: %T`, internalServiceIpAttribute))
	}

	lastTransitionDateAttribute, ok := attributes["last_transition_date"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`last_transition_date is missing from object`)

		return nil, diags
	}

	lastTransitionDateVal, ok := lastTransitionDateAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`last_transition_date expected to be ovhtypes.TfStringValue, was: %T`, lastTransitionDateAttribute))
	}

	monitoringUrlAttribute, ok := attributes["monitoring_url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`monitoring_url is missing from object`)

		return nil, diags
	}

	monitoringUrlVal, ok := monitoringUrlAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`monitoring_url expected to be ovhtypes.TfStringValue, was: %T`, monitoringUrlAttribute))
	}

	stateAttribute, ok := attributes["state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`state is missing from object`)

		return nil, diags
	}

	stateVal, ok := stateAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`state expected to be ovhtypes.TfStringValue, was: %T`, stateAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return nil, diags
	}

	urlVal, ok := urlAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be ovhtypes.TfStringValue, was: %T`, urlAttribute))
	}

	volumesAttribute, ok := attributes["volumes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volumes is missing from object`)

		return nil, diags
	}

	volumesVal, ok := volumesAttribute.(ovhtypes.TfListNestedValue[StatusVolumesValue])

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volumes expected to be ovhtypes.TfListNestedValue[StatusVolumesValue], was: %T`, volumesAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return StatusValue{
		AvailableReplicas:  availableReplicasVal,
		DataSync:           dataSyncVal,
		GrpcAddress:        grpcAddressVal,
		History:            historyVal,
		Info:               infoVal,
		InfoUrl:            infoUrlVal,
		InternalServiceIp:  internalServiceIpVal,
		LastTransitionDate: lastTransitionDateVal,
		MonitoringUrl:      monitoringUrlVal,
		State:              stateVal,
		Url:                urlVal,
		Volumes:            volumesVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewStatusValueNull() StatusValue {
	return StatusValue{
		state: attr.ValueStateNull,
	}
}

func NewStatusValueUnknown() StatusValue {
	return StatusValue{
		state: attr.ValueStateUnknown,
	}
}

func NewStatusValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (StatusValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing StatusValue Attribute Value",
				"While creating a StatusValue value, a missing attribute value was detected. "+
					"A StatusValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StatusValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid StatusValue Attribute Type",
				"While creating a StatusValue value, an invalid attribute value was detected. "+
					"A StatusValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StatusValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("StatusValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra StatusValue Attribute Value",
				"While creating a StatusValue value, an extra attribute value was detected. "+
					"A StatusValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra StatusValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewStatusValueUnknown(), diags
	}

	availableReplicasAttribute, ok := attributes["available_replicas"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`available_replicas is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	availableReplicasVal, ok := availableReplicasAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`available_replicas expected to be ovhtypes.TfInt64Value, was: %T`, availableReplicasAttribute))
	}

	dataSyncAttribute, ok := attributes["data_sync"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`data_sync is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	dataSyncVal, ok := dataSyncAttribute.(ovhtypes.TfListNestedValue[StatusDataSyncValue])

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`data_sync expected to be ovhtypes.TfListNestedValue[StatusDataSyncValue], was: %T`, dataSyncAttribute))
	}

	grpcAddressAttribute, ok := attributes["grpc_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`grpc_address is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	grpcAddressVal, ok := grpcAddressAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`grpc_address expected to be ovhtypes.TfStringValue, was: %T`, grpcAddressAttribute))
	}

	historyAttribute, ok := attributes["history"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`history is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	historyVal, ok := historyAttribute.(ovhtypes.TfListNestedValue[StatusHistoryValue])

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`history expected to be ovhtypes.TfListNestedValue[StatusHistoryValue], was: %T`, historyAttribute))
	}

	infoAttribute, ok := attributes["info"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`info is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	infoVal, ok := infoAttribute.(StatusInfoValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`info expected to be StatusInfoValue, was: %T`, infoAttribute))
	}

	infoUrlAttribute, ok := attributes["info_url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`info_url is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	infoUrlVal, ok := infoUrlAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`info_url expected to be ovhtypes.TfStringValue, was: %T`, infoUrlAttribute))
	}

	internalServiceIpAttribute, ok := attributes["internal_service_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`internal_service_ip is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	internalServiceIpVal, ok := internalServiceIpAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`internal_service_ip expected to be ovhtypes.TfStringValue, was: %T`, internalServiceIpAttribute))
	}

	lastTransitionDateAttribute, ok := attributes["last_transition_date"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`last_transition_date is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	lastTransitionDateVal, ok := lastTransitionDateAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`last_transition_date expected to be ovhtypes.TfStringValue, was: %T`, lastTransitionDateAttribute))
	}

	monitoringUrlAttribute, ok := attributes["monitoring_url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`monitoring_url is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	monitoringUrlVal, ok := monitoringUrlAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`monitoring_url expected to be ovhtypes.TfStringValue, was: %T`, monitoringUrlAttribute))
	}

	stateAttribute, ok := attributes["state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`state is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	stateVal, ok := stateAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`state expected to be ovhtypes.TfStringValue, was: %T`, stateAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	urlVal, ok := urlAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be ovhtypes.TfStringValue, was: %T`, urlAttribute))
	}

	volumesAttribute, ok := attributes["volumes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volumes is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	volumesVal, ok := volumesAttribute.(ovhtypes.TfListNestedValue[StatusVolumesValue])

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volumes expected to be ovhtypes.TfListNestedValue[StatusVolumesValue], was: %T`, volumesAttribute))
	}

	if diags.HasError() {
		return NewStatusValueUnknown(), diags
	}

	return StatusValue{
		AvailableReplicas:  availableReplicasVal,
		DataSync:           dataSyncVal,
		GrpcAddress:        grpcAddressVal,
		History:            historyVal,
		Info:               infoVal,
		InfoUrl:            infoUrlVal,
		InternalServiceIp:  internalServiceIpVal,
		LastTransitionDate: lastTransitionDateVal,
		MonitoringUrl:      monitoringUrlVal,
		State:              stateVal,
		Url:                urlVal,
		Volumes:            volumesVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewStatusValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) StatusValue {
	object, diags := NewStatusValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewStatusValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t StatusType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewStatusValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewStatusValueUnknown(), nil
	}

	if in.IsNull() {
		return NewStatusValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewStatusValueMust(StatusValue{}.AttributeTypes(ctx), attributes), nil
}

func (t StatusType) ValueType(ctx context.Context) attr.Value {
	return StatusValue{}
}

var _ basetypes.ObjectValuable = StatusValue{}

type StatusValue struct {
	AvailableReplicas  ovhtypes.TfInt64Value                           `tfsdk:"available_replicas" json:"availableReplicas"`
	DataSync           ovhtypes.TfListNestedValue[StatusDataSyncValue] `tfsdk:"data_sync" json:"dataSync"`
	GrpcAddress        ovhtypes.TfStringValue                          `tfsdk:"grpc_address" json:"grpcAddress"`
	History            ovhtypes.TfListNestedValue[StatusHistoryValue]  `tfsdk:"history" json:"history"`
	Info               StatusInfoValue                                 `tfsdk:"info" json:"info"`
	InfoUrl            ovhtypes.TfStringValue                          `tfsdk:"info_url" json:"infoUrl"`
	InternalServiceIp  ovhtypes.TfStringValue                          `tfsdk:"internal_service_ip" json:"internalServiceIp"`
	LastTransitionDate ovhtypes.TfStringValue                          `tfsdk:"last_transition_date" json:"lastTransitionDate"`
	MonitoringUrl      ovhtypes.TfStringValue                          `tfsdk:"monitoring_url" json:"monitoringUrl"`
	State              ovhtypes.TfStringValue                          `tfsdk:"state" json:"state"`
	Url                ovhtypes.TfStringValue                          `tfsdk:"url" json:"url"`
	Volumes            ovhtypes.TfListNestedValue[StatusVolumesValue]  `tfsdk:"volumes" json:"volumes"`
	state              attr.ValueState
}

func (v *StatusValue) UnmarshalJSON(data []byte) error {
	type JsonStatusValue StatusValue

	var tmp JsonStatusValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.AvailableReplicas = tmp.AvailableReplicas
	v.DataSync = tmp.DataSync
	v.GrpcAddress = tmp.GrpcAddress
	v.History = tmp.History
	v.Info = tmp.Info
	v.InfoUrl = tmp.InfoUrl
	v.InternalServiceIp = tmp.InternalServiceIp
	v.LastTransitionDate = tmp.LastTransitionDate
	v.MonitoringUrl = tmp.MonitoringUrl
	v.State = tmp.State
	v.Url = tmp.Url
	v.Volumes = tmp.Volumes

	v.state = attr.ValueStateKnown

	return nil
}

func (v *StatusValue) MergeWith(other *StatusValue) {

	if (v.AvailableReplicas.IsUnknown() || v.AvailableReplicas.IsNull()) && !other.AvailableReplicas.IsUnknown() {
		v.AvailableReplicas = other.AvailableReplicas
	}

	if (v.DataSync.IsUnknown() || v.DataSync.IsNull()) && !other.DataSync.IsUnknown() {
		v.DataSync = other.DataSync
	} else if !other.DataSync.IsUnknown() {
		newSlice := make([]attr.Value, 0)
		elems := v.DataSync.Elements()
		newElems := other.DataSync.Elements()

		if len(elems) != len(newElems) {
			v.DataSync = other.DataSync
		} else {
			for idx, e := range elems {
				tmp := e.(StatusDataSyncValue)
				tmp2 := newElems[idx].(StatusDataSyncValue)
				tmp.MergeWith(&tmp2)
				newSlice = append(newSlice, tmp)
			}

			v.DataSync = ovhtypes.TfListNestedValue[StatusDataSyncValue]{
				ListValue: basetypes.NewListValueMust(StatusDataSyncValue{}.Type(context.Background()), newSlice),
			}
		}
	}

	if (v.GrpcAddress.IsUnknown() || v.GrpcAddress.IsNull()) && !other.GrpcAddress.IsUnknown() {
		v.GrpcAddress = other.GrpcAddress
	}

	if (v.History.IsUnknown() || v.History.IsNull()) && !other.History.IsUnknown() {
		v.History = other.History
	} else if !other.History.IsUnknown() {
		newSlice := make([]attr.Value, 0)
		elems := v.History.Elements()
		newElems := other.History.Elements()

		if len(elems) != len(newElems) {
			v.History = other.History
		} else {
			for idx, e := range elems {
				tmp := e.(StatusHistoryValue)
				tmp2 := newElems[idx].(StatusHistoryValue)
				tmp.MergeWith(&tmp2)
				newSlice = append(newSlice, tmp)
			}

			v.History = ovhtypes.TfListNestedValue[StatusHistoryValue]{
				ListValue: basetypes.NewListValueMust(StatusHistoryValue{}.Type(context.Background()), newSlice),
			}
		}
	}

	if v.Info.IsUnknown() && !other.Info.IsUnknown() {
		v.Info = other.Info
	} else if !other.Info.IsUnknown() {
		v.Info.MergeWith(&other.Info)
	}

	if (v.InfoUrl.IsUnknown() || v.InfoUrl.IsNull()) && !other.InfoUrl.IsUnknown() {
		v.InfoUrl = other.InfoUrl
	}

	if (v.InternalServiceIp.IsUnknown() || v.InternalServiceIp.IsNull()) && !other.InternalServiceIp.IsUnknown() {
		v.InternalServiceIp = other.InternalServiceIp
	}

	if (v.LastTransitionDate.IsUnknown() || v.LastTransitionDate.IsNull()) && !other.LastTransitionDate.IsUnknown() {
		v.LastTransitionDate = other.LastTransitionDate
	}

	if (v.MonitoringUrl.IsUnknown() || v.MonitoringUrl.IsNull()) && !other.MonitoringUrl.IsUnknown() {
		v.MonitoringUrl = other.MonitoringUrl
	}

	if (v.State.IsUnknown() || v.State.IsNull()) && !other.State.IsUnknown() {
		v.State = other.State
	}

	if (v.Url.IsUnknown() || v.Url.IsNull()) && !other.Url.IsUnknown() {
		v.Url = other.Url
	}

	if (v.Volumes.IsUnknown() || v.Volumes.IsNull()) && !other.Volumes.IsUnknown() {
		v.Volumes = other.Volumes
	} else if !other.Volumes.IsUnknown() {
		newSlice := make([]attr.Value, 0)
		elems := v.Volumes.Elements()
		newElems := other.Volumes.Elements()

		if len(elems) != len(newElems) {
			v.Volumes = other.Volumes
		} else {
			for idx, e := range elems {
				tmp := e.(StatusVolumesValue)
				tmp2 := newElems[idx].(StatusVolumesValue)
				tmp.MergeWith(&tmp2)
				newSlice = append(newSlice, tmp)
			}

			v.Volumes = ovhtypes.TfListNestedValue[StatusVolumesValue]{
				ListValue: basetypes.NewListValueMust(StatusVolumesValue{}.Type(context.Background()), newSlice),
			}
		}
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v StatusValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"availableReplicas":  v.AvailableReplicas,
		"dataSync":           v.DataSync,
		"grpcAddress":        v.GrpcAddress,
		"history":            v.History,
		"info":               v.Info,
		"infoUrl":            v.InfoUrl,
		"internalServiceIp":  v.InternalServiceIp,
		"lastTransitionDate": v.LastTransitionDate,
		"monitoringUrl":      v.MonitoringUrl,
		"state":              v.State,
		"url":                v.Url,
		"volumes":            v.Volumes,
	}
}
func (v StatusValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 12)

	var val tftypes.Value
	var err error

	attrTypes["available_replicas"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["data_sync"] = basetypes.ListType{
		ElemType: StatusDataSyncValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["grpc_address"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["history"] = basetypes.ListType{
		ElemType: StatusHistoryValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["info"] = basetypes.ObjectType{
		AttrTypes: StatusInfoValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["info_url"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["internal_service_ip"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["last_transition_date"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["monitoring_url"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["state"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["url"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["volumes"] = basetypes.ListType{
		ElemType: StatusVolumesValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 12)

		val, err = v.AvailableReplicas.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["available_replicas"] = val

		val, err = v.DataSync.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["data_sync"] = val

		val, err = v.GrpcAddress.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["grpc_address"] = val

		val, err = v.History.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["history"] = val

		val, err = v.Info.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["info"] = val

		val, err = v.InfoUrl.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["info_url"] = val

		val, err = v.InternalServiceIp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["internal_service_ip"] = val

		val, err = v.LastTransitionDate.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["last_transition_date"] = val

		val, err = v.MonitoringUrl.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["monitoring_url"] = val

		val, err = v.State.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["state"] = val

		val, err = v.Url.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["url"] = val

		val, err = v.Volumes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["volumes"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v StatusValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v StatusValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v StatusValue) String() string {
	return "StatusValue"
}

func (v StatusValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"available_replicas": ovhtypes.TfInt64Type{},
			"data_sync":          ovhtypes.NewTfListNestedType[StatusDataSyncValue](ctx),
			"grpc_address":       ovhtypes.TfStringType{},
			"history":            ovhtypes.NewTfListNestedType[StatusHistoryValue](ctx),
			"info": StatusInfoType{
				basetypes.ObjectType{
					AttrTypes: StatusInfoValue{}.AttributeTypes(ctx),
				},
			},
			"info_url":             ovhtypes.TfStringType{},
			"internal_service_ip":  ovhtypes.TfStringType{},
			"last_transition_date": ovhtypes.TfStringType{},
			"monitoring_url":       ovhtypes.TfStringType{},
			"state":                ovhtypes.TfStringType{},
			"url":                  ovhtypes.TfStringType{},
			"volumes":              ovhtypes.NewTfListNestedType[StatusVolumesValue](ctx),
		},
		map[string]attr.Value{
			"available_replicas":   v.AvailableReplicas,
			"data_sync":            v.DataSync,
			"grpc_address":         v.GrpcAddress,
			"history":              v.History,
			"info":                 v.Info,
			"info_url":             v.InfoUrl,
			"internal_service_ip":  v.InternalServiceIp,
			"last_transition_date": v.LastTransitionDate,
			"monitoring_url":       v.MonitoringUrl,
			"state":                v.State,
			"url":                  v.Url,
			"volumes":              v.Volumes,
		})

	return objVal, diags
}

func (v StatusValue) Equal(o attr.Value) bool {
	other, ok := o.(StatusValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AvailableReplicas.Equal(other.AvailableReplicas) {
		return false
	}

	if !v.DataSync.Equal(other.DataSync) {
		return false
	}

	if !v.GrpcAddress.Equal(other.GrpcAddress) {
		return false
	}

	if !v.History.Equal(other.History) {
		return false
	}

	if !v.Info.Equal(other.Info) {
		return false
	}

	if !v.InfoUrl.Equal(other.InfoUrl) {
		return false
	}

	if !v.InternalServiceIp.Equal(other.InternalServiceIp) {
		return false
	}

	if !v.LastTransitionDate.Equal(other.LastTransitionDate) {
		return false
	}

	if !v.MonitoringUrl.Equal(other.MonitoringUrl) {
		return false
	}

	if !v.State.Equal(other.State) {
		return false
	}

	if !v.Url.Equal(other.Url) {
		return false
	}

	if !v.Volumes.Equal(other.Volumes) {
		return false
	}

	return true
}

func (v StatusValue) Type(ctx context.Context) attr.Type {
	return StatusType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v StatusValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"available_replicas":   ovhtypes.TfInt64Type{},
		"data_sync":            ovhtypes.NewTfListNestedType[StatusDataSyncValue](ctx),
		"grpc_address":         ovhtypes.TfStringType{},
		"history":              ovhtypes.NewTfListNestedType[StatusHistoryValue](ctx),
		"info":                 StatusInfoValue{}.Type(ctx),
		"info_url":             ovhtypes.TfStringType{},
		"internal_service_ip":  ovhtypes.TfStringType{},
		"last_transition_date": ovhtypes.TfStringType{},
		"monitoring_url":       ovhtypes.TfStringType{},
		"state":                ovhtypes.TfStringType{},
		"url":                  ovhtypes.TfStringType{},
		"volumes":              ovhtypes.NewTfListNestedType[StatusVolumesValue](ctx),
	}
}

var _ basetypes.ObjectTypable = StatusDataSyncType{}

type StatusDataSyncType struct {
	basetypes.ObjectType
}

func (t StatusDataSyncType) Equal(o attr.Type) bool {
	other, ok := o.(StatusDataSyncType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t StatusDataSyncType) String() string {
	return "StatusDataSyncType"
}

func (t StatusDataSyncType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return nil, diags
	}

	createdAtVal, ok := createdAtAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be ovhtypes.TfStringValue, was: %T`, createdAtAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be ovhtypes.TfStringValue, was: %T`, idAttribute))
	}

	specAttribute, ok := attributes["spec"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`spec is missing from object`)

		return nil, diags
	}

	specVal, ok := specAttribute.(StatusDataSyncSpecValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`spec expected to be StatusDataSyncSpecValue, was: %T`, specAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return nil, diags
	}

	statusVal, ok := statusAttribute.(StatusDataSyncStatusValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be StatusDataSyncStatusValue, was: %T`, statusAttribute))
	}

	updatedAtAttribute, ok := attributes["updated_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`updated_at is missing from object`)

		return nil, diags
	}

	updatedAtVal, ok := updatedAtAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`updated_at expected to be ovhtypes.TfStringValue, was: %T`, updatedAtAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return StatusDataSyncValue{
		CreatedAt: createdAtVal,
		Id:        idVal,
		Spec:      specVal,
		Status:    statusVal,
		UpdatedAt: updatedAtVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewStatusDataSyncValueNull() StatusDataSyncValue {
	return StatusDataSyncValue{
		state: attr.ValueStateNull,
	}
}

func NewStatusDataSyncValueUnknown() StatusDataSyncValue {
	return StatusDataSyncValue{
		state: attr.ValueStateUnknown,
	}
}

func NewStatusDataSyncValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (StatusDataSyncValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing StatusDataSyncValue Attribute Value",
				"While creating a StatusDataSyncValue value, a missing attribute value was detected. "+
					"A StatusDataSyncValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StatusDataSyncValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid StatusDataSyncValue Attribute Type",
				"While creating a StatusDataSyncValue value, an invalid attribute value was detected. "+
					"A StatusDataSyncValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StatusDataSyncValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("StatusDataSyncValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra StatusDataSyncValue Attribute Value",
				"While creating a StatusDataSyncValue value, an extra attribute value was detected. "+
					"A StatusDataSyncValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra StatusDataSyncValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewStatusDataSyncValueUnknown(), diags
	}

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return NewStatusDataSyncValueUnknown(), diags
	}

	createdAtVal, ok := createdAtAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be ovhtypes.TfStringValue, was: %T`, createdAtAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewStatusDataSyncValueUnknown(), diags
	}

	idVal, ok := idAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be ovhtypes.TfStringValue, was: %T`, idAttribute))
	}

	specAttribute, ok := attributes["spec"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`spec is missing from object`)

		return NewStatusDataSyncValueUnknown(), diags
	}

	specVal, ok := specAttribute.(StatusDataSyncSpecValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`spec expected to be StatusDataSyncSpecValue, was: %T`, specAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return NewStatusDataSyncValueUnknown(), diags
	}

	statusVal, ok := statusAttribute.(StatusDataSyncStatusValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be StatusDataSyncStatusValue, was: %T`, statusAttribute))
	}

	updatedAtAttribute, ok := attributes["updated_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`updated_at is missing from object`)

		return NewStatusDataSyncValueUnknown(), diags
	}

	updatedAtVal, ok := updatedAtAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`updated_at expected to be ovhtypes.TfStringValue, was: %T`, updatedAtAttribute))
	}

	if diags.HasError() {
		return NewStatusDataSyncValueUnknown(), diags
	}

	return StatusDataSyncValue{
		CreatedAt: createdAtVal,
		Id:        idVal,
		Spec:      specVal,
		Status:    statusVal,
		UpdatedAt: updatedAtVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewStatusDataSyncValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) StatusDataSyncValue {
	object, diags := NewStatusDataSyncValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewStatusDataSyncValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t StatusDataSyncType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewStatusDataSyncValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewStatusDataSyncValueUnknown(), nil
	}

	if in.IsNull() {
		return NewStatusDataSyncValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewStatusDataSyncValueMust(StatusDataSyncValue{}.AttributeTypes(ctx), attributes), nil
}

func (t StatusDataSyncType) ValueType(ctx context.Context) attr.Value {
	return StatusDataSyncValue{}
}

var _ basetypes.ObjectValuable = StatusDataSyncValue{}

type StatusDataSyncValue struct {
	CreatedAt ovhtypes.TfStringValue    `tfsdk:"created_at" json:"createdAt"`
	Id        ovhtypes.TfStringValue    `tfsdk:"id" json:"id"`
	Spec      StatusDataSyncSpecValue   `tfsdk:"spec" json:"spec"`
	Status    StatusDataSyncStatusValue `tfsdk:"status" json:"status"`
	UpdatedAt ovhtypes.TfStringValue    `tfsdk:"updated_at" json:"updatedAt"`
	state     attr.ValueState
}

func (v *StatusDataSyncValue) UnmarshalJSON(data []byte) error {
	type JsonStatusDataSyncValue StatusDataSyncValue

	var tmp JsonStatusDataSyncValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.CreatedAt = tmp.CreatedAt
	v.Id = tmp.Id
	v.Spec = tmp.Spec
	v.Status = tmp.Status
	v.UpdatedAt = tmp.UpdatedAt

	v.state = attr.ValueStateKnown

	return nil
}

func (v *StatusDataSyncValue) MergeWith(other *StatusDataSyncValue) {

	if (v.CreatedAt.IsUnknown() || v.CreatedAt.IsNull()) && !other.CreatedAt.IsUnknown() {
		v.CreatedAt = other.CreatedAt
	}

	if (v.Id.IsUnknown() || v.Id.IsNull()) && !other.Id.IsUnknown() {
		v.Id = other.Id
	}

	if v.Spec.IsUnknown() && !other.Spec.IsUnknown() {
		v.Spec = other.Spec
	} else if !other.Spec.IsUnknown() {
		v.Spec.MergeWith(&other.Spec)
	}

	if v.Status.IsUnknown() && !other.Status.IsUnknown() {
		v.Status = other.Status
	} else if !other.Status.IsUnknown() {
		v.Status.MergeWith(&other.Status)
	}

	if (v.UpdatedAt.IsUnknown() || v.UpdatedAt.IsNull()) && !other.UpdatedAt.IsUnknown() {
		v.UpdatedAt = other.UpdatedAt
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v StatusDataSyncValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"createdAt": v.CreatedAt,
		"id":        v.Id,
		"spec":      v.Spec,
		"status":    v.Status,
		"updatedAt": v.UpdatedAt,
	}
}
func (v StatusDataSyncValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["created_at"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["spec"] = basetypes.ObjectType{
		AttrTypes: StatusDataSyncSpecValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["status"] = basetypes.ObjectType{
		AttrTypes: StatusDataSyncStatusValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["updated_at"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.CreatedAt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["created_at"] = val

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.Spec.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["spec"] = val

		val, err = v.Status.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["status"] = val

		val, err = v.UpdatedAt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["updated_at"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v StatusDataSyncValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v StatusDataSyncValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v StatusDataSyncValue) String() string {
	return "StatusDataSyncValue"
}

func (v StatusDataSyncValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"created_at": ovhtypes.TfStringType{},
			"id":         ovhtypes.TfStringType{},
			"spec": StatusDataSyncSpecType{
				basetypes.ObjectType{
					AttrTypes: StatusDataSyncSpecValue{}.AttributeTypes(ctx),
				},
			},
			"status": StatusDataSyncStatusType{
				basetypes.ObjectType{
					AttrTypes: StatusDataSyncStatusValue{}.AttributeTypes(ctx),
				},
			},
			"updated_at": ovhtypes.TfStringType{},
		},
		map[string]attr.Value{
			"created_at": v.CreatedAt,
			"id":         v.Id,
			"spec":       v.Spec,
			"status":     v.Status,
			"updated_at": v.UpdatedAt,
		})

	return objVal, diags
}

func (v StatusDataSyncValue) Equal(o attr.Value) bool {
	other, ok := o.(StatusDataSyncValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.CreatedAt.Equal(other.CreatedAt) {
		return false
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.Spec.Equal(other.Spec) {
		return false
	}

	if !v.Status.Equal(other.Status) {
		return false
	}

	if !v.UpdatedAt.Equal(other.UpdatedAt) {
		return false
	}

	return true
}

func (v StatusDataSyncValue) Type(ctx context.Context) attr.Type {
	return StatusDataSyncType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v StatusDataSyncValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"created_at": ovhtypes.TfStringType{},
		"id":         ovhtypes.TfStringType{},
		"spec":       StatusDataSyncSpecValue{}.Type(ctx),
		"status":     StatusDataSyncStatusValue{}.Type(ctx),
		"updated_at": ovhtypes.TfStringType{},
	}
}

var _ basetypes.ObjectTypable = StatusDataSyncSpecType{}

type StatusDataSyncSpecType struct {
	basetypes.ObjectType
}

func (t StatusDataSyncSpecType) Equal(o attr.Type) bool {
	other, ok := o.(StatusDataSyncSpecType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t StatusDataSyncSpecType) String() string {
	return "StatusDataSyncSpecType"
}

func (t StatusDataSyncSpecType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	directionAttribute, ok := attributes["direction"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`direction is missing from object`)

		return nil, diags
	}

	directionVal, ok := directionAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`direction expected to be ovhtypes.TfStringValue, was: %T`, directionAttribute))
	}

	manualAttribute, ok := attributes["manual"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`manual is missing from object`)

		return nil, diags
	}

	manualVal, ok := manualAttribute.(ovhtypes.TfBoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`manual expected to be ovhtypes.TfBoolValue, was: %T`, manualAttribute))
	}

	volumeAttribute, ok := attributes["volume"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume is missing from object`)

		return nil, diags
	}

	volumeVal, ok := volumeAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume expected to be ovhtypes.TfStringValue, was: %T`, volumeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return StatusDataSyncSpecValue{
		Direction: directionVal,
		Manual:    manualVal,
		Volume:    volumeVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewStatusDataSyncSpecValueNull() StatusDataSyncSpecValue {
	return StatusDataSyncSpecValue{
		state: attr.ValueStateNull,
	}
}

func NewStatusDataSyncSpecValueUnknown() StatusDataSyncSpecValue {
	return StatusDataSyncSpecValue{
		state: attr.ValueStateUnknown,
	}
}

func NewStatusDataSyncSpecValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (StatusDataSyncSpecValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing StatusDataSyncSpecValue Attribute Value",
				"While creating a StatusDataSyncSpecValue value, a missing attribute value was detected. "+
					"A StatusDataSyncSpecValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StatusDataSyncSpecValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid StatusDataSyncSpecValue Attribute Type",
				"While creating a StatusDataSyncSpecValue value, an invalid attribute value was detected. "+
					"A StatusDataSyncSpecValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StatusDataSyncSpecValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("StatusDataSyncSpecValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra StatusDataSyncSpecValue Attribute Value",
				"While creating a StatusDataSyncSpecValue value, an extra attribute value was detected. "+
					"A StatusDataSyncSpecValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra StatusDataSyncSpecValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewStatusDataSyncSpecValueUnknown(), diags
	}

	directionAttribute, ok := attributes["direction"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`direction is missing from object`)

		return NewStatusDataSyncSpecValueUnknown(), diags
	}

	directionVal, ok := directionAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`direction expected to be ovhtypes.TfStringValue, was: %T`, directionAttribute))
	}

	manualAttribute, ok := attributes["manual"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`manual is missing from object`)

		return NewStatusDataSyncSpecValueUnknown(), diags
	}

	manualVal, ok := manualAttribute.(ovhtypes.TfBoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`manual expected to be ovhtypes.TfBoolValue, was: %T`, manualAttribute))
	}

	volumeAttribute, ok := attributes["volume"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume is missing from object`)

		return NewStatusDataSyncSpecValueUnknown(), diags
	}

	volumeVal, ok := volumeAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume expected to be ovhtypes.TfStringValue, was: %T`, volumeAttribute))
	}

	if diags.HasError() {
		return NewStatusDataSyncSpecValueUnknown(), diags
	}

	return StatusDataSyncSpecValue{
		Direction: directionVal,
		Manual:    manualVal,
		Volume:    volumeVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewStatusDataSyncSpecValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) StatusDataSyncSpecValue {
	object, diags := NewStatusDataSyncSpecValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewStatusDataSyncSpecValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t StatusDataSyncSpecType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewStatusDataSyncSpecValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewStatusDataSyncSpecValueUnknown(), nil
	}

	if in.IsNull() {
		return NewStatusDataSyncSpecValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewStatusDataSyncSpecValueMust(StatusDataSyncSpecValue{}.AttributeTypes(ctx), attributes), nil
}

func (t StatusDataSyncSpecType) ValueType(ctx context.Context) attr.Value {
	return StatusDataSyncSpecValue{}
}

var _ basetypes.ObjectValuable = StatusDataSyncSpecValue{}

type StatusDataSyncSpecValue struct {
	Direction ovhtypes.TfStringValue `tfsdk:"direction" json:"direction"`
	Manual    ovhtypes.TfBoolValue   `tfsdk:"manual" json:"manual"`
	Volume    ovhtypes.TfStringValue `tfsdk:"volume" json:"volume"`
	state     attr.ValueState
}

func (v StatusDataSyncSpecValue) ToCreate() *StatusDataSyncSpecValue {
	res := &StatusDataSyncSpecValue{}

	if !v.Manual.IsNull() {
		res.Manual = v.Manual
	}

	res.state = attr.ValueStateKnown

	return res
}

func (v StatusDataSyncSpecValue) MarshalJSON() ([]byte, error) {
	toMarshal := map[string]any{}
	if !v.Manual.IsNull() && !v.Manual.IsUnknown() {
		toMarshal["manual"] = v.Manual
	}

	return json.Marshal(toMarshal)
}

func (v *StatusDataSyncSpecValue) UnmarshalJSON(data []byte) error {
	type JsonStatusDataSyncSpecValue StatusDataSyncSpecValue

	var tmp JsonStatusDataSyncSpecValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.Direction = tmp.Direction
	v.Manual = tmp.Manual
	v.Volume = tmp.Volume

	v.state = attr.ValueStateKnown

	return nil
}

func (v *StatusDataSyncSpecValue) MergeWith(other *StatusDataSyncSpecValue) {

	if (v.Direction.IsUnknown() || v.Direction.IsNull()) && !other.Direction.IsUnknown() {
		v.Direction = other.Direction
	}

	if (v.Manual.IsUnknown() || v.Manual.IsNull()) && !other.Manual.IsUnknown() {
		v.Manual = other.Manual
	}

	if (v.Volume.IsUnknown() || v.Volume.IsNull()) && !other.Volume.IsUnknown() {
		v.Volume = other.Volume
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v StatusDataSyncSpecValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"direction": v.Direction,
		"manual":    v.Manual,
		"volume":    v.Volume,
	}
}
func (v StatusDataSyncSpecValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["direction"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["manual"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["volume"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Direction.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["direction"] = val

		val, err = v.Manual.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["manual"] = val

		val, err = v.Volume.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["volume"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v StatusDataSyncSpecValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v StatusDataSyncSpecValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v StatusDataSyncSpecValue) String() string {
	return "StatusDataSyncSpecValue"
}

func (v StatusDataSyncSpecValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"direction": ovhtypes.TfStringType{},
			"manual":    ovhtypes.TfBoolType{},
			"volume":    ovhtypes.TfStringType{},
		},
		map[string]attr.Value{
			"direction": v.Direction,
			"manual":    v.Manual,
			"volume":    v.Volume,
		})

	return objVal, diags
}

func (v StatusDataSyncSpecValue) Equal(o attr.Value) bool {
	other, ok := o.(StatusDataSyncSpecValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Direction.Equal(other.Direction) {
		return false
	}

	if !v.Manual.Equal(other.Manual) {
		return false
	}

	if !v.Volume.Equal(other.Volume) {
		return false
	}

	return true
}

func (v StatusDataSyncSpecValue) Type(ctx context.Context) attr.Type {
	return StatusDataSyncSpecType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v StatusDataSyncSpecValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"direction": ovhtypes.TfStringType{},
		"manual":    ovhtypes.TfBoolType{},
		"volume":    ovhtypes.TfStringType{},
	}
}

var _ basetypes.ObjectTypable = StatusDataSyncStatusType{}

type StatusDataSyncStatusType struct {
	basetypes.ObjectType
}

func (t StatusDataSyncStatusType) Equal(o attr.Type) bool {
	other, ok := o.(StatusDataSyncStatusType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t StatusDataSyncStatusType) String() string {
	return "StatusDataSyncStatusType"
}

func (t StatusDataSyncStatusType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	endedAtAttribute, ok := attributes["ended_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ended_at is missing from object`)

		return nil, diags
	}

	endedAtVal, ok := endedAtAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ended_at expected to be ovhtypes.TfStringValue, was: %T`, endedAtAttribute))
	}

	infoAttribute, ok := attributes["info"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`info is missing from object`)

		return nil, diags
	}

	infoVal, ok := infoAttribute.(StatusDataSyncStatusInfoValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`info expected to be StatusDataSyncStatusInfoValue, was: %T`, infoAttribute))
	}

	progressAttribute, ok := attributes["progress"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`progress is missing from object`)

		return nil, diags
	}

	progressVal, ok := progressAttribute.(ovhtypes.TfListNestedValue[StatusDataSyncStatusProgressValue])

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`progress expected to be ovhtypes.TfListNestedValue[StatusDataSyncStatusProgressValue], was: %T`, progressAttribute))
	}

	queuedAtAttribute, ok := attributes["queued_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`queued_at is missing from object`)

		return nil, diags
	}

	queuedAtVal, ok := queuedAtAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`queued_at expected to be ovhtypes.TfStringValue, was: %T`, queuedAtAttribute))
	}

	startedAtAttribute, ok := attributes["started_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`started_at is missing from object`)

		return nil, diags
	}

	startedAtVal, ok := startedAtAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`started_at expected to be ovhtypes.TfStringValue, was: %T`, startedAtAttribute))
	}

	stateAttribute, ok := attributes["state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`state is missing from object`)

		return nil, diags
	}

	stateVal, ok := stateAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`state expected to be ovhtypes.TfStringValue, was: %T`, stateAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return StatusDataSyncStatusValue{
		EndedAt:   endedAtVal,
		Info:      infoVal,
		Progress:  progressVal,
		QueuedAt:  queuedAtVal,
		StartedAt: startedAtVal,
		State:     stateVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewStatusDataSyncStatusValueNull() StatusDataSyncStatusValue {
	return StatusDataSyncStatusValue{
		state: attr.ValueStateNull,
	}
}

func NewStatusDataSyncStatusValueUnknown() StatusDataSyncStatusValue {
	return StatusDataSyncStatusValue{
		state: attr.ValueStateUnknown,
	}
}

func NewStatusDataSyncStatusValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (StatusDataSyncStatusValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing StatusDataSyncStatusValue Attribute Value",
				"While creating a StatusDataSyncStatusValue value, a missing attribute value was detected. "+
					"A StatusDataSyncStatusValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StatusDataSyncStatusValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid StatusDataSyncStatusValue Attribute Type",
				"While creating a StatusDataSyncStatusValue value, an invalid attribute value was detected. "+
					"A StatusDataSyncStatusValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StatusDataSyncStatusValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("StatusDataSyncStatusValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra StatusDataSyncStatusValue Attribute Value",
				"While creating a StatusDataSyncStatusValue value, an extra attribute value was detected. "+
					"A StatusDataSyncStatusValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra StatusDataSyncStatusValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewStatusDataSyncStatusValueUnknown(), diags
	}

	endedAtAttribute, ok := attributes["ended_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ended_at is missing from object`)

		return NewStatusDataSyncStatusValueUnknown(), diags
	}

	endedAtVal, ok := endedAtAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ended_at expected to be ovhtypes.TfStringValue, was: %T`, endedAtAttribute))
	}

	infoAttribute, ok := attributes["info"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`info is missing from object`)

		return NewStatusDataSyncStatusValueUnknown(), diags
	}

	infoVal, ok := infoAttribute.(StatusDataSyncStatusInfoValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`info expected to be StatusDataSyncStatusInfoValue, was: %T`, infoAttribute))
	}

	progressAttribute, ok := attributes["progress"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`progress is missing from object`)

		return NewStatusDataSyncStatusValueUnknown(), diags
	}

	progressVal, ok := progressAttribute.(ovhtypes.TfListNestedValue[StatusDataSyncStatusProgressValue])

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`progress expected to be ovhtypes.TfListNestedValue[StatusDataSyncStatusProgressValue], was: %T`, progressAttribute))
	}

	queuedAtAttribute, ok := attributes["queued_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`queued_at is missing from object`)

		return NewStatusDataSyncStatusValueUnknown(), diags
	}

	queuedAtVal, ok := queuedAtAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`queued_at expected to be ovhtypes.TfStringValue, was: %T`, queuedAtAttribute))
	}

	startedAtAttribute, ok := attributes["started_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`started_at is missing from object`)

		return NewStatusDataSyncStatusValueUnknown(), diags
	}

	startedAtVal, ok := startedAtAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`started_at expected to be ovhtypes.TfStringValue, was: %T`, startedAtAttribute))
	}

	stateAttribute, ok := attributes["state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`state is missing from object`)

		return NewStatusDataSyncStatusValueUnknown(), diags
	}

	stateVal, ok := stateAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`state expected to be ovhtypes.TfStringValue, was: %T`, stateAttribute))
	}

	if diags.HasError() {
		return NewStatusDataSyncStatusValueUnknown(), diags
	}

	return StatusDataSyncStatusValue{
		EndedAt:   endedAtVal,
		Info:      infoVal,
		Progress:  progressVal,
		QueuedAt:  queuedAtVal,
		StartedAt: startedAtVal,
		State:     stateVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewStatusDataSyncStatusValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) StatusDataSyncStatusValue {
	object, diags := NewStatusDataSyncStatusValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewStatusDataSyncStatusValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t StatusDataSyncStatusType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewStatusDataSyncStatusValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewStatusDataSyncStatusValueUnknown(), nil
	}

	if in.IsNull() {
		return NewStatusDataSyncStatusValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewStatusDataSyncStatusValueMust(StatusDataSyncStatusValue{}.AttributeTypes(ctx), attributes), nil
}

func (t StatusDataSyncStatusType) ValueType(ctx context.Context) attr.Value {
	return StatusDataSyncStatusValue{}
}

var _ basetypes.ObjectValuable = StatusDataSyncStatusValue{}

type StatusDataSyncStatusValue struct {
	EndedAt   ovhtypes.TfStringValue                                        `tfsdk:"ended_at" json:"endedAt"`
	Info      StatusDataSyncStatusInfoValue                                 `tfsdk:"info" json:"info"`
	Progress  ovhtypes.TfListNestedValue[StatusDataSyncStatusProgressValue] `tfsdk:"progress" json:"progress"`
	QueuedAt  ovhtypes.TfStringValue                                        `tfsdk:"queued_at" json:"queuedAt"`
	StartedAt ovhtypes.TfStringValue                                        `tfsdk:"started_at" json:"startedAt"`
	State     ovhtypes.TfStringValue                                        `tfsdk:"state" json:"state"`
	state     attr.ValueState
}

func (v *StatusDataSyncStatusValue) UnmarshalJSON(data []byte) error {
	type JsonStatusDataSyncStatusValue StatusDataSyncStatusValue

	var tmp JsonStatusDataSyncStatusValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.EndedAt = tmp.EndedAt
	v.Info = tmp.Info
	v.Progress = tmp.Progress
	v.QueuedAt = tmp.QueuedAt
	v.StartedAt = tmp.StartedAt
	v.State = tmp.State

	v.state = attr.ValueStateKnown

	return nil
}

func (v *StatusDataSyncStatusValue) MergeWith(other *StatusDataSyncStatusValue) {

	if (v.EndedAt.IsUnknown() || v.EndedAt.IsNull()) && !other.EndedAt.IsUnknown() {
		v.EndedAt = other.EndedAt
	}

	if v.Info.IsUnknown() && !other.Info.IsUnknown() {
		v.Info = other.Info
	} else if !other.Info.IsUnknown() {
		v.Info.MergeWith(&other.Info)
	}

	if (v.Progress.IsUnknown() || v.Progress.IsNull()) && !other.Progress.IsUnknown() {
		v.Progress = other.Progress
	} else if !other.Progress.IsUnknown() {
		newSlice := make([]attr.Value, 0)
		elems := v.Progress.Elements()
		newElems := other.Progress.Elements()

		if len(elems) != len(newElems) {
			v.Progress = other.Progress
		} else {
			for idx, e := range elems {
				tmp := e.(StatusDataSyncStatusProgressValue)
				tmp2 := newElems[idx].(StatusDataSyncStatusProgressValue)
				tmp.MergeWith(&tmp2)
				newSlice = append(newSlice, tmp)
			}

			v.Progress = ovhtypes.TfListNestedValue[StatusDataSyncStatusProgressValue]{
				ListValue: basetypes.NewListValueMust(StatusDataSyncStatusProgressValue{}.Type(context.Background()), newSlice),
			}
		}
	}

	if (v.QueuedAt.IsUnknown() || v.QueuedAt.IsNull()) && !other.QueuedAt.IsUnknown() {
		v.QueuedAt = other.QueuedAt
	}

	if (v.StartedAt.IsUnknown() || v.StartedAt.IsNull()) && !other.StartedAt.IsUnknown() {
		v.StartedAt = other.StartedAt
	}

	if (v.State.IsUnknown() || v.State.IsNull()) && !other.State.IsUnknown() {
		v.State = other.State
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v StatusDataSyncStatusValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"endedAt":   v.EndedAt,
		"info":      v.Info,
		"progress":  v.Progress,
		"queuedAt":  v.QueuedAt,
		"startedAt": v.StartedAt,
		"state":     v.State,
	}
}
func (v StatusDataSyncStatusValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 6)

	var val tftypes.Value
	var err error

	attrTypes["ended_at"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["info"] = basetypes.ObjectType{
		AttrTypes: StatusDataSyncStatusInfoValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["progress"] = basetypes.ListType{
		ElemType: StatusDataSyncStatusProgressValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["queued_at"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["started_at"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["state"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 6)

		val, err = v.EndedAt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ended_at"] = val

		val, err = v.Info.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["info"] = val

		val, err = v.Progress.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["progress"] = val

		val, err = v.QueuedAt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["queued_at"] = val

		val, err = v.StartedAt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["started_at"] = val

		val, err = v.State.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["state"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v StatusDataSyncStatusValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v StatusDataSyncStatusValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v StatusDataSyncStatusValue) String() string {
	return "StatusDataSyncStatusValue"
}

func (v StatusDataSyncStatusValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"ended_at": ovhtypes.TfStringType{},
			"info": StatusDataSyncStatusInfoType{
				basetypes.ObjectType{
					AttrTypes: StatusDataSyncStatusInfoValue{}.AttributeTypes(ctx),
				},
			},
			"progress":   ovhtypes.NewTfListNestedType[StatusDataSyncStatusProgressValue](ctx),
			"queued_at":  ovhtypes.TfStringType{},
			"started_at": ovhtypes.TfStringType{},
			"state":      ovhtypes.TfStringType{},
		},
		map[string]attr.Value{
			"ended_at":   v.EndedAt,
			"info":       v.Info,
			"progress":   v.Progress,
			"queued_at":  v.QueuedAt,
			"started_at": v.StartedAt,
			"state":      v.State,
		})

	return objVal, diags
}

func (v StatusDataSyncStatusValue) Equal(o attr.Value) bool {
	other, ok := o.(StatusDataSyncStatusValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.EndedAt.Equal(other.EndedAt) {
		return false
	}

	if !v.Info.Equal(other.Info) {
		return false
	}

	if !v.Progress.Equal(other.Progress) {
		return false
	}

	if !v.QueuedAt.Equal(other.QueuedAt) {
		return false
	}

	if !v.StartedAt.Equal(other.StartedAt) {
		return false
	}

	if !v.State.Equal(other.State) {
		return false
	}

	return true
}

func (v StatusDataSyncStatusValue) Type(ctx context.Context) attr.Type {
	return StatusDataSyncStatusType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v StatusDataSyncStatusValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"ended_at":   ovhtypes.TfStringType{},
		"info":       StatusDataSyncStatusInfoValue{}.Type(ctx),
		"progress":   ovhtypes.NewTfListNestedType[StatusDataSyncStatusProgressValue](ctx),
		"queued_at":  ovhtypes.TfStringType{},
		"started_at": ovhtypes.TfStringType{},
		"state":      ovhtypes.TfStringType{},
	}
}

var _ basetypes.ObjectTypable = StatusDataSyncStatusInfoType{}

type StatusDataSyncStatusInfoType struct {
	basetypes.ObjectType
}

func (t StatusDataSyncStatusInfoType) Equal(o attr.Type) bool {
	other, ok := o.(StatusDataSyncStatusInfoType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t StatusDataSyncStatusInfoType) String() string {
	return "StatusDataSyncStatusInfoType"
}

func (t StatusDataSyncStatusInfoType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	codeAttribute, ok := attributes["code"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`code is missing from object`)

		return nil, diags
	}

	codeVal, ok := codeAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`code expected to be ovhtypes.TfStringValue, was: %T`, codeAttribute))
	}

	messageAttribute, ok := attributes["message"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`message is missing from object`)

		return nil, diags
	}

	messageVal, ok := messageAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`message expected to be ovhtypes.TfStringValue, was: %T`, messageAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return StatusDataSyncStatusInfoValue{
		Code:    codeVal,
		Message: messageVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewStatusDataSyncStatusInfoValueNull() StatusDataSyncStatusInfoValue {
	return StatusDataSyncStatusInfoValue{
		state: attr.ValueStateNull,
	}
}

func NewStatusDataSyncStatusInfoValueUnknown() StatusDataSyncStatusInfoValue {
	return StatusDataSyncStatusInfoValue{
		state: attr.ValueStateUnknown,
	}
}

func NewStatusDataSyncStatusInfoValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (StatusDataSyncStatusInfoValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing StatusDataSyncStatusInfoValue Attribute Value",
				"While creating a StatusDataSyncStatusInfoValue value, a missing attribute value was detected. "+
					"A StatusDataSyncStatusInfoValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StatusDataSyncStatusInfoValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid StatusDataSyncStatusInfoValue Attribute Type",
				"While creating a StatusDataSyncStatusInfoValue value, an invalid attribute value was detected. "+
					"A StatusDataSyncStatusInfoValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StatusDataSyncStatusInfoValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("StatusDataSyncStatusInfoValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra StatusDataSyncStatusInfoValue Attribute Value",
				"While creating a StatusDataSyncStatusInfoValue value, an extra attribute value was detected. "+
					"A StatusDataSyncStatusInfoValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra StatusDataSyncStatusInfoValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewStatusDataSyncStatusInfoValueUnknown(), diags
	}

	codeAttribute, ok := attributes["code"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`code is missing from object`)

		return NewStatusDataSyncStatusInfoValueUnknown(), diags
	}

	codeVal, ok := codeAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`code expected to be ovhtypes.TfStringValue, was: %T`, codeAttribute))
	}

	messageAttribute, ok := attributes["message"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`message is missing from object`)

		return NewStatusDataSyncStatusInfoValueUnknown(), diags
	}

	messageVal, ok := messageAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`message expected to be ovhtypes.TfStringValue, was: %T`, messageAttribute))
	}

	if diags.HasError() {
		return NewStatusDataSyncStatusInfoValueUnknown(), diags
	}

	return StatusDataSyncStatusInfoValue{
		Code:    codeVal,
		Message: messageVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewStatusDataSyncStatusInfoValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) StatusDataSyncStatusInfoValue {
	object, diags := NewStatusDataSyncStatusInfoValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewStatusDataSyncStatusInfoValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t StatusDataSyncStatusInfoType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewStatusDataSyncStatusInfoValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewStatusDataSyncStatusInfoValueUnknown(), nil
	}

	if in.IsNull() {
		return NewStatusDataSyncStatusInfoValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewStatusDataSyncStatusInfoValueMust(StatusDataSyncStatusInfoValue{}.AttributeTypes(ctx), attributes), nil
}

func (t StatusDataSyncStatusInfoType) ValueType(ctx context.Context) attr.Value {
	return StatusDataSyncStatusInfoValue{}
}

var _ basetypes.ObjectValuable = StatusDataSyncStatusInfoValue{}

type StatusDataSyncStatusInfoValue struct {
	Code    ovhtypes.TfStringValue `tfsdk:"code" json:"code"`
	Message ovhtypes.TfStringValue `tfsdk:"message" json:"message"`
	state   attr.ValueState
}

func (v *StatusDataSyncStatusInfoValue) UnmarshalJSON(data []byte) error {
	type JsonStatusDataSyncStatusInfoValue StatusDataSyncStatusInfoValue

	var tmp JsonStatusDataSyncStatusInfoValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.Code = tmp.Code
	v.Message = tmp.Message

	v.state = attr.ValueStateKnown

	return nil
}

func (v *StatusDataSyncStatusInfoValue) MergeWith(other *StatusDataSyncStatusInfoValue) {

	if (v.Code.IsUnknown() || v.Code.IsNull()) && !other.Code.IsUnknown() {
		v.Code = other.Code
	}

	if (v.Message.IsUnknown() || v.Message.IsNull()) && !other.Message.IsUnknown() {
		v.Message = other.Message
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v StatusDataSyncStatusInfoValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"code":    v.Code,
		"message": v.Message,
	}
}
func (v StatusDataSyncStatusInfoValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["code"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["message"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Code.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["code"] = val

		val, err = v.Message.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["message"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v StatusDataSyncStatusInfoValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v StatusDataSyncStatusInfoValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v StatusDataSyncStatusInfoValue) String() string {
	return "StatusDataSyncStatusInfoValue"
}

func (v StatusDataSyncStatusInfoValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"code":    ovhtypes.TfStringType{},
			"message": ovhtypes.TfStringType{},
		},
		map[string]attr.Value{
			"code":    v.Code,
			"message": v.Message,
		})

	return objVal, diags
}

func (v StatusDataSyncStatusInfoValue) Equal(o attr.Value) bool {
	other, ok := o.(StatusDataSyncStatusInfoValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Code.Equal(other.Code) {
		return false
	}

	if !v.Message.Equal(other.Message) {
		return false
	}

	return true
}

func (v StatusDataSyncStatusInfoValue) Type(ctx context.Context) attr.Type {
	return StatusDataSyncStatusInfoType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v StatusDataSyncStatusInfoValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"code":    ovhtypes.TfStringType{},
		"message": ovhtypes.TfStringType{},
	}
}

var _ basetypes.ObjectTypable = StatusDataSyncStatusProgressType{}

type StatusDataSyncStatusProgressType struct {
	basetypes.ObjectType
}

func (t StatusDataSyncStatusProgressType) Equal(o attr.Type) bool {
	other, ok := o.(StatusDataSyncStatusProgressType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t StatusDataSyncStatusProgressType) String() string {
	return "StatusDataSyncStatusProgressType"
}

func (t StatusDataSyncStatusProgressType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	completedAttribute, ok := attributes["completed"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`completed is missing from object`)

		return nil, diags
	}

	completedVal, ok := completedAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`completed expected to be ovhtypes.TfInt64Value, was: %T`, completedAttribute))
	}

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return nil, diags
	}

	createdAtVal, ok := createdAtAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be ovhtypes.TfStringValue, was: %T`, createdAtAttribute))
	}

	deletedAttribute, ok := attributes["deleted"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`deleted is missing from object`)

		return nil, diags
	}

	deletedVal, ok := deletedAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`deleted expected to be ovhtypes.TfInt64Value, was: %T`, deletedAttribute))
	}

	directionAttribute, ok := attributes["direction"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`direction is missing from object`)

		return nil, diags
	}

	directionVal, ok := directionAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`direction expected to be ovhtypes.TfStringValue, was: %T`, directionAttribute))
	}

	etaAttribute, ok := attributes["eta"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`eta is missing from object`)

		return nil, diags
	}

	etaVal, ok := etaAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`eta expected to be ovhtypes.TfInt64Value, was: %T`, etaAttribute))
	}

	failedAttribute, ok := attributes["failed"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`failed is missing from object`)

		return nil, diags
	}

	failedVal, ok := failedAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`failed expected to be ovhtypes.TfInt64Value, was: %T`, failedAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be ovhtypes.TfStringValue, was: %T`, idAttribute))
	}

	infoAttribute, ok := attributes["info"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`info is missing from object`)

		return nil, diags
	}

	infoVal, ok := infoAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`info expected to be ovhtypes.TfStringValue, was: %T`, infoAttribute))
	}

	processedAttribute, ok := attributes["processed"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`processed is missing from object`)

		return nil, diags
	}

	processedVal, ok := processedAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`processed expected to be ovhtypes.TfInt64Value, was: %T`, processedAttribute))
	}

	skippedAttribute, ok := attributes["skipped"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`skipped is missing from object`)

		return nil, diags
	}

	skippedVal, ok := skippedAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`skipped expected to be ovhtypes.TfInt64Value, was: %T`, skippedAttribute))
	}

	stateAttribute, ok := attributes["state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`state is missing from object`)

		return nil, diags
	}

	stateVal, ok := stateAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`state expected to be ovhtypes.TfStringValue, was: %T`, stateAttribute))
	}

	totalAttribute, ok := attributes["total"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`total is missing from object`)

		return nil, diags
	}

	totalVal, ok := totalAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`total expected to be ovhtypes.TfInt64Value, was: %T`, totalAttribute))
	}

	transferredBytesAttribute, ok := attributes["transferred_bytes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`transferred_bytes is missing from object`)

		return nil, diags
	}

	transferredBytesVal, ok := transferredBytesAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`transferred_bytes expected to be ovhtypes.TfInt64Value, was: %T`, transferredBytesAttribute))
	}

	updatedAtAttribute, ok := attributes["updated_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`updated_at is missing from object`)

		return nil, diags
	}

	updatedAtVal, ok := updatedAtAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`updated_at expected to be ovhtypes.TfStringValue, was: %T`, updatedAtAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return StatusDataSyncStatusProgressValue{
		Completed:        completedVal,
		CreatedAt:        createdAtVal,
		Deleted:          deletedVal,
		Direction:        directionVal,
		Eta:              etaVal,
		Failed:           failedVal,
		Id:               idVal,
		Info:             infoVal,
		Processed:        processedVal,
		Skipped:          skippedVal,
		State:            stateVal,
		Total:            totalVal,
		TransferredBytes: transferredBytesVal,
		UpdatedAt:        updatedAtVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewStatusDataSyncStatusProgressValueNull() StatusDataSyncStatusProgressValue {
	return StatusDataSyncStatusProgressValue{
		state: attr.ValueStateNull,
	}
}

func NewStatusDataSyncStatusProgressValueUnknown() StatusDataSyncStatusProgressValue {
	return StatusDataSyncStatusProgressValue{
		state: attr.ValueStateUnknown,
	}
}

func NewStatusDataSyncStatusProgressValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (StatusDataSyncStatusProgressValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing StatusDataSyncStatusProgressValue Attribute Value",
				"While creating a StatusDataSyncStatusProgressValue value, a missing attribute value was detected. "+
					"A StatusDataSyncStatusProgressValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StatusDataSyncStatusProgressValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid StatusDataSyncStatusProgressValue Attribute Type",
				"While creating a StatusDataSyncStatusProgressValue value, an invalid attribute value was detected. "+
					"A StatusDataSyncStatusProgressValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StatusDataSyncStatusProgressValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("StatusDataSyncStatusProgressValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra StatusDataSyncStatusProgressValue Attribute Value",
				"While creating a StatusDataSyncStatusProgressValue value, an extra attribute value was detected. "+
					"A StatusDataSyncStatusProgressValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra StatusDataSyncStatusProgressValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewStatusDataSyncStatusProgressValueUnknown(), diags
	}

	completedAttribute, ok := attributes["completed"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`completed is missing from object`)

		return NewStatusDataSyncStatusProgressValueUnknown(), diags
	}

	completedVal, ok := completedAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`completed expected to be ovhtypes.TfInt64Value, was: %T`, completedAttribute))
	}

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return NewStatusDataSyncStatusProgressValueUnknown(), diags
	}

	createdAtVal, ok := createdAtAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be ovhtypes.TfStringValue, was: %T`, createdAtAttribute))
	}

	deletedAttribute, ok := attributes["deleted"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`deleted is missing from object`)

		return NewStatusDataSyncStatusProgressValueUnknown(), diags
	}

	deletedVal, ok := deletedAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`deleted expected to be ovhtypes.TfInt64Value, was: %T`, deletedAttribute))
	}

	directionAttribute, ok := attributes["direction"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`direction is missing from object`)

		return NewStatusDataSyncStatusProgressValueUnknown(), diags
	}

	directionVal, ok := directionAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`direction expected to be ovhtypes.TfStringValue, was: %T`, directionAttribute))
	}

	etaAttribute, ok := attributes["eta"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`eta is missing from object`)

		return NewStatusDataSyncStatusProgressValueUnknown(), diags
	}

	etaVal, ok := etaAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`eta expected to be ovhtypes.TfInt64Value, was: %T`, etaAttribute))
	}

	failedAttribute, ok := attributes["failed"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`failed is missing from object`)

		return NewStatusDataSyncStatusProgressValueUnknown(), diags
	}

	failedVal, ok := failedAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`failed expected to be ovhtypes.TfInt64Value, was: %T`, failedAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewStatusDataSyncStatusProgressValueUnknown(), diags
	}

	idVal, ok := idAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be ovhtypes.TfStringValue, was: %T`, idAttribute))
	}

	infoAttribute, ok := attributes["info"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`info is missing from object`)

		return NewStatusDataSyncStatusProgressValueUnknown(), diags
	}

	infoVal, ok := infoAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`info expected to be ovhtypes.TfStringValue, was: %T`, infoAttribute))
	}

	processedAttribute, ok := attributes["processed"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`processed is missing from object`)

		return NewStatusDataSyncStatusProgressValueUnknown(), diags
	}

	processedVal, ok := processedAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`processed expected to be ovhtypes.TfInt64Value, was: %T`, processedAttribute))
	}

	skippedAttribute, ok := attributes["skipped"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`skipped is missing from object`)

		return NewStatusDataSyncStatusProgressValueUnknown(), diags
	}

	skippedVal, ok := skippedAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`skipped expected to be ovhtypes.TfInt64Value, was: %T`, skippedAttribute))
	}

	stateAttribute, ok := attributes["state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`state is missing from object`)

		return NewStatusDataSyncStatusProgressValueUnknown(), diags
	}

	stateVal, ok := stateAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`state expected to be ovhtypes.TfStringValue, was: %T`, stateAttribute))
	}

	totalAttribute, ok := attributes["total"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`total is missing from object`)

		return NewStatusDataSyncStatusProgressValueUnknown(), diags
	}

	totalVal, ok := totalAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`total expected to be ovhtypes.TfInt64Value, was: %T`, totalAttribute))
	}

	transferredBytesAttribute, ok := attributes["transferred_bytes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`transferred_bytes is missing from object`)

		return NewStatusDataSyncStatusProgressValueUnknown(), diags
	}

	transferredBytesVal, ok := transferredBytesAttribute.(ovhtypes.TfInt64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`transferred_bytes expected to be ovhtypes.TfInt64Value, was: %T`, transferredBytesAttribute))
	}

	updatedAtAttribute, ok := attributes["updated_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`updated_at is missing from object`)

		return NewStatusDataSyncStatusProgressValueUnknown(), diags
	}

	updatedAtVal, ok := updatedAtAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`updated_at expected to be ovhtypes.TfStringValue, was: %T`, updatedAtAttribute))
	}

	if diags.HasError() {
		return NewStatusDataSyncStatusProgressValueUnknown(), diags
	}

	return StatusDataSyncStatusProgressValue{
		Completed:        completedVal,
		CreatedAt:        createdAtVal,
		Deleted:          deletedVal,
		Direction:        directionVal,
		Eta:              etaVal,
		Failed:           failedVal,
		Id:               idVal,
		Info:             infoVal,
		Processed:        processedVal,
		Skipped:          skippedVal,
		State:            stateVal,
		Total:            totalVal,
		TransferredBytes: transferredBytesVal,
		UpdatedAt:        updatedAtVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewStatusDataSyncStatusProgressValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) StatusDataSyncStatusProgressValue {
	object, diags := NewStatusDataSyncStatusProgressValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewStatusDataSyncStatusProgressValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t StatusDataSyncStatusProgressType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewStatusDataSyncStatusProgressValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewStatusDataSyncStatusProgressValueUnknown(), nil
	}

	if in.IsNull() {
		return NewStatusDataSyncStatusProgressValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewStatusDataSyncStatusProgressValueMust(StatusDataSyncStatusProgressValue{}.AttributeTypes(ctx), attributes), nil
}

func (t StatusDataSyncStatusProgressType) ValueType(ctx context.Context) attr.Value {
	return StatusDataSyncStatusProgressValue{}
}

var _ basetypes.ObjectValuable = StatusDataSyncStatusProgressValue{}

type StatusDataSyncStatusProgressValue struct {
	Completed        ovhtypes.TfInt64Value  `tfsdk:"completed" json:"completed"`
	CreatedAt        ovhtypes.TfStringValue `tfsdk:"created_at" json:"createdAt"`
	Deleted          ovhtypes.TfInt64Value  `tfsdk:"deleted" json:"deleted"`
	Direction        ovhtypes.TfStringValue `tfsdk:"direction" json:"direction"`
	Eta              ovhtypes.TfInt64Value  `tfsdk:"eta" json:"eta"`
	Failed           ovhtypes.TfInt64Value  `tfsdk:"failed" json:"failed"`
	Id               ovhtypes.TfStringValue `tfsdk:"id" json:"id"`
	Info             ovhtypes.TfStringValue `tfsdk:"info" json:"info"`
	Processed        ovhtypes.TfInt64Value  `tfsdk:"processed" json:"processed"`
	Skipped          ovhtypes.TfInt64Value  `tfsdk:"skipped" json:"skipped"`
	State            ovhtypes.TfStringValue `tfsdk:"state" json:"state"`
	Total            ovhtypes.TfInt64Value  `tfsdk:"total" json:"total"`
	TransferredBytes ovhtypes.TfInt64Value  `tfsdk:"transferred_bytes" json:"transferredBytes"`
	UpdatedAt        ovhtypes.TfStringValue `tfsdk:"updated_at" json:"updatedAt"`
	state            attr.ValueState
}

func (v *StatusDataSyncStatusProgressValue) UnmarshalJSON(data []byte) error {
	type JsonStatusDataSyncStatusProgressValue StatusDataSyncStatusProgressValue

	var tmp JsonStatusDataSyncStatusProgressValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.Completed = tmp.Completed
	v.CreatedAt = tmp.CreatedAt
	v.Deleted = tmp.Deleted
	v.Direction = tmp.Direction
	v.Eta = tmp.Eta
	v.Failed = tmp.Failed
	v.Id = tmp.Id
	v.Info = tmp.Info
	v.Processed = tmp.Processed
	v.Skipped = tmp.Skipped
	v.State = tmp.State
	v.Total = tmp.Total
	v.TransferredBytes = tmp.TransferredBytes
	v.UpdatedAt = tmp.UpdatedAt

	v.state = attr.ValueStateKnown

	return nil
}

func (v *StatusDataSyncStatusProgressValue) MergeWith(other *StatusDataSyncStatusProgressValue) {

	if (v.Completed.IsUnknown() || v.Completed.IsNull()) && !other.Completed.IsUnknown() {
		v.Completed = other.Completed
	}

	if (v.CreatedAt.IsUnknown() || v.CreatedAt.IsNull()) && !other.CreatedAt.IsUnknown() {
		v.CreatedAt = other.CreatedAt
	}

	if (v.Deleted.IsUnknown() || v.Deleted.IsNull()) && !other.Deleted.IsUnknown() {
		v.Deleted = other.Deleted
	}

	if (v.Direction.IsUnknown() || v.Direction.IsNull()) && !other.Direction.IsUnknown() {
		v.Direction = other.Direction
	}

	if (v.Eta.IsUnknown() || v.Eta.IsNull()) && !other.Eta.IsUnknown() {
		v.Eta = other.Eta
	}

	if (v.Failed.IsUnknown() || v.Failed.IsNull()) && !other.Failed.IsUnknown() {
		v.Failed = other.Failed
	}

	if (v.Id.IsUnknown() || v.Id.IsNull()) && !other.Id.IsUnknown() {
		v.Id = other.Id
	}

	if (v.Info.IsUnknown() || v.Info.IsNull()) && !other.Info.IsUnknown() {
		v.Info = other.Info
	}

	if (v.Processed.IsUnknown() || v.Processed.IsNull()) && !other.Processed.IsUnknown() {
		v.Processed = other.Processed
	}

	if (v.Skipped.IsUnknown() || v.Skipped.IsNull()) && !other.Skipped.IsUnknown() {
		v.Skipped = other.Skipped
	}

	if (v.State.IsUnknown() || v.State.IsNull()) && !other.State.IsUnknown() {
		v.State = other.State
	}

	if (v.Total.IsUnknown() || v.Total.IsNull()) && !other.Total.IsUnknown() {
		v.Total = other.Total
	}

	if (v.TransferredBytes.IsUnknown() || v.TransferredBytes.IsNull()) && !other.TransferredBytes.IsUnknown() {
		v.TransferredBytes = other.TransferredBytes
	}

	if (v.UpdatedAt.IsUnknown() || v.UpdatedAt.IsNull()) && !other.UpdatedAt.IsUnknown() {
		v.UpdatedAt = other.UpdatedAt
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v StatusDataSyncStatusProgressValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"completed":        v.Completed,
		"createdAt":        v.CreatedAt,
		"deleted":          v.Deleted,
		"direction":        v.Direction,
		"eta":              v.Eta,
		"failed":           v.Failed,
		"id":               v.Id,
		"info":             v.Info,
		"processed":        v.Processed,
		"skipped":          v.Skipped,
		"state":            v.State,
		"total":            v.Total,
		"transferredBytes": v.TransferredBytes,
		"updatedAt":        v.UpdatedAt,
	}
}
func (v StatusDataSyncStatusProgressValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 14)

	var val tftypes.Value
	var err error

	attrTypes["completed"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["created_at"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["deleted"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["direction"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["eta"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["failed"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["info"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["processed"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["skipped"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["state"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["total"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["transferred_bytes"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["updated_at"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 14)

		val, err = v.Completed.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["completed"] = val

		val, err = v.CreatedAt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["created_at"] = val

		val, err = v.Deleted.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["deleted"] = val

		val, err = v.Direction.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["direction"] = val

		val, err = v.Eta.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["eta"] = val

		val, err = v.Failed.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["failed"] = val

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.Info.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["info"] = val

		val, err = v.Processed.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["processed"] = val

		val, err = v.Skipped.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["skipped"] = val

		val, err = v.State.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["state"] = val

		val, err = v.Total.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["total"] = val

		val, err = v.TransferredBytes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["transferred_bytes"] = val

		val, err = v.UpdatedAt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["updated_at"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v StatusDataSyncStatusProgressValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v StatusDataSyncStatusProgressValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v StatusDataSyncStatusProgressValue) String() string {
	return "StatusDataSyncStatusProgressValue"
}

func (v StatusDataSyncStatusProgressValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"completed":         ovhtypes.TfInt64Type{},
			"created_at":        ovhtypes.TfStringType{},
			"deleted":           ovhtypes.TfInt64Type{},
			"direction":         ovhtypes.TfStringType{},
			"eta":               ovhtypes.TfInt64Type{},
			"failed":            ovhtypes.TfInt64Type{},
			"id":                ovhtypes.TfStringType{},
			"info":              ovhtypes.TfStringType{},
			"processed":         ovhtypes.TfInt64Type{},
			"skipped":           ovhtypes.TfInt64Type{},
			"state":             ovhtypes.TfStringType{},
			"total":             ovhtypes.TfInt64Type{},
			"transferred_bytes": ovhtypes.TfInt64Type{},
			"updated_at":        ovhtypes.TfStringType{},
		},
		map[string]attr.Value{
			"completed":         v.Completed,
			"created_at":        v.CreatedAt,
			"deleted":           v.Deleted,
			"direction":         v.Direction,
			"eta":               v.Eta,
			"failed":            v.Failed,
			"id":                v.Id,
			"info":              v.Info,
			"processed":         v.Processed,
			"skipped":           v.Skipped,
			"state":             v.State,
			"total":             v.Total,
			"transferred_bytes": v.TransferredBytes,
			"updated_at":        v.UpdatedAt,
		})

	return objVal, diags
}

func (v StatusDataSyncStatusProgressValue) Equal(o attr.Value) bool {
	other, ok := o.(StatusDataSyncStatusProgressValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Completed.Equal(other.Completed) {
		return false
	}

	if !v.CreatedAt.Equal(other.CreatedAt) {
		return false
	}

	if !v.Deleted.Equal(other.Deleted) {
		return false
	}

	if !v.Direction.Equal(other.Direction) {
		return false
	}

	if !v.Eta.Equal(other.Eta) {
		return false
	}

	if !v.Failed.Equal(other.Failed) {
		return false
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.Info.Equal(other.Info) {
		return false
	}

	if !v.Processed.Equal(other.Processed) {
		return false
	}

	if !v.Skipped.Equal(other.Skipped) {
		return false
	}

	if !v.State.Equal(other.State) {
		return false
	}

	if !v.Total.Equal(other.Total) {
		return false
	}

	if !v.TransferredBytes.Equal(other.TransferredBytes) {
		return false
	}

	if !v.UpdatedAt.Equal(other.UpdatedAt) {
		return false
	}

	return true
}

func (v StatusDataSyncStatusProgressValue) Type(ctx context.Context) attr.Type {
	return StatusDataSyncStatusProgressType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v StatusDataSyncStatusProgressValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"completed":         ovhtypes.TfInt64Type{},
		"created_at":        ovhtypes.TfStringType{},
		"deleted":           ovhtypes.TfInt64Type{},
		"direction":         ovhtypes.TfStringType{},
		"eta":               ovhtypes.TfInt64Type{},
		"failed":            ovhtypes.TfInt64Type{},
		"id":                ovhtypes.TfStringType{},
		"info":              ovhtypes.TfStringType{},
		"processed":         ovhtypes.TfInt64Type{},
		"skipped":           ovhtypes.TfInt64Type{},
		"state":             ovhtypes.TfStringType{},
		"total":             ovhtypes.TfInt64Type{},
		"transferred_bytes": ovhtypes.TfInt64Type{},
		"updated_at":        ovhtypes.TfStringType{},
	}
}

var _ basetypes.ObjectTypable = StatusHistoryType{}

type StatusHistoryType struct {
	basetypes.ObjectType
}

func (t StatusHistoryType) Equal(o attr.Type) bool {
	other, ok := o.(StatusHistoryType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t StatusHistoryType) String() string {
	return "StatusHistoryType"
}

func (t StatusHistoryType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	dateAttribute, ok := attributes["date"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`date is missing from object`)

		return nil, diags
	}

	dateVal, ok := dateAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`date expected to be ovhtypes.TfStringValue, was: %T`, dateAttribute))
	}

	stateAttribute, ok := attributes["state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`state is missing from object`)

		return nil, diags
	}

	stateVal, ok := stateAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`state expected to be ovhtypes.TfStringValue, was: %T`, stateAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return StatusHistoryValue{
		Date:  dateVal,
		State: stateVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewStatusHistoryValueNull() StatusHistoryValue {
	return StatusHistoryValue{
		state: attr.ValueStateNull,
	}
}

func NewStatusHistoryValueUnknown() StatusHistoryValue {
	return StatusHistoryValue{
		state: attr.ValueStateUnknown,
	}
}

func NewStatusHistoryValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (StatusHistoryValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing StatusHistoryValue Attribute Value",
				"While creating a StatusHistoryValue value, a missing attribute value was detected. "+
					"A StatusHistoryValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StatusHistoryValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid StatusHistoryValue Attribute Type",
				"While creating a StatusHistoryValue value, an invalid attribute value was detected. "+
					"A StatusHistoryValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StatusHistoryValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("StatusHistoryValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra StatusHistoryValue Attribute Value",
				"While creating a StatusHistoryValue value, an extra attribute value was detected. "+
					"A StatusHistoryValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra StatusHistoryValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewStatusHistoryValueUnknown(), diags
	}

	dateAttribute, ok := attributes["date"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`date is missing from object`)

		return NewStatusHistoryValueUnknown(), diags
	}

	dateVal, ok := dateAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`date expected to be ovhtypes.TfStringValue, was: %T`, dateAttribute))
	}

	stateAttribute, ok := attributes["state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`state is missing from object`)

		return NewStatusHistoryValueUnknown(), diags
	}

	stateVal, ok := stateAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`state expected to be ovhtypes.TfStringValue, was: %T`, stateAttribute))
	}

	if diags.HasError() {
		return NewStatusHistoryValueUnknown(), diags
	}

	return StatusHistoryValue{
		Date:  dateVal,
		State: stateVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewStatusHistoryValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) StatusHistoryValue {
	object, diags := NewStatusHistoryValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewStatusHistoryValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t StatusHistoryType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewStatusHistoryValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewStatusHistoryValueUnknown(), nil
	}

	if in.IsNull() {
		return NewStatusHistoryValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewStatusHistoryValueMust(StatusHistoryValue{}.AttributeTypes(ctx), attributes), nil
}

func (t StatusHistoryType) ValueType(ctx context.Context) attr.Value {
	return StatusHistoryValue{}
}

var _ basetypes.ObjectValuable = StatusHistoryValue{}

type StatusHistoryValue struct {
	Date  ovhtypes.TfStringValue `tfsdk:"date" json:"date"`
	State ovhtypes.TfStringValue `tfsdk:"state" json:"state"`
	state attr.ValueState
}

func (v *StatusHistoryValue) UnmarshalJSON(data []byte) error {
	type JsonStatusHistoryValue StatusHistoryValue

	var tmp JsonStatusHistoryValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.Date = tmp.Date
	v.State = tmp.State

	v.state = attr.ValueStateKnown

	return nil
}

func (v *StatusHistoryValue) MergeWith(other *StatusHistoryValue) {

	if (v.Date.IsUnknown() || v.Date.IsNull()) && !other.Date.IsUnknown() {
		v.Date = other.Date
	}

	if (v.State.IsUnknown() || v.State.IsNull()) && !other.State.IsUnknown() {
		v.State = other.State
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v StatusHistoryValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"date":  v.Date,
		"state": v.State,
	}
}
func (v StatusHistoryValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["date"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["state"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Date.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["date"] = val

		val, err = v.State.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["state"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v StatusHistoryValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v StatusHistoryValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v StatusHistoryValue) String() string {
	return "StatusHistoryValue"
}

func (v StatusHistoryValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"date":  ovhtypes.TfStringType{},
			"state": ovhtypes.TfStringType{},
		},
		map[string]attr.Value{
			"date":  v.Date,
			"state": v.State,
		})

	return objVal, diags
}

func (v StatusHistoryValue) Equal(o attr.Value) bool {
	other, ok := o.(StatusHistoryValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Date.Equal(other.Date) {
		return false
	}

	if !v.State.Equal(other.State) {
		return false
	}

	return true
}

func (v StatusHistoryValue) Type(ctx context.Context) attr.Type {
	return StatusHistoryType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v StatusHistoryValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"date":  ovhtypes.TfStringType{},
		"state": ovhtypes.TfStringType{},
	}
}

var _ basetypes.ObjectTypable = StatusInfoType{}

type StatusInfoType struct {
	basetypes.ObjectType
}

func (t StatusInfoType) Equal(o attr.Type) bool {
	other, ok := o.(StatusInfoType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t StatusInfoType) String() string {
	return "StatusInfoType"
}

func (t StatusInfoType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	codeAttribute, ok := attributes["code"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`code is missing from object`)

		return nil, diags
	}

	codeVal, ok := codeAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`code expected to be ovhtypes.TfStringValue, was: %T`, codeAttribute))
	}

	messageAttribute, ok := attributes["message"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`message is missing from object`)

		return nil, diags
	}

	messageVal, ok := messageAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`message expected to be ovhtypes.TfStringValue, was: %T`, messageAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return StatusInfoValue{
		Code:    codeVal,
		Message: messageVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewStatusInfoValueNull() StatusInfoValue {
	return StatusInfoValue{
		state: attr.ValueStateNull,
	}
}

func NewStatusInfoValueUnknown() StatusInfoValue {
	return StatusInfoValue{
		state: attr.ValueStateUnknown,
	}
}

func NewStatusInfoValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (StatusInfoValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing StatusInfoValue Attribute Value",
				"While creating a StatusInfoValue value, a missing attribute value was detected. "+
					"A StatusInfoValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StatusInfoValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid StatusInfoValue Attribute Type",
				"While creating a StatusInfoValue value, an invalid attribute value was detected. "+
					"A StatusInfoValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StatusInfoValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("StatusInfoValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra StatusInfoValue Attribute Value",
				"While creating a StatusInfoValue value, an extra attribute value was detected. "+
					"A StatusInfoValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra StatusInfoValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewStatusInfoValueUnknown(), diags
	}

	codeAttribute, ok := attributes["code"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`code is missing from object`)

		return NewStatusInfoValueUnknown(), diags
	}

	codeVal, ok := codeAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`code expected to be ovhtypes.TfStringValue, was: %T`, codeAttribute))
	}

	messageAttribute, ok := attributes["message"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`message is missing from object`)

		return NewStatusInfoValueUnknown(), diags
	}

	messageVal, ok := messageAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`message expected to be ovhtypes.TfStringValue, was: %T`, messageAttribute))
	}

	if diags.HasError() {
		return NewStatusInfoValueUnknown(), diags
	}

	return StatusInfoValue{
		Code:    codeVal,
		Message: messageVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewStatusInfoValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) StatusInfoValue {
	object, diags := NewStatusInfoValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewStatusInfoValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t StatusInfoType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewStatusInfoValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewStatusInfoValueUnknown(), nil
	}

	if in.IsNull() {
		return NewStatusInfoValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewStatusInfoValueMust(StatusInfoValue{}.AttributeTypes(ctx), attributes), nil
}

func (t StatusInfoType) ValueType(ctx context.Context) attr.Value {
	return StatusInfoValue{}
}

var _ basetypes.ObjectValuable = StatusInfoValue{}

type StatusInfoValue struct {
	Code    ovhtypes.TfStringValue `tfsdk:"code" json:"code"`
	Message ovhtypes.TfStringValue `tfsdk:"message" json:"message"`
	state   attr.ValueState
}

func (v *StatusInfoValue) UnmarshalJSON(data []byte) error {
	type JsonStatusInfoValue StatusInfoValue

	var tmp JsonStatusInfoValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.Code = tmp.Code
	v.Message = tmp.Message

	v.state = attr.ValueStateKnown

	return nil
}

func (v *StatusInfoValue) MergeWith(other *StatusInfoValue) {

	if (v.Code.IsUnknown() || v.Code.IsNull()) && !other.Code.IsUnknown() {
		v.Code = other.Code
	}

	if (v.Message.IsUnknown() || v.Message.IsNull()) && !other.Message.IsUnknown() {
		v.Message = other.Message
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v StatusInfoValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"code":    v.Code,
		"message": v.Message,
	}
}
func (v StatusInfoValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["code"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["message"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Code.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["code"] = val

		val, err = v.Message.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["message"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v StatusInfoValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v StatusInfoValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v StatusInfoValue) String() string {
	return "StatusInfoValue"
}

func (v StatusInfoValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"code":    ovhtypes.TfStringType{},
			"message": ovhtypes.TfStringType{},
		},
		map[string]attr.Value{
			"code":    v.Code,
			"message": v.Message,
		})

	return objVal, diags
}

func (v StatusInfoValue) Equal(o attr.Value) bool {
	other, ok := o.(StatusInfoValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Code.Equal(other.Code) {
		return false
	}

	if !v.Message.Equal(other.Message) {
		return false
	}

	return true
}

func (v StatusInfoValue) Type(ctx context.Context) attr.Type {
	return StatusInfoType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v StatusInfoValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"code":    ovhtypes.TfStringType{},
		"message": ovhtypes.TfStringType{},
	}
}

var _ basetypes.ObjectTypable = StatusVolumesType{}

type StatusVolumesType struct {
	basetypes.ObjectType
}

func (t StatusVolumesType) Equal(o attr.Type) bool {
	other, ok := o.(StatusVolumesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t StatusVolumesType) String() string {
	return "StatusVolumesType"
}

func (t StatusVolumesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be ovhtypes.TfStringValue, was: %T`, idAttribute))
	}

	mountPathAttribute, ok := attributes["mount_path"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mount_path is missing from object`)

		return nil, diags
	}

	mountPathVal, ok := mountPathAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mount_path expected to be ovhtypes.TfStringValue, was: %T`, mountPathAttribute))
	}

	userVolumeIdAttribute, ok := attributes["user_volume_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`user_volume_id is missing from object`)

		return nil, diags
	}

	userVolumeIdVal, ok := userVolumeIdAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`user_volume_id expected to be ovhtypes.TfStringValue, was: %T`, userVolumeIdAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return StatusVolumesValue{
		Id:           idVal,
		MountPath:    mountPathVal,
		UserVolumeId: userVolumeIdVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewStatusVolumesValueNull() StatusVolumesValue {
	return StatusVolumesValue{
		state: attr.ValueStateNull,
	}
}

func NewStatusVolumesValueUnknown() StatusVolumesValue {
	return StatusVolumesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewStatusVolumesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (StatusVolumesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing StatusVolumesValue Attribute Value",
				"While creating a StatusVolumesValue value, a missing attribute value was detected. "+
					"A StatusVolumesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StatusVolumesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid StatusVolumesValue Attribute Type",
				"While creating a StatusVolumesValue value, an invalid attribute value was detected. "+
					"A StatusVolumesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StatusVolumesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("StatusVolumesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra StatusVolumesValue Attribute Value",
				"While creating a StatusVolumesValue value, an extra attribute value was detected. "+
					"A StatusVolumesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra StatusVolumesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewStatusVolumesValueUnknown(), diags
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewStatusVolumesValueUnknown(), diags
	}

	idVal, ok := idAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be ovhtypes.TfStringValue, was: %T`, idAttribute))
	}

	mountPathAttribute, ok := attributes["mount_path"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mount_path is missing from object`)

		return NewStatusVolumesValueUnknown(), diags
	}

	mountPathVal, ok := mountPathAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mount_path expected to be ovhtypes.TfStringValue, was: %T`, mountPathAttribute))
	}

	userVolumeIdAttribute, ok := attributes["user_volume_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`user_volume_id is missing from object`)

		return NewStatusVolumesValueUnknown(), diags
	}

	userVolumeIdVal, ok := userVolumeIdAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`user_volume_id expected to be ovhtypes.TfStringValue, was: %T`, userVolumeIdAttribute))
	}

	if diags.HasError() {
		return NewStatusVolumesValueUnknown(), diags
	}

	return StatusVolumesValue{
		Id:           idVal,
		MountPath:    mountPathVal,
		UserVolumeId: userVolumeIdVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewStatusVolumesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) StatusVolumesValue {
	object, diags := NewStatusVolumesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewStatusVolumesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t StatusVolumesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewStatusVolumesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewStatusVolumesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewStatusVolumesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewStatusVolumesValueMust(StatusVolumesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t StatusVolumesType) ValueType(ctx context.Context) attr.Value {
	return StatusVolumesValue{}
}

var _ basetypes.ObjectValuable = StatusVolumesValue{}

type StatusVolumesValue struct {
	Id           ovhtypes.TfStringValue `tfsdk:"id" json:"id"`
	MountPath    ovhtypes.TfStringValue `tfsdk:"mount_path" json:"mountPath"`
	UserVolumeId ovhtypes.TfStringValue `tfsdk:"user_volume_id" json:"userVolumeId"`
	state        attr.ValueState
}

func (v *StatusVolumesValue) UnmarshalJSON(data []byte) error {
	type JsonStatusVolumesValue StatusVolumesValue

	var tmp JsonStatusVolumesValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.Id = tmp.Id
	v.MountPath = tmp.MountPath
	v.UserVolumeId = tmp.UserVolumeId

	v.state = attr.ValueStateKnown

	return nil
}

func (v *StatusVolumesValue) MergeWith(other *StatusVolumesValue) {

	if (v.Id.IsUnknown() || v.Id.IsNull()) && !other.Id.IsUnknown() {
		v.Id = other.Id
	}

	if (v.MountPath.IsUnknown() || v.MountPath.IsNull()) && !other.MountPath.IsUnknown() {
		v.MountPath = other.MountPath
	}

	if (v.UserVolumeId.IsUnknown() || v.UserVolumeId.IsNull()) && !other.UserVolumeId.IsUnknown() {
		v.UserVolumeId = other.UserVolumeId
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v StatusVolumesValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"id":           v.Id,
		"mountPath":    v.MountPath,
		"userVolumeId": v.UserVolumeId,
	}
}
func (v StatusVolumesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["mount_path"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["user_volume_id"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.MountPath.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mount_path"] = val

		val, err = v.UserVolumeId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["user_volume_id"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v StatusVolumesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v StatusVolumesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v StatusVolumesValue) String() string {
	return "StatusVolumesValue"
}

func (v StatusVolumesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"id":             ovhtypes.TfStringType{},
			"mount_path":     ovhtypes.TfStringType{},
			"user_volume_id": ovhtypes.TfStringType{},
		},
		map[string]attr.Value{
			"id":             v.Id,
			"mount_path":     v.MountPath,
			"user_volume_id": v.UserVolumeId,
		})

	return objVal, diags
}

func (v StatusVolumesValue) Equal(o attr.Value) bool {
	other, ok := o.(StatusVolumesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.MountPath.Equal(other.MountPath) {
		return false
	}

	if !v.UserVolumeId.Equal(other.UserVolumeId) {
		return false
	}

	return true
}

func (v StatusVolumesValue) Type(ctx context.Context) attr.Type {
	return StatusVolumesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v StatusVolumesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"id":             ovhtypes.TfStringType{},
		"mount_path":     ovhtypes.TfStringType{},
		"user_volume_id": ovhtypes.TfStringType{},
	}
}

var _ basetypes.ObjectTypable = VolumesType{}

type VolumesType struct {
	basetypes.ObjectType
}

func (t VolumesType) Equal(o attr.Type) bool {
	other, ok := o.(VolumesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t VolumesType) String() string {
	return "VolumesType"
}

func (t VolumesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	cacheAttribute, ok := attributes["cache"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cache is missing from object`)

		return nil, diags
	}

	cacheVal, ok := cacheAttribute.(ovhtypes.TfBoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cache expected to be ovhtypes.TfBoolValue, was: %T`, cacheAttribute))
	}

	containerAttribute, ok := attributes["container"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`container is missing from object`)

		return nil, diags
	}

	containerVal, ok := containerAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`container expected to be ovhtypes.TfStringValue, was: %T`, containerAttribute))
	}

	dataStoreAttribute, ok := attributes["data_store"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`data_store is missing from object`)

		return nil, diags
	}

	dataStoreVal, ok := dataStoreAttribute.(VolumesDataStoreValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`data_store expected to be VolumesDataStoreValue, was: %T`, dataStoreAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be ovhtypes.TfStringValue, was: %T`, idAttribute))
	}

	mountPathAttribute, ok := attributes["mount_path"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mount_path is missing from object`)

		return nil, diags
	}

	mountPathVal, ok := mountPathAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mount_path expected to be ovhtypes.TfStringValue, was: %T`, mountPathAttribute))
	}

	permissionAttribute, ok := attributes["permission"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`permission is missing from object`)

		return nil, diags
	}

	permissionVal, ok := permissionAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`permission expected to be ovhtypes.TfStringValue, was: %T`, permissionAttribute))
	}

	prefixAttribute, ok := attributes["prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix is missing from object`)

		return nil, diags
	}

	prefixVal, ok := prefixAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix expected to be ovhtypes.TfStringValue, was: %T`, prefixAttribute))
	}

	privateSwiftAttribute, ok := attributes["private_swift"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`private_swift is missing from object`)

		return nil, diags
	}

	privateSwiftVal, ok := privateSwiftAttribute.(VolumesPrivateSwiftValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`private_swift expected to be VolumesPrivateSwiftValue, was: %T`, privateSwiftAttribute))
	}

	publicGitAttribute, ok := attributes["public_git"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`public_git is missing from object`)

		return nil, diags
	}

	publicGitVal, ok := publicGitAttribute.(VolumesPublicGitValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`public_git expected to be VolumesPublicGitValue, was: %T`, publicGitAttribute))
	}

	publicSwiftAttribute, ok := attributes["public_swift"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`public_swift is missing from object`)

		return nil, diags
	}

	publicSwiftVal, ok := publicSwiftAttribute.(VolumesPublicSwiftValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`public_swift expected to be VolumesPublicSwiftValue, was: %T`, publicSwiftAttribute))
	}

	regionAttribute, ok := attributes["region"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`region is missing from object`)

		return nil, diags
	}

	regionVal, ok := regionAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`region expected to be ovhtypes.TfStringValue, was: %T`, regionAttribute))
	}

	standaloneAttribute, ok := attributes["standalone"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`standalone is missing from object`)

		return nil, diags
	}

	standaloneVal, ok := standaloneAttribute.(VolumesStandaloneValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`standalone expected to be VolumesStandaloneValue, was: %T`, standaloneAttribute))
	}

	targetDataStoreAttribute, ok := attributes["target_data_store"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`target_data_store is missing from object`)

		return nil, diags
	}

	targetDataStoreVal, ok := targetDataStoreAttribute.(VolumesTargetDataStoreValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`target_data_store expected to be VolumesTargetDataStoreValue, was: %T`, targetDataStoreAttribute))
	}

	targetPrivateSwiftAttribute, ok := attributes["target_private_swift"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`target_private_swift is missing from object`)

		return nil, diags
	}

	targetPrivateSwiftVal, ok := targetPrivateSwiftAttribute.(VolumesTargetPrivateSwiftValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`target_private_swift expected to be VolumesTargetPrivateSwiftValue, was: %T`, targetPrivateSwiftAttribute))
	}

	volumeSourceAttribute, ok := attributes["volume_source"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_source is missing from object`)

		return nil, diags
	}

	volumeSourceVal, ok := volumeSourceAttribute.(VolumesVolumeSourceValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_source expected to be VolumesVolumeSourceValue, was: %T`, volumeSourceAttribute))
	}

	volumeTargetAttribute, ok := attributes["volume_target"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_target is missing from object`)

		return nil, diags
	}

	volumeTargetVal, ok := volumeTargetAttribute.(VolumesVolumeTargetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_target expected to be VolumesVolumeTargetValue, was: %T`, volumeTargetAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return VolumesValue{
		Cache:              cacheVal,
		Container:          containerVal,
		DataStore:          dataStoreVal,
		Id:                 idVal,
		MountPath:          mountPathVal,
		Permission:         permissionVal,
		Prefix:             prefixVal,
		PrivateSwift:       privateSwiftVal,
		PublicGit:          publicGitVal,
		PublicSwift:        publicSwiftVal,
		Region:             regionVal,
		Standalone:         standaloneVal,
		TargetDataStore:    targetDataStoreVal,
		TargetPrivateSwift: targetPrivateSwiftVal,
		VolumeSource:       volumeSourceVal,
		VolumeTarget:       volumeTargetVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewVolumesValueNull() VolumesValue {
	return VolumesValue{
		state: attr.ValueStateNull,
	}
}

func NewVolumesValueUnknown() VolumesValue {
	return VolumesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewVolumesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (VolumesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing VolumesValue Attribute Value",
				"While creating a VolumesValue value, a missing attribute value was detected. "+
					"A VolumesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VolumesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid VolumesValue Attribute Type",
				"While creating a VolumesValue value, an invalid attribute value was detected. "+
					"A VolumesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VolumesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("VolumesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra VolumesValue Attribute Value",
				"While creating a VolumesValue value, an extra attribute value was detected. "+
					"A VolumesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra VolumesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewVolumesValueUnknown(), diags
	}

	cacheAttribute, ok := attributes["cache"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cache is missing from object`)

		return NewVolumesValueUnknown(), diags
	}

	cacheVal, ok := cacheAttribute.(ovhtypes.TfBoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cache expected to be ovhtypes.TfBoolValue, was: %T`, cacheAttribute))
	}

	containerAttribute, ok := attributes["container"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`container is missing from object`)

		return NewVolumesValueUnknown(), diags
	}

	containerVal, ok := containerAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`container expected to be ovhtypes.TfStringValue, was: %T`, containerAttribute))
	}

	dataStoreAttribute, ok := attributes["data_store"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`data_store is missing from object`)

		return NewVolumesValueUnknown(), diags
	}

	dataStoreVal, ok := dataStoreAttribute.(VolumesDataStoreValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`data_store expected to be VolumesDataStoreValue, was: %T`, dataStoreAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewVolumesValueUnknown(), diags
	}

	idVal, ok := idAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be ovhtypes.TfStringValue, was: %T`, idAttribute))
	}

	mountPathAttribute, ok := attributes["mount_path"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mount_path is missing from object`)

		return NewVolumesValueUnknown(), diags
	}

	mountPathVal, ok := mountPathAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mount_path expected to be ovhtypes.TfStringValue, was: %T`, mountPathAttribute))
	}

	permissionAttribute, ok := attributes["permission"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`permission is missing from object`)

		return NewVolumesValueUnknown(), diags
	}

	permissionVal, ok := permissionAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`permission expected to be ovhtypes.TfStringValue, was: %T`, permissionAttribute))
	}

	prefixAttribute, ok := attributes["prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix is missing from object`)

		return NewVolumesValueUnknown(), diags
	}

	prefixVal, ok := prefixAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix expected to be ovhtypes.TfStringValue, was: %T`, prefixAttribute))
	}

	privateSwiftAttribute, ok := attributes["private_swift"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`private_swift is missing from object`)

		return NewVolumesValueUnknown(), diags
	}

	privateSwiftVal, ok := privateSwiftAttribute.(VolumesPrivateSwiftValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`private_swift expected to be VolumesPrivateSwiftValue, was: %T`, privateSwiftAttribute))
	}

	publicGitAttribute, ok := attributes["public_git"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`public_git is missing from object`)

		return NewVolumesValueUnknown(), diags
	}

	publicGitVal, ok := publicGitAttribute.(VolumesPublicGitValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`public_git expected to be VolumesPublicGitValue, was: %T`, publicGitAttribute))
	}

	publicSwiftAttribute, ok := attributes["public_swift"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`public_swift is missing from object`)

		return NewVolumesValueUnknown(), diags
	}

	publicSwiftVal, ok := publicSwiftAttribute.(VolumesPublicSwiftValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`public_swift expected to be VolumesPublicSwiftValue, was: %T`, publicSwiftAttribute))
	}

	regionAttribute, ok := attributes["region"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`region is missing from object`)

		return NewVolumesValueUnknown(), diags
	}

	regionVal, ok := regionAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`region expected to be ovhtypes.TfStringValue, was: %T`, regionAttribute))
	}

	standaloneAttribute, ok := attributes["standalone"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`standalone is missing from object`)

		return NewVolumesValueUnknown(), diags
	}

	standaloneVal, ok := standaloneAttribute.(VolumesStandaloneValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`standalone expected to be VolumesStandaloneValue, was: %T`, standaloneAttribute))
	}

	targetDataStoreAttribute, ok := attributes["target_data_store"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`target_data_store is missing from object`)

		return NewVolumesValueUnknown(), diags
	}

	targetDataStoreVal, ok := targetDataStoreAttribute.(VolumesTargetDataStoreValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`target_data_store expected to be VolumesTargetDataStoreValue, was: %T`, targetDataStoreAttribute))
	}

	targetPrivateSwiftAttribute, ok := attributes["target_private_swift"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`target_private_swift is missing from object`)

		return NewVolumesValueUnknown(), diags
	}

	targetPrivateSwiftVal, ok := targetPrivateSwiftAttribute.(VolumesTargetPrivateSwiftValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`target_private_swift expected to be VolumesTargetPrivateSwiftValue, was: %T`, targetPrivateSwiftAttribute))
	}

	volumeSourceAttribute, ok := attributes["volume_source"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_source is missing from object`)

		return NewVolumesValueUnknown(), diags
	}

	volumeSourceVal, ok := volumeSourceAttribute.(VolumesVolumeSourceValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_source expected to be VolumesVolumeSourceValue, was: %T`, volumeSourceAttribute))
	}

	volumeTargetAttribute, ok := attributes["volume_target"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_target is missing from object`)

		return NewVolumesValueUnknown(), diags
	}

	volumeTargetVal, ok := volumeTargetAttribute.(VolumesVolumeTargetValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_target expected to be VolumesVolumeTargetValue, was: %T`, volumeTargetAttribute))
	}

	if diags.HasError() {
		return NewVolumesValueUnknown(), diags
	}

	return VolumesValue{
		Cache:              cacheVal,
		Container:          containerVal,
		DataStore:          dataStoreVal,
		Id:                 idVal,
		MountPath:          mountPathVal,
		Permission:         permissionVal,
		Prefix:             prefixVal,
		PrivateSwift:       privateSwiftVal,
		PublicGit:          publicGitVal,
		PublicSwift:        publicSwiftVal,
		Region:             regionVal,
		Standalone:         standaloneVal,
		TargetDataStore:    targetDataStoreVal,
		TargetPrivateSwift: targetPrivateSwiftVal,
		VolumeSource:       volumeSourceVal,
		VolumeTarget:       volumeTargetVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewVolumesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) VolumesValue {
	object, diags := NewVolumesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewVolumesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t VolumesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewVolumesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewVolumesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewVolumesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewVolumesValueMust(VolumesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t VolumesType) ValueType(ctx context.Context) attr.Value {
	return VolumesValue{}
}

var _ basetypes.ObjectValuable = VolumesValue{}

type VolumesValue struct {
	Cache              ovhtypes.TfBoolValue           `tfsdk:"cache" json:"cache"`
	Container          ovhtypes.TfStringValue         `tfsdk:"container" json:"container"`
	DataStore          VolumesDataStoreValue          `tfsdk:"data_store" json:"dataStore"`
	Id                 ovhtypes.TfStringValue         `tfsdk:"id" json:"id"`
	MountPath          ovhtypes.TfStringValue         `tfsdk:"mount_path" json:"mountPath"`
	Permission         ovhtypes.TfStringValue         `tfsdk:"permission" json:"permission"`
	Prefix             ovhtypes.TfStringValue         `tfsdk:"prefix" json:"prefix"`
	PrivateSwift       VolumesPrivateSwiftValue       `tfsdk:"private_swift" json:"privateSwift"`
	PublicGit          VolumesPublicGitValue          `tfsdk:"public_git" json:"publicGit"`
	PublicSwift        VolumesPublicSwiftValue        `tfsdk:"public_swift" json:"publicSwift"`
	Region             ovhtypes.TfStringValue         `tfsdk:"region" json:"region"`
	Standalone         VolumesStandaloneValue         `tfsdk:"standalone" json:"standalone"`
	TargetDataStore    VolumesTargetDataStoreValue    `tfsdk:"target_data_store" json:"targetDataStore"`
	TargetPrivateSwift VolumesTargetPrivateSwiftValue `tfsdk:"target_private_swift" json:"targetPrivateSwift"`
	VolumeSource       VolumesVolumeSourceValue       `tfsdk:"volume_source" json:"volumeSource"`
	VolumeTarget       VolumesVolumeTargetValue       `tfsdk:"volume_target" json:"volumeTarget"`
	state              attr.ValueState
}

func (v VolumesValue) ToCreate() *VolumesValue {
	res := &VolumesValue{}

	if !v.VolumeSource.IsNull() {
		res.VolumeSource = v.VolumeSource
	}

	if !v.TargetPrivateSwift.IsNull() {
		res.TargetPrivateSwift = v.TargetPrivateSwift
	}

	if !v.VolumeTarget.IsNull() {
		res.VolumeTarget = v.VolumeTarget
	}

	if !v.PrivateSwift.IsNull() {
		res.PrivateSwift = v.PrivateSwift
	}

	if !v.Prefix.IsNull() {
		res.Prefix = v.Prefix
	}

	if !v.Region.IsNull() {
		res.Region = v.Region
	}

	if !v.Cache.IsNull() {
		res.Cache = v.Cache
	}

	if !v.Permission.IsNull() {
		res.Permission = v.Permission
	}

	if !v.Container.IsNull() {
		res.Container = v.Container
	}

	if !v.PublicGit.IsNull() {
		res.PublicGit = v.PublicGit
	}

	if !v.PublicSwift.IsNull() {
		res.PublicSwift = v.PublicSwift
	}

	if !v.TargetDataStore.IsNull() {
		res.TargetDataStore = v.TargetDataStore
	}

	if !v.Standalone.IsNull() {
		res.Standalone = v.Standalone
	}

	if !v.MountPath.IsNull() {
		res.MountPath = v.MountPath
	}

	if !v.DataStore.IsNull() {
		res.DataStore = v.DataStore
	}

	res.state = attr.ValueStateKnown

	return res
}

func (v VolumesValue) MarshalJSON() ([]byte, error) {
	toMarshal := map[string]any{}
	if !v.Cache.IsNull() && !v.Cache.IsUnknown() {
		toMarshal["cache"] = v.Cache
	}
	if !v.Container.IsNull() && !v.Container.IsUnknown() {
		toMarshal["container"] = v.Container
	}
	if !v.DataStore.IsNull() && !v.DataStore.IsUnknown() {
		toMarshal["dataStore"] = v.DataStore
	}
	if !v.MountPath.IsNull() && !v.MountPath.IsUnknown() {
		toMarshal["mountPath"] = v.MountPath
	}
	if !v.Permission.IsNull() && !v.Permission.IsUnknown() {
		toMarshal["permission"] = v.Permission
	}
	if !v.Prefix.IsNull() && !v.Prefix.IsUnknown() {
		toMarshal["prefix"] = v.Prefix
	}
	if !v.PrivateSwift.IsNull() && !v.PrivateSwift.IsUnknown() {
		toMarshal["privateSwift"] = v.PrivateSwift
	}
	if !v.PublicGit.IsNull() && !v.PublicGit.IsUnknown() {
		toMarshal["publicGit"] = v.PublicGit
	}
	if !v.PublicSwift.IsNull() && !v.PublicSwift.IsUnknown() {
		toMarshal["publicSwift"] = v.PublicSwift
	}
	if !v.Region.IsNull() && !v.Region.IsUnknown() {
		toMarshal["region"] = v.Region
	}
	if !v.Standalone.IsNull() && !v.Standalone.IsUnknown() {
		toMarshal["standalone"] = v.Standalone
	}
	if !v.TargetDataStore.IsNull() && !v.TargetDataStore.IsUnknown() {
		toMarshal["targetDataStore"] = v.TargetDataStore
	}
	if !v.TargetPrivateSwift.IsNull() && !v.TargetPrivateSwift.IsUnknown() {
		toMarshal["targetPrivateSwift"] = v.TargetPrivateSwift
	}
	if !v.VolumeSource.IsNull() && !v.VolumeSource.IsUnknown() {
		toMarshal["volumeSource"] = v.VolumeSource
	}
	if !v.VolumeTarget.IsNull() && !v.VolumeTarget.IsUnknown() {
		toMarshal["volumeTarget"] = v.VolumeTarget
	}

	return json.Marshal(toMarshal)
}

func (v *VolumesValue) UnmarshalJSON(data []byte) error {
	type JsonVolumesValue VolumesValue

	var tmp JsonVolumesValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.Cache = tmp.Cache
	v.Container = tmp.Container
	v.DataStore = tmp.DataStore
	v.Id = tmp.Id
	v.MountPath = tmp.MountPath
	v.Permission = tmp.Permission
	v.Prefix = tmp.Prefix
	v.PrivateSwift = tmp.PrivateSwift
	v.PublicGit = tmp.PublicGit
	v.PublicSwift = tmp.PublicSwift
	v.Region = tmp.Region
	v.Standalone = tmp.Standalone
	v.TargetDataStore = tmp.TargetDataStore
	v.TargetPrivateSwift = tmp.TargetPrivateSwift
	v.VolumeSource = tmp.VolumeSource
	v.VolumeTarget = tmp.VolumeTarget

	v.state = attr.ValueStateKnown

	return nil
}

func (v *VolumesValue) MergeWith(other *VolumesValue) {

	if (v.Cache.IsUnknown() || v.Cache.IsNull()) && !other.Cache.IsUnknown() {
		v.Cache = other.Cache
	}

	if (v.Container.IsUnknown() || v.Container.IsNull()) && !other.Container.IsUnknown() {
		v.Container = other.Container
	}

	if v.DataStore.IsUnknown() && !other.DataStore.IsUnknown() {
		v.DataStore = other.DataStore
	} else if !other.DataStore.IsUnknown() {
		v.DataStore.MergeWith(&other.DataStore)
	}

	if (v.Id.IsUnknown() || v.Id.IsNull()) && !other.Id.IsUnknown() {
		v.Id = other.Id
	}

	if (v.MountPath.IsUnknown() || v.MountPath.IsNull()) && !other.MountPath.IsUnknown() {
		v.MountPath = other.MountPath
	}

	if (v.Permission.IsUnknown() || v.Permission.IsNull()) && !other.Permission.IsUnknown() {
		v.Permission = other.Permission
	}

	if (v.Prefix.IsUnknown() || v.Prefix.IsNull()) && !other.Prefix.IsUnknown() {
		v.Prefix = other.Prefix
	}

	if v.PrivateSwift.IsUnknown() && !other.PrivateSwift.IsUnknown() {
		v.PrivateSwift = other.PrivateSwift
	} else if !other.PrivateSwift.IsUnknown() {
		v.PrivateSwift.MergeWith(&other.PrivateSwift)
	}

	if v.PublicGit.IsUnknown() && !other.PublicGit.IsUnknown() {
		v.PublicGit = other.PublicGit
	} else if !other.PublicGit.IsUnknown() {
		v.PublicGit.MergeWith(&other.PublicGit)
	}

	if v.PublicSwift.IsUnknown() && !other.PublicSwift.IsUnknown() {
		v.PublicSwift = other.PublicSwift
	} else if !other.PublicSwift.IsUnknown() {
		v.PublicSwift.MergeWith(&other.PublicSwift)
	}

	if (v.Region.IsUnknown() || v.Region.IsNull()) && !other.Region.IsUnknown() {
		v.Region = other.Region
	}

	if v.Standalone.IsUnknown() && !other.Standalone.IsUnknown() {
		v.Standalone = other.Standalone
	} else if !other.Standalone.IsUnknown() {
		v.Standalone.MergeWith(&other.Standalone)
	}

	if v.TargetDataStore.IsUnknown() && !other.TargetDataStore.IsUnknown() {
		v.TargetDataStore = other.TargetDataStore
	} else if !other.TargetDataStore.IsUnknown() {
		v.TargetDataStore.MergeWith(&other.TargetDataStore)
	}

	if v.TargetPrivateSwift.IsUnknown() && !other.TargetPrivateSwift.IsUnknown() {
		v.TargetPrivateSwift = other.TargetPrivateSwift
	} else if !other.TargetPrivateSwift.IsUnknown() {
		v.TargetPrivateSwift.MergeWith(&other.TargetPrivateSwift)
	}

	if v.VolumeSource.IsUnknown() && !other.VolumeSource.IsUnknown() {
		v.VolumeSource = other.VolumeSource
	} else if !other.VolumeSource.IsUnknown() {
		v.VolumeSource.MergeWith(&other.VolumeSource)
	}

	if v.VolumeTarget.IsUnknown() && !other.VolumeTarget.IsUnknown() {
		v.VolumeTarget = other.VolumeTarget
	} else if !other.VolumeTarget.IsUnknown() {
		v.VolumeTarget.MergeWith(&other.VolumeTarget)
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v VolumesValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"cache":              v.Cache,
		"container":          v.Container,
		"dataStore":          v.DataStore,
		"id":                 v.Id,
		"mountPath":          v.MountPath,
		"permission":         v.Permission,
		"prefix":             v.Prefix,
		"privateSwift":       v.PrivateSwift,
		"publicGit":          v.PublicGit,
		"publicSwift":        v.PublicSwift,
		"region":             v.Region,
		"standalone":         v.Standalone,
		"targetDataStore":    v.TargetDataStore,
		"targetPrivateSwift": v.TargetPrivateSwift,
		"volumeSource":       v.VolumeSource,
		"volumeTarget":       v.VolumeTarget,
	}
}
func (v VolumesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 16)

	var val tftypes.Value
	var err error

	attrTypes["cache"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["container"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["data_store"] = basetypes.ObjectType{
		AttrTypes: VolumesDataStoreValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["mount_path"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["permission"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["prefix"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["private_swift"] = basetypes.ObjectType{
		AttrTypes: VolumesPrivateSwiftValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["public_git"] = basetypes.ObjectType{
		AttrTypes: VolumesPublicGitValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["public_swift"] = basetypes.ObjectType{
		AttrTypes: VolumesPublicSwiftValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["region"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["standalone"] = basetypes.ObjectType{
		AttrTypes: VolumesStandaloneValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["target_data_store"] = basetypes.ObjectType{
		AttrTypes: VolumesTargetDataStoreValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["target_private_swift"] = basetypes.ObjectType{
		AttrTypes: VolumesTargetPrivateSwiftValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["volume_source"] = basetypes.ObjectType{
		AttrTypes: VolumesVolumeSourceValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["volume_target"] = basetypes.ObjectType{
		AttrTypes: VolumesVolumeTargetValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 16)

		val, err = v.Cache.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cache"] = val

		val, err = v.Container.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["container"] = val

		val, err = v.DataStore.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["data_store"] = val

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.MountPath.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mount_path"] = val

		val, err = v.Permission.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["permission"] = val

		val, err = v.Prefix.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["prefix"] = val

		val, err = v.PrivateSwift.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["private_swift"] = val

		val, err = v.PublicGit.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["public_git"] = val

		val, err = v.PublicSwift.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["public_swift"] = val

		val, err = v.Region.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["region"] = val

		val, err = v.Standalone.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["standalone"] = val

		val, err = v.TargetDataStore.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["target_data_store"] = val

		val, err = v.TargetPrivateSwift.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["target_private_swift"] = val

		val, err = v.VolumeSource.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["volume_source"] = val

		val, err = v.VolumeTarget.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["volume_target"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v VolumesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v VolumesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v VolumesValue) String() string {
	return "VolumesValue"
}

func (v VolumesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"cache":     ovhtypes.TfBoolType{},
			"container": ovhtypes.TfStringType{},
			"data_store": VolumesDataStoreType{
				basetypes.ObjectType{
					AttrTypes: VolumesDataStoreValue{}.AttributeTypes(ctx),
				},
			},
			"id":         ovhtypes.TfStringType{},
			"mount_path": ovhtypes.TfStringType{},
			"permission": ovhtypes.TfStringType{},
			"prefix":     ovhtypes.TfStringType{},
			"private_swift": VolumesPrivateSwiftType{
				basetypes.ObjectType{
					AttrTypes: VolumesPrivateSwiftValue{}.AttributeTypes(ctx),
				},
			},
			"public_git": VolumesPublicGitType{
				basetypes.ObjectType{
					AttrTypes: VolumesPublicGitValue{}.AttributeTypes(ctx),
				},
			},
			"public_swift": VolumesPublicSwiftType{
				basetypes.ObjectType{
					AttrTypes: VolumesPublicSwiftValue{}.AttributeTypes(ctx),
				},
			},
			"region": ovhtypes.TfStringType{},
			"standalone": VolumesStandaloneType{
				basetypes.ObjectType{
					AttrTypes: VolumesStandaloneValue{}.AttributeTypes(ctx),
				},
			},
			"target_data_store": VolumesTargetDataStoreType{
				basetypes.ObjectType{
					AttrTypes: VolumesTargetDataStoreValue{}.AttributeTypes(ctx),
				},
			},
			"target_private_swift": VolumesTargetPrivateSwiftType{
				basetypes.ObjectType{
					AttrTypes: VolumesTargetPrivateSwiftValue{}.AttributeTypes(ctx),
				},
			},
			"volume_source": VolumesVolumeSourceType{
				basetypes.ObjectType{
					AttrTypes: VolumesVolumeSourceValue{}.AttributeTypes(ctx),
				},
			},
			"volume_target": VolumesVolumeTargetType{
				basetypes.ObjectType{
					AttrTypes: VolumesVolumeTargetValue{}.AttributeTypes(ctx),
				},
			},
		},
		map[string]attr.Value{
			"cache":                v.Cache,
			"container":            v.Container,
			"data_store":           v.DataStore,
			"id":                   v.Id,
			"mount_path":           v.MountPath,
			"permission":           v.Permission,
			"prefix":               v.Prefix,
			"private_swift":        v.PrivateSwift,
			"public_git":           v.PublicGit,
			"public_swift":         v.PublicSwift,
			"region":               v.Region,
			"standalone":           v.Standalone,
			"target_data_store":    v.TargetDataStore,
			"target_private_swift": v.TargetPrivateSwift,
			"volume_source":        v.VolumeSource,
			"volume_target":        v.VolumeTarget,
		})

	return objVal, diags
}

func (v VolumesValue) Equal(o attr.Value) bool {
	other, ok := o.(VolumesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Cache.Equal(other.Cache) {
		return false
	}

	if !v.Container.Equal(other.Container) {
		return false
	}

	if !v.DataStore.Equal(other.DataStore) {
		return false
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.MountPath.Equal(other.MountPath) {
		return false
	}

	if !v.Permission.Equal(other.Permission) {
		return false
	}

	if !v.Prefix.Equal(other.Prefix) {
		return false
	}

	if !v.PrivateSwift.Equal(other.PrivateSwift) {
		return false
	}

	if !v.PublicGit.Equal(other.PublicGit) {
		return false
	}

	if !v.PublicSwift.Equal(other.PublicSwift) {
		return false
	}

	if !v.Region.Equal(other.Region) {
		return false
	}

	if !v.Standalone.Equal(other.Standalone) {
		return false
	}

	if !v.TargetDataStore.Equal(other.TargetDataStore) {
		return false
	}

	if !v.TargetPrivateSwift.Equal(other.TargetPrivateSwift) {
		return false
	}

	if !v.VolumeSource.Equal(other.VolumeSource) {
		return false
	}

	if !v.VolumeTarget.Equal(other.VolumeTarget) {
		return false
	}

	return true
}

func (v VolumesValue) Type(ctx context.Context) attr.Type {
	return VolumesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v VolumesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"cache":                ovhtypes.TfBoolType{},
		"container":            ovhtypes.TfStringType{},
		"data_store":           VolumesDataStoreValue{}.Type(ctx),
		"id":                   ovhtypes.TfStringType{},
		"mount_path":           ovhtypes.TfStringType{},
		"permission":           ovhtypes.TfStringType{},
		"prefix":               ovhtypes.TfStringType{},
		"private_swift":        VolumesPrivateSwiftValue{}.Type(ctx),
		"public_git":           VolumesPublicGitValue{}.Type(ctx),
		"public_swift":         VolumesPublicSwiftValue{}.Type(ctx),
		"region":               ovhtypes.TfStringType{},
		"standalone":           VolumesStandaloneValue{}.Type(ctx),
		"target_data_store":    VolumesTargetDataStoreValue{}.Type(ctx),
		"target_private_swift": VolumesTargetPrivateSwiftValue{}.Type(ctx),
		"volume_source":        VolumesVolumeSourceValue{}.Type(ctx),
		"volume_target":        VolumesVolumeTargetValue{}.Type(ctx),
	}
}

var _ basetypes.ObjectTypable = VolumesDataStoreType{}

type VolumesDataStoreType struct {
	basetypes.ObjectType
}

func (t VolumesDataStoreType) Equal(o attr.Type) bool {
	other, ok := o.(VolumesDataStoreType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t VolumesDataStoreType) String() string {
	return "VolumesDataStoreType"
}

func (t VolumesDataStoreType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	aliasAttribute, ok := attributes["alias"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`alias is missing from object`)

		return nil, diags
	}

	aliasVal, ok := aliasAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`alias expected to be ovhtypes.TfStringValue, was: %T`, aliasAttribute))
	}

	archiveAttribute, ok := attributes["archive"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`archive is missing from object`)

		return nil, diags
	}

	archiveVal, ok := archiveAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`archive expected to be ovhtypes.TfStringValue, was: %T`, archiveAttribute))
	}

	containerAttribute, ok := attributes["container"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`container is missing from object`)

		return nil, diags
	}

	containerVal, ok := containerAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`container expected to be ovhtypes.TfStringValue, was: %T`, containerAttribute))
	}

	internalAttribute, ok := attributes["internal"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`internal is missing from object`)

		return nil, diags
	}

	internalVal, ok := internalAttribute.(ovhtypes.TfBoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`internal expected to be ovhtypes.TfBoolValue, was: %T`, internalAttribute))
	}

	prefixAttribute, ok := attributes["prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix is missing from object`)

		return nil, diags
	}

	prefixVal, ok := prefixAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix expected to be ovhtypes.TfStringValue, was: %T`, prefixAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return VolumesDataStoreValue{
		Alias:     aliasVal,
		Archive:   archiveVal,
		Container: containerVal,
		Internal:  internalVal,
		Prefix:    prefixVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewVolumesDataStoreValueNull() VolumesDataStoreValue {
	return VolumesDataStoreValue{
		state: attr.ValueStateNull,
	}
}

func NewVolumesDataStoreValueUnknown() VolumesDataStoreValue {
	return VolumesDataStoreValue{
		state: attr.ValueStateUnknown,
	}
}

func NewVolumesDataStoreValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (VolumesDataStoreValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing VolumesDataStoreValue Attribute Value",
				"While creating a VolumesDataStoreValue value, a missing attribute value was detected. "+
					"A VolumesDataStoreValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VolumesDataStoreValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid VolumesDataStoreValue Attribute Type",
				"While creating a VolumesDataStoreValue value, an invalid attribute value was detected. "+
					"A VolumesDataStoreValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VolumesDataStoreValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("VolumesDataStoreValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra VolumesDataStoreValue Attribute Value",
				"While creating a VolumesDataStoreValue value, an extra attribute value was detected. "+
					"A VolumesDataStoreValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra VolumesDataStoreValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewVolumesDataStoreValueUnknown(), diags
	}

	aliasAttribute, ok := attributes["alias"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`alias is missing from object`)

		return NewVolumesDataStoreValueUnknown(), diags
	}

	aliasVal, ok := aliasAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`alias expected to be ovhtypes.TfStringValue, was: %T`, aliasAttribute))
	}

	archiveAttribute, ok := attributes["archive"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`archive is missing from object`)

		return NewVolumesDataStoreValueUnknown(), diags
	}

	archiveVal, ok := archiveAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`archive expected to be ovhtypes.TfStringValue, was: %T`, archiveAttribute))
	}

	containerAttribute, ok := attributes["container"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`container is missing from object`)

		return NewVolumesDataStoreValueUnknown(), diags
	}

	containerVal, ok := containerAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`container expected to be ovhtypes.TfStringValue, was: %T`, containerAttribute))
	}

	internalAttribute, ok := attributes["internal"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`internal is missing from object`)

		return NewVolumesDataStoreValueUnknown(), diags
	}

	internalVal, ok := internalAttribute.(ovhtypes.TfBoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`internal expected to be ovhtypes.TfBoolValue, was: %T`, internalAttribute))
	}

	prefixAttribute, ok := attributes["prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix is missing from object`)

		return NewVolumesDataStoreValueUnknown(), diags
	}

	prefixVal, ok := prefixAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix expected to be ovhtypes.TfStringValue, was: %T`, prefixAttribute))
	}

	if diags.HasError() {
		return NewVolumesDataStoreValueUnknown(), diags
	}

	return VolumesDataStoreValue{
		Alias:     aliasVal,
		Archive:   archiveVal,
		Container: containerVal,
		Internal:  internalVal,
		Prefix:    prefixVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewVolumesDataStoreValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) VolumesDataStoreValue {
	object, diags := NewVolumesDataStoreValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewVolumesDataStoreValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t VolumesDataStoreType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewVolumesDataStoreValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewVolumesDataStoreValueUnknown(), nil
	}

	if in.IsNull() {
		return NewVolumesDataStoreValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewVolumesDataStoreValueMust(VolumesDataStoreValue{}.AttributeTypes(ctx), attributes), nil
}

func (t VolumesDataStoreType) ValueType(ctx context.Context) attr.Value {
	return VolumesDataStoreValue{}
}

var _ basetypes.ObjectValuable = VolumesDataStoreValue{}

type VolumesDataStoreValue struct {
	Alias     ovhtypes.TfStringValue `tfsdk:"alias" json:"alias"`
	Archive   ovhtypes.TfStringValue `tfsdk:"archive" json:"archive"`
	Container ovhtypes.TfStringValue `tfsdk:"container" json:"container"`
	Internal  ovhtypes.TfBoolValue   `tfsdk:"internal" json:"internal"`
	Prefix    ovhtypes.TfStringValue `tfsdk:"prefix" json:"prefix"`
	state     attr.ValueState
}

func (v VolumesDataStoreValue) ToCreate() *VolumesDataStoreValue {
	res := &VolumesDataStoreValue{}

	if !v.Alias.IsNull() {
		res.Alias = v.Alias
	}

	if !v.Archive.IsNull() {
		res.Archive = v.Archive
	}

	if !v.Container.IsNull() {
		res.Container = v.Container
	}

	if !v.Internal.IsNull() {
		res.Internal = v.Internal
	}

	if !v.Prefix.IsNull() {
		res.Prefix = v.Prefix
	}

	res.state = attr.ValueStateKnown

	return res
}

func (v VolumesDataStoreValue) MarshalJSON() ([]byte, error) {
	toMarshal := map[string]any{}
	if !v.Alias.IsNull() && !v.Alias.IsUnknown() {
		toMarshal["alias"] = v.Alias
	}
	if !v.Archive.IsNull() && !v.Archive.IsUnknown() {
		toMarshal["archive"] = v.Archive
	}
	if !v.Container.IsNull() && !v.Container.IsUnknown() {
		toMarshal["container"] = v.Container
	}
	if !v.Internal.IsNull() && !v.Internal.IsUnknown() {
		toMarshal["internal"] = v.Internal
	}
	if !v.Prefix.IsNull() && !v.Prefix.IsUnknown() {
		toMarshal["prefix"] = v.Prefix
	}

	return json.Marshal(toMarshal)
}

func (v *VolumesDataStoreValue) UnmarshalJSON(data []byte) error {
	type JsonVolumesDataStoreValue VolumesDataStoreValue

	var tmp JsonVolumesDataStoreValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.Alias = tmp.Alias
	v.Archive = tmp.Archive
	v.Container = tmp.Container
	v.Internal = tmp.Internal
	v.Prefix = tmp.Prefix

	v.state = attr.ValueStateKnown

	return nil
}

func (v *VolumesDataStoreValue) MergeWith(other *VolumesDataStoreValue) {

	if (v.Alias.IsUnknown() || v.Alias.IsNull()) && !other.Alias.IsUnknown() {
		v.Alias = other.Alias
	}

	if (v.Archive.IsUnknown() || v.Archive.IsNull()) && !other.Archive.IsUnknown() {
		v.Archive = other.Archive
	}

	if (v.Container.IsUnknown() || v.Container.IsNull()) && !other.Container.IsUnknown() {
		v.Container = other.Container
	}

	if (v.Internal.IsUnknown() || v.Internal.IsNull()) && !other.Internal.IsUnknown() {
		v.Internal = other.Internal
	}

	if (v.Prefix.IsUnknown() || v.Prefix.IsNull()) && !other.Prefix.IsUnknown() {
		v.Prefix = other.Prefix
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v VolumesDataStoreValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"alias":     v.Alias,
		"archive":   v.Archive,
		"container": v.Container,
		"internal":  v.Internal,
		"prefix":    v.Prefix,
	}
}
func (v VolumesDataStoreValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["alias"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["archive"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["container"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["internal"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["prefix"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.Alias.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["alias"] = val

		val, err = v.Archive.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["archive"] = val

		val, err = v.Container.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["container"] = val

		val, err = v.Internal.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["internal"] = val

		val, err = v.Prefix.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["prefix"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v VolumesDataStoreValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v VolumesDataStoreValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v VolumesDataStoreValue) String() string {
	return "VolumesDataStoreValue"
}

func (v VolumesDataStoreValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"alias":     ovhtypes.TfStringType{},
			"archive":   ovhtypes.TfStringType{},
			"container": ovhtypes.TfStringType{},
			"internal":  ovhtypes.TfBoolType{},
			"prefix":    ovhtypes.TfStringType{},
		},
		map[string]attr.Value{
			"alias":     v.Alias,
			"archive":   v.Archive,
			"container": v.Container,
			"internal":  v.Internal,
			"prefix":    v.Prefix,
		})

	return objVal, diags
}

func (v VolumesDataStoreValue) Equal(o attr.Value) bool {
	other, ok := o.(VolumesDataStoreValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Alias.Equal(other.Alias) {
		return false
	}

	if !v.Archive.Equal(other.Archive) {
		return false
	}

	if !v.Container.Equal(other.Container) {
		return false
	}

	if !v.Internal.Equal(other.Internal) {
		return false
	}

	if !v.Prefix.Equal(other.Prefix) {
		return false
	}

	return true
}

func (v VolumesDataStoreValue) Type(ctx context.Context) attr.Type {
	return VolumesDataStoreType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v VolumesDataStoreValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"alias":     ovhtypes.TfStringType{},
		"archive":   ovhtypes.TfStringType{},
		"container": ovhtypes.TfStringType{},
		"internal":  ovhtypes.TfBoolType{},
		"prefix":    ovhtypes.TfStringType{},
	}
}

var _ basetypes.ObjectTypable = VolumesPrivateSwiftType{}

type VolumesPrivateSwiftType struct {
	basetypes.ObjectType
}

func (t VolumesPrivateSwiftType) Equal(o attr.Type) bool {
	other, ok := o.(VolumesPrivateSwiftType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t VolumesPrivateSwiftType) String() string {
	return "VolumesPrivateSwiftType"
}

func (t VolumesPrivateSwiftType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	archiveAttribute, ok := attributes["archive"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`archive is missing from object`)

		return nil, diags
	}

	archiveVal, ok := archiveAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`archive expected to be ovhtypes.TfStringValue, was: %T`, archiveAttribute))
	}

	containerAttribute, ok := attributes["container"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`container is missing from object`)

		return nil, diags
	}

	containerVal, ok := containerAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`container expected to be ovhtypes.TfStringValue, was: %T`, containerAttribute))
	}

	internalAttribute, ok := attributes["internal"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`internal is missing from object`)

		return nil, diags
	}

	internalVal, ok := internalAttribute.(ovhtypes.TfBoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`internal expected to be ovhtypes.TfBoolValue, was: %T`, internalAttribute))
	}

	prefixAttribute, ok := attributes["prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix is missing from object`)

		return nil, diags
	}

	prefixVal, ok := prefixAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix expected to be ovhtypes.TfStringValue, was: %T`, prefixAttribute))
	}

	regionAttribute, ok := attributes["region"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`region is missing from object`)

		return nil, diags
	}

	regionVal, ok := regionAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`region expected to be ovhtypes.TfStringValue, was: %T`, regionAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return VolumesPrivateSwiftValue{
		Archive:   archiveVal,
		Container: containerVal,
		Internal:  internalVal,
		Prefix:    prefixVal,
		Region:    regionVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewVolumesPrivateSwiftValueNull() VolumesPrivateSwiftValue {
	return VolumesPrivateSwiftValue{
		state: attr.ValueStateNull,
	}
}

func NewVolumesPrivateSwiftValueUnknown() VolumesPrivateSwiftValue {
	return VolumesPrivateSwiftValue{
		state: attr.ValueStateUnknown,
	}
}

func NewVolumesPrivateSwiftValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (VolumesPrivateSwiftValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing VolumesPrivateSwiftValue Attribute Value",
				"While creating a VolumesPrivateSwiftValue value, a missing attribute value was detected. "+
					"A VolumesPrivateSwiftValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VolumesPrivateSwiftValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid VolumesPrivateSwiftValue Attribute Type",
				"While creating a VolumesPrivateSwiftValue value, an invalid attribute value was detected. "+
					"A VolumesPrivateSwiftValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VolumesPrivateSwiftValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("VolumesPrivateSwiftValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra VolumesPrivateSwiftValue Attribute Value",
				"While creating a VolumesPrivateSwiftValue value, an extra attribute value was detected. "+
					"A VolumesPrivateSwiftValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra VolumesPrivateSwiftValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewVolumesPrivateSwiftValueUnknown(), diags
	}

	archiveAttribute, ok := attributes["archive"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`archive is missing from object`)

		return NewVolumesPrivateSwiftValueUnknown(), diags
	}

	archiveVal, ok := archiveAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`archive expected to be ovhtypes.TfStringValue, was: %T`, archiveAttribute))
	}

	containerAttribute, ok := attributes["container"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`container is missing from object`)

		return NewVolumesPrivateSwiftValueUnknown(), diags
	}

	containerVal, ok := containerAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`container expected to be ovhtypes.TfStringValue, was: %T`, containerAttribute))
	}

	internalAttribute, ok := attributes["internal"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`internal is missing from object`)

		return NewVolumesPrivateSwiftValueUnknown(), diags
	}

	internalVal, ok := internalAttribute.(ovhtypes.TfBoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`internal expected to be ovhtypes.TfBoolValue, was: %T`, internalAttribute))
	}

	prefixAttribute, ok := attributes["prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix is missing from object`)

		return NewVolumesPrivateSwiftValueUnknown(), diags
	}

	prefixVal, ok := prefixAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix expected to be ovhtypes.TfStringValue, was: %T`, prefixAttribute))
	}

	regionAttribute, ok := attributes["region"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`region is missing from object`)

		return NewVolumesPrivateSwiftValueUnknown(), diags
	}

	regionVal, ok := regionAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`region expected to be ovhtypes.TfStringValue, was: %T`, regionAttribute))
	}

	if diags.HasError() {
		return NewVolumesPrivateSwiftValueUnknown(), diags
	}

	return VolumesPrivateSwiftValue{
		Archive:   archiveVal,
		Container: containerVal,
		Internal:  internalVal,
		Prefix:    prefixVal,
		Region:    regionVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewVolumesPrivateSwiftValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) VolumesPrivateSwiftValue {
	object, diags := NewVolumesPrivateSwiftValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewVolumesPrivateSwiftValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t VolumesPrivateSwiftType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewVolumesPrivateSwiftValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewVolumesPrivateSwiftValueUnknown(), nil
	}

	if in.IsNull() {
		return NewVolumesPrivateSwiftValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewVolumesPrivateSwiftValueMust(VolumesPrivateSwiftValue{}.AttributeTypes(ctx), attributes), nil
}

func (t VolumesPrivateSwiftType) ValueType(ctx context.Context) attr.Value {
	return VolumesPrivateSwiftValue{}
}

var _ basetypes.ObjectValuable = VolumesPrivateSwiftValue{}

type VolumesPrivateSwiftValue struct {
	Archive   ovhtypes.TfStringValue `tfsdk:"archive" json:"archive"`
	Container ovhtypes.TfStringValue `tfsdk:"container" json:"container"`
	Internal  ovhtypes.TfBoolValue   `tfsdk:"internal" json:"internal"`
	Prefix    ovhtypes.TfStringValue `tfsdk:"prefix" json:"prefix"`
	Region    ovhtypes.TfStringValue `tfsdk:"region" json:"region"`
	state     attr.ValueState
}

func (v VolumesPrivateSwiftValue) ToCreate() *VolumesPrivateSwiftValue {
	res := &VolumesPrivateSwiftValue{}

	if !v.Region.IsNull() {
		res.Region = v.Region
	}

	if !v.Archive.IsNull() {
		res.Archive = v.Archive
	}

	if !v.Container.IsNull() {
		res.Container = v.Container
	}

	if !v.Prefix.IsNull() {
		res.Prefix = v.Prefix
	}

	res.state = attr.ValueStateKnown

	return res
}

func (v VolumesPrivateSwiftValue) MarshalJSON() ([]byte, error) {
	toMarshal := map[string]any{}
	if !v.Archive.IsNull() && !v.Archive.IsUnknown() {
		toMarshal["archive"] = v.Archive
	}
	if !v.Container.IsNull() && !v.Container.IsUnknown() {
		toMarshal["container"] = v.Container
	}
	if !v.Prefix.IsNull() && !v.Prefix.IsUnknown() {
		toMarshal["prefix"] = v.Prefix
	}
	if !v.Region.IsNull() && !v.Region.IsUnknown() {
		toMarshal["region"] = v.Region
	}

	return json.Marshal(toMarshal)
}

func (v *VolumesPrivateSwiftValue) UnmarshalJSON(data []byte) error {
	type JsonVolumesPrivateSwiftValue VolumesPrivateSwiftValue

	var tmp JsonVolumesPrivateSwiftValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.Archive = tmp.Archive
	v.Container = tmp.Container
	v.Internal = tmp.Internal
	v.Prefix = tmp.Prefix
	v.Region = tmp.Region

	v.state = attr.ValueStateKnown

	return nil
}

func (v *VolumesPrivateSwiftValue) MergeWith(other *VolumesPrivateSwiftValue) {

	if (v.Archive.IsUnknown() || v.Archive.IsNull()) && !other.Archive.IsUnknown() {
		v.Archive = other.Archive
	}

	if (v.Container.IsUnknown() || v.Container.IsNull()) && !other.Container.IsUnknown() {
		v.Container = other.Container
	}

	if (v.Internal.IsUnknown() || v.Internal.IsNull()) && !other.Internal.IsUnknown() {
		v.Internal = other.Internal
	}

	if (v.Prefix.IsUnknown() || v.Prefix.IsNull()) && !other.Prefix.IsUnknown() {
		v.Prefix = other.Prefix
	}

	if (v.Region.IsUnknown() || v.Region.IsNull()) && !other.Region.IsUnknown() {
		v.Region = other.Region
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v VolumesPrivateSwiftValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"archive":   v.Archive,
		"container": v.Container,
		"internal":  v.Internal,
		"prefix":    v.Prefix,
		"region":    v.Region,
	}
}
func (v VolumesPrivateSwiftValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["archive"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["container"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["internal"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["prefix"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["region"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.Archive.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["archive"] = val

		val, err = v.Container.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["container"] = val

		val, err = v.Internal.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["internal"] = val

		val, err = v.Prefix.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["prefix"] = val

		val, err = v.Region.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["region"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v VolumesPrivateSwiftValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v VolumesPrivateSwiftValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v VolumesPrivateSwiftValue) String() string {
	return "VolumesPrivateSwiftValue"
}

func (v VolumesPrivateSwiftValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"archive":   ovhtypes.TfStringType{},
			"container": ovhtypes.TfStringType{},
			"internal":  ovhtypes.TfBoolType{},
			"prefix":    ovhtypes.TfStringType{},
			"region":    ovhtypes.TfStringType{},
		},
		map[string]attr.Value{
			"archive":   v.Archive,
			"container": v.Container,
			"internal":  v.Internal,
			"prefix":    v.Prefix,
			"region":    v.Region,
		})

	return objVal, diags
}

func (v VolumesPrivateSwiftValue) Equal(o attr.Value) bool {
	other, ok := o.(VolumesPrivateSwiftValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Archive.Equal(other.Archive) {
		return false
	}

	if !v.Container.Equal(other.Container) {
		return false
	}

	if !v.Internal.Equal(other.Internal) {
		return false
	}

	if !v.Prefix.Equal(other.Prefix) {
		return false
	}

	if !v.Region.Equal(other.Region) {
		return false
	}

	return true
}

func (v VolumesPrivateSwiftValue) Type(ctx context.Context) attr.Type {
	return VolumesPrivateSwiftType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v VolumesPrivateSwiftValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"archive":   ovhtypes.TfStringType{},
		"container": ovhtypes.TfStringType{},
		"internal":  ovhtypes.TfBoolType{},
		"prefix":    ovhtypes.TfStringType{},
		"region":    ovhtypes.TfStringType{},
	}
}

var _ basetypes.ObjectTypable = VolumesPublicGitType{}

type VolumesPublicGitType struct {
	basetypes.ObjectType
}

func (t VolumesPublicGitType) Equal(o attr.Type) bool {
	other, ok := o.(VolumesPublicGitType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t VolumesPublicGitType) String() string {
	return "VolumesPublicGitType"
}

func (t VolumesPublicGitType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return nil, diags
	}

	urlVal, ok := urlAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be ovhtypes.TfStringValue, was: %T`, urlAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return VolumesPublicGitValue{
		Url:   urlVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewVolumesPublicGitValueNull() VolumesPublicGitValue {
	return VolumesPublicGitValue{
		state: attr.ValueStateNull,
	}
}

func NewVolumesPublicGitValueUnknown() VolumesPublicGitValue {
	return VolumesPublicGitValue{
		state: attr.ValueStateUnknown,
	}
}

func NewVolumesPublicGitValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (VolumesPublicGitValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing VolumesPublicGitValue Attribute Value",
				"While creating a VolumesPublicGitValue value, a missing attribute value was detected. "+
					"A VolumesPublicGitValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VolumesPublicGitValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid VolumesPublicGitValue Attribute Type",
				"While creating a VolumesPublicGitValue value, an invalid attribute value was detected. "+
					"A VolumesPublicGitValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VolumesPublicGitValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("VolumesPublicGitValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra VolumesPublicGitValue Attribute Value",
				"While creating a VolumesPublicGitValue value, an extra attribute value was detected. "+
					"A VolumesPublicGitValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra VolumesPublicGitValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewVolumesPublicGitValueUnknown(), diags
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return NewVolumesPublicGitValueUnknown(), diags
	}

	urlVal, ok := urlAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be ovhtypes.TfStringValue, was: %T`, urlAttribute))
	}

	if diags.HasError() {
		return NewVolumesPublicGitValueUnknown(), diags
	}

	return VolumesPublicGitValue{
		Url:   urlVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewVolumesPublicGitValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) VolumesPublicGitValue {
	object, diags := NewVolumesPublicGitValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewVolumesPublicGitValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t VolumesPublicGitType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewVolumesPublicGitValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewVolumesPublicGitValueUnknown(), nil
	}

	if in.IsNull() {
		return NewVolumesPublicGitValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewVolumesPublicGitValueMust(VolumesPublicGitValue{}.AttributeTypes(ctx), attributes), nil
}

func (t VolumesPublicGitType) ValueType(ctx context.Context) attr.Value {
	return VolumesPublicGitValue{}
}

var _ basetypes.ObjectValuable = VolumesPublicGitValue{}

type VolumesPublicGitValue struct {
	Url   ovhtypes.TfStringValue `tfsdk:"url" json:"url"`
	state attr.ValueState
}

func (v VolumesPublicGitValue) ToCreate() *VolumesPublicGitValue {
	res := &VolumesPublicGitValue{}

	if !v.Url.IsNull() {
		res.Url = v.Url
	}

	res.state = attr.ValueStateKnown

	return res
}

func (v VolumesPublicGitValue) MarshalJSON() ([]byte, error) {
	toMarshal := map[string]any{}
	if !v.Url.IsNull() && !v.Url.IsUnknown() {
		toMarshal["url"] = v.Url
	}

	return json.Marshal(toMarshal)
}

func (v *VolumesPublicGitValue) UnmarshalJSON(data []byte) error {
	type JsonVolumesPublicGitValue VolumesPublicGitValue

	var tmp JsonVolumesPublicGitValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.Url = tmp.Url

	v.state = attr.ValueStateKnown

	return nil
}

func (v *VolumesPublicGitValue) MergeWith(other *VolumesPublicGitValue) {

	if (v.Url.IsUnknown() || v.Url.IsNull()) && !other.Url.IsUnknown() {
		v.Url = other.Url
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v VolumesPublicGitValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"url": v.Url,
	}
}
func (v VolumesPublicGitValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["url"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Url.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["url"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v VolumesPublicGitValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v VolumesPublicGitValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v VolumesPublicGitValue) String() string {
	return "VolumesPublicGitValue"
}

func (v VolumesPublicGitValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"url": ovhtypes.TfStringType{},
		},
		map[string]attr.Value{
			"url": v.Url,
		})

	return objVal, diags
}

func (v VolumesPublicGitValue) Equal(o attr.Value) bool {
	other, ok := o.(VolumesPublicGitValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Url.Equal(other.Url) {
		return false
	}

	return true
}

func (v VolumesPublicGitValue) Type(ctx context.Context) attr.Type {
	return VolumesPublicGitType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v VolumesPublicGitValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"url": ovhtypes.TfStringType{},
	}
}

var _ basetypes.ObjectTypable = VolumesPublicSwiftType{}

type VolumesPublicSwiftType struct {
	basetypes.ObjectType
}

func (t VolumesPublicSwiftType) Equal(o attr.Type) bool {
	other, ok := o.(VolumesPublicSwiftType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t VolumesPublicSwiftType) String() string {
	return "VolumesPublicSwiftType"
}

func (t VolumesPublicSwiftType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return nil, diags
	}

	urlVal, ok := urlAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be ovhtypes.TfStringValue, was: %T`, urlAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return VolumesPublicSwiftValue{
		Url:   urlVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewVolumesPublicSwiftValueNull() VolumesPublicSwiftValue {
	return VolumesPublicSwiftValue{
		state: attr.ValueStateNull,
	}
}

func NewVolumesPublicSwiftValueUnknown() VolumesPublicSwiftValue {
	return VolumesPublicSwiftValue{
		state: attr.ValueStateUnknown,
	}
}

func NewVolumesPublicSwiftValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (VolumesPublicSwiftValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing VolumesPublicSwiftValue Attribute Value",
				"While creating a VolumesPublicSwiftValue value, a missing attribute value was detected. "+
					"A VolumesPublicSwiftValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VolumesPublicSwiftValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid VolumesPublicSwiftValue Attribute Type",
				"While creating a VolumesPublicSwiftValue value, an invalid attribute value was detected. "+
					"A VolumesPublicSwiftValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VolumesPublicSwiftValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("VolumesPublicSwiftValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra VolumesPublicSwiftValue Attribute Value",
				"While creating a VolumesPublicSwiftValue value, an extra attribute value was detected. "+
					"A VolumesPublicSwiftValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra VolumesPublicSwiftValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewVolumesPublicSwiftValueUnknown(), diags
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return NewVolumesPublicSwiftValueUnknown(), diags
	}

	urlVal, ok := urlAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be ovhtypes.TfStringValue, was: %T`, urlAttribute))
	}

	if diags.HasError() {
		return NewVolumesPublicSwiftValueUnknown(), diags
	}

	return VolumesPublicSwiftValue{
		Url:   urlVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewVolumesPublicSwiftValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) VolumesPublicSwiftValue {
	object, diags := NewVolumesPublicSwiftValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewVolumesPublicSwiftValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t VolumesPublicSwiftType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewVolumesPublicSwiftValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewVolumesPublicSwiftValueUnknown(), nil
	}

	if in.IsNull() {
		return NewVolumesPublicSwiftValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewVolumesPublicSwiftValueMust(VolumesPublicSwiftValue{}.AttributeTypes(ctx), attributes), nil
}

func (t VolumesPublicSwiftType) ValueType(ctx context.Context) attr.Value {
	return VolumesPublicSwiftValue{}
}

var _ basetypes.ObjectValuable = VolumesPublicSwiftValue{}

type VolumesPublicSwiftValue struct {
	Url   ovhtypes.TfStringValue `tfsdk:"url" json:"url"`
	state attr.ValueState
}

func (v VolumesPublicSwiftValue) ToCreate() *VolumesPublicSwiftValue {
	res := &VolumesPublicSwiftValue{}

	if !v.Url.IsNull() {
		res.Url = v.Url
	}

	res.state = attr.ValueStateKnown

	return res
}

func (v VolumesPublicSwiftValue) MarshalJSON() ([]byte, error) {
	toMarshal := map[string]any{}
	if !v.Url.IsNull() && !v.Url.IsUnknown() {
		toMarshal["url"] = v.Url
	}

	return json.Marshal(toMarshal)
}

func (v *VolumesPublicSwiftValue) UnmarshalJSON(data []byte) error {
	type JsonVolumesPublicSwiftValue VolumesPublicSwiftValue

	var tmp JsonVolumesPublicSwiftValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.Url = tmp.Url

	v.state = attr.ValueStateKnown

	return nil
}

func (v *VolumesPublicSwiftValue) MergeWith(other *VolumesPublicSwiftValue) {

	if (v.Url.IsUnknown() || v.Url.IsNull()) && !other.Url.IsUnknown() {
		v.Url = other.Url
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v VolumesPublicSwiftValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"url": v.Url,
	}
}
func (v VolumesPublicSwiftValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["url"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Url.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["url"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v VolumesPublicSwiftValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v VolumesPublicSwiftValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v VolumesPublicSwiftValue) String() string {
	return "VolumesPublicSwiftValue"
}

func (v VolumesPublicSwiftValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"url": ovhtypes.TfStringType{},
		},
		map[string]attr.Value{
			"url": v.Url,
		})

	return objVal, diags
}

func (v VolumesPublicSwiftValue) Equal(o attr.Value) bool {
	other, ok := o.(VolumesPublicSwiftValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Url.Equal(other.Url) {
		return false
	}

	return true
}

func (v VolumesPublicSwiftValue) Type(ctx context.Context) attr.Type {
	return VolumesPublicSwiftType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v VolumesPublicSwiftValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"url": ovhtypes.TfStringType{},
	}
}

var _ basetypes.ObjectTypable = VolumesStandaloneType{}

type VolumesStandaloneType struct {
	basetypes.ObjectType
}

func (t VolumesStandaloneType) Equal(o attr.Type) bool {
	other, ok := o.(VolumesStandaloneType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t VolumesStandaloneType) String() string {
	return "VolumesStandaloneType"
}

func (t VolumesStandaloneType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be ovhtypes.TfStringValue, was: %T`, nameAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return VolumesStandaloneValue{
		Name:  nameVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewVolumesStandaloneValueNull() VolumesStandaloneValue {
	return VolumesStandaloneValue{
		state: attr.ValueStateNull,
	}
}

func NewVolumesStandaloneValueUnknown() VolumesStandaloneValue {
	return VolumesStandaloneValue{
		state: attr.ValueStateUnknown,
	}
}

func NewVolumesStandaloneValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (VolumesStandaloneValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing VolumesStandaloneValue Attribute Value",
				"While creating a VolumesStandaloneValue value, a missing attribute value was detected. "+
					"A VolumesStandaloneValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VolumesStandaloneValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid VolumesStandaloneValue Attribute Type",
				"While creating a VolumesStandaloneValue value, an invalid attribute value was detected. "+
					"A VolumesStandaloneValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VolumesStandaloneValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("VolumesStandaloneValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra VolumesStandaloneValue Attribute Value",
				"While creating a VolumesStandaloneValue value, an extra attribute value was detected. "+
					"A VolumesStandaloneValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra VolumesStandaloneValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewVolumesStandaloneValueUnknown(), diags
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewVolumesStandaloneValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be ovhtypes.TfStringValue, was: %T`, nameAttribute))
	}

	if diags.HasError() {
		return NewVolumesStandaloneValueUnknown(), diags
	}

	return VolumesStandaloneValue{
		Name:  nameVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewVolumesStandaloneValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) VolumesStandaloneValue {
	object, diags := NewVolumesStandaloneValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewVolumesStandaloneValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t VolumesStandaloneType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewVolumesStandaloneValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewVolumesStandaloneValueUnknown(), nil
	}

	if in.IsNull() {
		return NewVolumesStandaloneValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewVolumesStandaloneValueMust(VolumesStandaloneValue{}.AttributeTypes(ctx), attributes), nil
}

func (t VolumesStandaloneType) ValueType(ctx context.Context) attr.Value {
	return VolumesStandaloneValue{}
}

var _ basetypes.ObjectValuable = VolumesStandaloneValue{}

type VolumesStandaloneValue struct {
	Name  ovhtypes.TfStringValue `tfsdk:"name" json:"name"`
	state attr.ValueState
}

func (v VolumesStandaloneValue) ToCreate() *VolumesStandaloneValue {
	res := &VolumesStandaloneValue{}

	if !v.Name.IsNull() {
		res.Name = v.Name
	}

	res.state = attr.ValueStateKnown

	return res
}

func (v VolumesStandaloneValue) MarshalJSON() ([]byte, error) {
	toMarshal := map[string]any{}
	if !v.Name.IsNull() && !v.Name.IsUnknown() {
		toMarshal["name"] = v.Name
	}

	return json.Marshal(toMarshal)
}

func (v *VolumesStandaloneValue) UnmarshalJSON(data []byte) error {
	type JsonVolumesStandaloneValue VolumesStandaloneValue

	var tmp JsonVolumesStandaloneValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.Name = tmp.Name

	v.state = attr.ValueStateKnown

	return nil
}

func (v *VolumesStandaloneValue) MergeWith(other *VolumesStandaloneValue) {

	if (v.Name.IsUnknown() || v.Name.IsNull()) && !other.Name.IsUnknown() {
		v.Name = other.Name
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v VolumesStandaloneValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"name": v.Name,
	}
}
func (v VolumesStandaloneValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v VolumesStandaloneValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v VolumesStandaloneValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v VolumesStandaloneValue) String() string {
	return "VolumesStandaloneValue"
}

func (v VolumesStandaloneValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"name": ovhtypes.TfStringType{},
		},
		map[string]attr.Value{
			"name": v.Name,
		})

	return objVal, diags
}

func (v VolumesStandaloneValue) Equal(o attr.Value) bool {
	other, ok := o.(VolumesStandaloneValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	return true
}

func (v VolumesStandaloneValue) Type(ctx context.Context) attr.Type {
	return VolumesStandaloneType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v VolumesStandaloneValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"name": ovhtypes.TfStringType{},
	}
}

var _ basetypes.ObjectTypable = VolumesTargetDataStoreType{}

type VolumesTargetDataStoreType struct {
	basetypes.ObjectType
}

func (t VolumesTargetDataStoreType) Equal(o attr.Type) bool {
	other, ok := o.(VolumesTargetDataStoreType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t VolumesTargetDataStoreType) String() string {
	return "VolumesTargetDataStoreType"
}

func (t VolumesTargetDataStoreType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	aliasAttribute, ok := attributes["alias"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`alias is missing from object`)

		return nil, diags
	}

	aliasVal, ok := aliasAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`alias expected to be ovhtypes.TfStringValue, was: %T`, aliasAttribute))
	}

	archiveAttribute, ok := attributes["archive"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`archive is missing from object`)

		return nil, diags
	}

	archiveVal, ok := archiveAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`archive expected to be ovhtypes.TfStringValue, was: %T`, archiveAttribute))
	}

	containerAttribute, ok := attributes["container"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`container is missing from object`)

		return nil, diags
	}

	containerVal, ok := containerAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`container expected to be ovhtypes.TfStringValue, was: %T`, containerAttribute))
	}

	internalAttribute, ok := attributes["internal"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`internal is missing from object`)

		return nil, diags
	}

	internalVal, ok := internalAttribute.(ovhtypes.TfBoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`internal expected to be ovhtypes.TfBoolValue, was: %T`, internalAttribute))
	}

	prefixAttribute, ok := attributes["prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix is missing from object`)

		return nil, diags
	}

	prefixVal, ok := prefixAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix expected to be ovhtypes.TfStringValue, was: %T`, prefixAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return VolumesTargetDataStoreValue{
		Alias:     aliasVal,
		Archive:   archiveVal,
		Container: containerVal,
		Internal:  internalVal,
		Prefix:    prefixVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewVolumesTargetDataStoreValueNull() VolumesTargetDataStoreValue {
	return VolumesTargetDataStoreValue{
		state: attr.ValueStateNull,
	}
}

func NewVolumesTargetDataStoreValueUnknown() VolumesTargetDataStoreValue {
	return VolumesTargetDataStoreValue{
		state: attr.ValueStateUnknown,
	}
}

func NewVolumesTargetDataStoreValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (VolumesTargetDataStoreValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing VolumesTargetDataStoreValue Attribute Value",
				"While creating a VolumesTargetDataStoreValue value, a missing attribute value was detected. "+
					"A VolumesTargetDataStoreValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VolumesTargetDataStoreValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid VolumesTargetDataStoreValue Attribute Type",
				"While creating a VolumesTargetDataStoreValue value, an invalid attribute value was detected. "+
					"A VolumesTargetDataStoreValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VolumesTargetDataStoreValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("VolumesTargetDataStoreValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra VolumesTargetDataStoreValue Attribute Value",
				"While creating a VolumesTargetDataStoreValue value, an extra attribute value was detected. "+
					"A VolumesTargetDataStoreValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra VolumesTargetDataStoreValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewVolumesTargetDataStoreValueUnknown(), diags
	}

	aliasAttribute, ok := attributes["alias"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`alias is missing from object`)

		return NewVolumesTargetDataStoreValueUnknown(), diags
	}

	aliasVal, ok := aliasAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`alias expected to be ovhtypes.TfStringValue, was: %T`, aliasAttribute))
	}

	archiveAttribute, ok := attributes["archive"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`archive is missing from object`)

		return NewVolumesTargetDataStoreValueUnknown(), diags
	}

	archiveVal, ok := archiveAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`archive expected to be ovhtypes.TfStringValue, was: %T`, archiveAttribute))
	}

	containerAttribute, ok := attributes["container"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`container is missing from object`)

		return NewVolumesTargetDataStoreValueUnknown(), diags
	}

	containerVal, ok := containerAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`container expected to be ovhtypes.TfStringValue, was: %T`, containerAttribute))
	}

	internalAttribute, ok := attributes["internal"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`internal is missing from object`)

		return NewVolumesTargetDataStoreValueUnknown(), diags
	}

	internalVal, ok := internalAttribute.(ovhtypes.TfBoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`internal expected to be ovhtypes.TfBoolValue, was: %T`, internalAttribute))
	}

	prefixAttribute, ok := attributes["prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix is missing from object`)

		return NewVolumesTargetDataStoreValueUnknown(), diags
	}

	prefixVal, ok := prefixAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix expected to be ovhtypes.TfStringValue, was: %T`, prefixAttribute))
	}

	if diags.HasError() {
		return NewVolumesTargetDataStoreValueUnknown(), diags
	}

	return VolumesTargetDataStoreValue{
		Alias:     aliasVal,
		Archive:   archiveVal,
		Container: containerVal,
		Internal:  internalVal,
		Prefix:    prefixVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewVolumesTargetDataStoreValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) VolumesTargetDataStoreValue {
	object, diags := NewVolumesTargetDataStoreValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewVolumesTargetDataStoreValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t VolumesTargetDataStoreType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewVolumesTargetDataStoreValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewVolumesTargetDataStoreValueUnknown(), nil
	}

	if in.IsNull() {
		return NewVolumesTargetDataStoreValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewVolumesTargetDataStoreValueMust(VolumesTargetDataStoreValue{}.AttributeTypes(ctx), attributes), nil
}

func (t VolumesTargetDataStoreType) ValueType(ctx context.Context) attr.Value {
	return VolumesTargetDataStoreValue{}
}

var _ basetypes.ObjectValuable = VolumesTargetDataStoreValue{}

type VolumesTargetDataStoreValue struct {
	Alias     ovhtypes.TfStringValue `tfsdk:"alias" json:"alias"`
	Archive   ovhtypes.TfStringValue `tfsdk:"archive" json:"archive"`
	Container ovhtypes.TfStringValue `tfsdk:"container" json:"container"`
	Internal  ovhtypes.TfBoolValue   `tfsdk:"internal" json:"internal"`
	Prefix    ovhtypes.TfStringValue `tfsdk:"prefix" json:"prefix"`
	state     attr.ValueState
}

func (v VolumesTargetDataStoreValue) ToCreate() *VolumesTargetDataStoreValue {
	res := &VolumesTargetDataStoreValue{}

	if !v.Alias.IsNull() {
		res.Alias = v.Alias
	}

	if !v.Archive.IsNull() {
		res.Archive = v.Archive
	}

	if !v.Container.IsNull() {
		res.Container = v.Container
	}

	if !v.Internal.IsNull() {
		res.Internal = v.Internal
	}

	if !v.Prefix.IsNull() {
		res.Prefix = v.Prefix
	}

	res.state = attr.ValueStateKnown

	return res
}

func (v VolumesTargetDataStoreValue) MarshalJSON() ([]byte, error) {
	toMarshal := map[string]any{}
	if !v.Alias.IsNull() && !v.Alias.IsUnknown() {
		toMarshal["alias"] = v.Alias
	}
	if !v.Archive.IsNull() && !v.Archive.IsUnknown() {
		toMarshal["archive"] = v.Archive
	}
	if !v.Container.IsNull() && !v.Container.IsUnknown() {
		toMarshal["container"] = v.Container
	}
	if !v.Internal.IsNull() && !v.Internal.IsUnknown() {
		toMarshal["internal"] = v.Internal
	}
	if !v.Prefix.IsNull() && !v.Prefix.IsUnknown() {
		toMarshal["prefix"] = v.Prefix
	}

	return json.Marshal(toMarshal)
}

func (v *VolumesTargetDataStoreValue) UnmarshalJSON(data []byte) error {
	type JsonVolumesTargetDataStoreValue VolumesTargetDataStoreValue

	var tmp JsonVolumesTargetDataStoreValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.Alias = tmp.Alias
	v.Archive = tmp.Archive
	v.Container = tmp.Container
	v.Internal = tmp.Internal
	v.Prefix = tmp.Prefix

	v.state = attr.ValueStateKnown

	return nil
}

func (v *VolumesTargetDataStoreValue) MergeWith(other *VolumesTargetDataStoreValue) {

	if (v.Alias.IsUnknown() || v.Alias.IsNull()) && !other.Alias.IsUnknown() {
		v.Alias = other.Alias
	}

	if (v.Archive.IsUnknown() || v.Archive.IsNull()) && !other.Archive.IsUnknown() {
		v.Archive = other.Archive
	}

	if (v.Container.IsUnknown() || v.Container.IsNull()) && !other.Container.IsUnknown() {
		v.Container = other.Container
	}

	if (v.Internal.IsUnknown() || v.Internal.IsNull()) && !other.Internal.IsUnknown() {
		v.Internal = other.Internal
	}

	if (v.Prefix.IsUnknown() || v.Prefix.IsNull()) && !other.Prefix.IsUnknown() {
		v.Prefix = other.Prefix
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v VolumesTargetDataStoreValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"alias":     v.Alias,
		"archive":   v.Archive,
		"container": v.Container,
		"internal":  v.Internal,
		"prefix":    v.Prefix,
	}
}
func (v VolumesTargetDataStoreValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["alias"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["archive"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["container"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["internal"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["prefix"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.Alias.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["alias"] = val

		val, err = v.Archive.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["archive"] = val

		val, err = v.Container.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["container"] = val

		val, err = v.Internal.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["internal"] = val

		val, err = v.Prefix.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["prefix"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v VolumesTargetDataStoreValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v VolumesTargetDataStoreValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v VolumesTargetDataStoreValue) String() string {
	return "VolumesTargetDataStoreValue"
}

func (v VolumesTargetDataStoreValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"alias":     ovhtypes.TfStringType{},
			"archive":   ovhtypes.TfStringType{},
			"container": ovhtypes.TfStringType{},
			"internal":  ovhtypes.TfBoolType{},
			"prefix":    ovhtypes.TfStringType{},
		},
		map[string]attr.Value{
			"alias":     v.Alias,
			"archive":   v.Archive,
			"container": v.Container,
			"internal":  v.Internal,
			"prefix":    v.Prefix,
		})

	return objVal, diags
}

func (v VolumesTargetDataStoreValue) Equal(o attr.Value) bool {
	other, ok := o.(VolumesTargetDataStoreValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Alias.Equal(other.Alias) {
		return false
	}

	if !v.Archive.Equal(other.Archive) {
		return false
	}

	if !v.Container.Equal(other.Container) {
		return false
	}

	if !v.Internal.Equal(other.Internal) {
		return false
	}

	if !v.Prefix.Equal(other.Prefix) {
		return false
	}

	return true
}

func (v VolumesTargetDataStoreValue) Type(ctx context.Context) attr.Type {
	return VolumesTargetDataStoreType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v VolumesTargetDataStoreValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"alias":     ovhtypes.TfStringType{},
		"archive":   ovhtypes.TfStringType{},
		"container": ovhtypes.TfStringType{},
		"internal":  ovhtypes.TfBoolType{},
		"prefix":    ovhtypes.TfStringType{},
	}
}

var _ basetypes.ObjectTypable = VolumesTargetPrivateSwiftType{}

type VolumesTargetPrivateSwiftType struct {
	basetypes.ObjectType
}

func (t VolumesTargetPrivateSwiftType) Equal(o attr.Type) bool {
	other, ok := o.(VolumesTargetPrivateSwiftType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t VolumesTargetPrivateSwiftType) String() string {
	return "VolumesTargetPrivateSwiftType"
}

func (t VolumesTargetPrivateSwiftType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	archiveAttribute, ok := attributes["archive"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`archive is missing from object`)

		return nil, diags
	}

	archiveVal, ok := archiveAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`archive expected to be ovhtypes.TfStringValue, was: %T`, archiveAttribute))
	}

	containerAttribute, ok := attributes["container"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`container is missing from object`)

		return nil, diags
	}

	containerVal, ok := containerAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`container expected to be ovhtypes.TfStringValue, was: %T`, containerAttribute))
	}

	internalAttribute, ok := attributes["internal"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`internal is missing from object`)

		return nil, diags
	}

	internalVal, ok := internalAttribute.(ovhtypes.TfBoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`internal expected to be ovhtypes.TfBoolValue, was: %T`, internalAttribute))
	}

	prefixAttribute, ok := attributes["prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix is missing from object`)

		return nil, diags
	}

	prefixVal, ok := prefixAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix expected to be ovhtypes.TfStringValue, was: %T`, prefixAttribute))
	}

	regionAttribute, ok := attributes["region"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`region is missing from object`)

		return nil, diags
	}

	regionVal, ok := regionAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`region expected to be ovhtypes.TfStringValue, was: %T`, regionAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return VolumesTargetPrivateSwiftValue{
		Archive:   archiveVal,
		Container: containerVal,
		Internal:  internalVal,
		Prefix:    prefixVal,
		Region:    regionVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewVolumesTargetPrivateSwiftValueNull() VolumesTargetPrivateSwiftValue {
	return VolumesTargetPrivateSwiftValue{
		state: attr.ValueStateNull,
	}
}

func NewVolumesTargetPrivateSwiftValueUnknown() VolumesTargetPrivateSwiftValue {
	return VolumesTargetPrivateSwiftValue{
		state: attr.ValueStateUnknown,
	}
}

func NewVolumesTargetPrivateSwiftValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (VolumesTargetPrivateSwiftValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing VolumesTargetPrivateSwiftValue Attribute Value",
				"While creating a VolumesTargetPrivateSwiftValue value, a missing attribute value was detected. "+
					"A VolumesTargetPrivateSwiftValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VolumesTargetPrivateSwiftValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid VolumesTargetPrivateSwiftValue Attribute Type",
				"While creating a VolumesTargetPrivateSwiftValue value, an invalid attribute value was detected. "+
					"A VolumesTargetPrivateSwiftValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VolumesTargetPrivateSwiftValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("VolumesTargetPrivateSwiftValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra VolumesTargetPrivateSwiftValue Attribute Value",
				"While creating a VolumesTargetPrivateSwiftValue value, an extra attribute value was detected. "+
					"A VolumesTargetPrivateSwiftValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra VolumesTargetPrivateSwiftValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewVolumesTargetPrivateSwiftValueUnknown(), diags
	}

	archiveAttribute, ok := attributes["archive"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`archive is missing from object`)

		return NewVolumesTargetPrivateSwiftValueUnknown(), diags
	}

	archiveVal, ok := archiveAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`archive expected to be ovhtypes.TfStringValue, was: %T`, archiveAttribute))
	}

	containerAttribute, ok := attributes["container"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`container is missing from object`)

		return NewVolumesTargetPrivateSwiftValueUnknown(), diags
	}

	containerVal, ok := containerAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`container expected to be ovhtypes.TfStringValue, was: %T`, containerAttribute))
	}

	internalAttribute, ok := attributes["internal"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`internal is missing from object`)

		return NewVolumesTargetPrivateSwiftValueUnknown(), diags
	}

	internalVal, ok := internalAttribute.(ovhtypes.TfBoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`internal expected to be ovhtypes.TfBoolValue, was: %T`, internalAttribute))
	}

	prefixAttribute, ok := attributes["prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix is missing from object`)

		return NewVolumesTargetPrivateSwiftValueUnknown(), diags
	}

	prefixVal, ok := prefixAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix expected to be ovhtypes.TfStringValue, was: %T`, prefixAttribute))
	}

	regionAttribute, ok := attributes["region"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`region is missing from object`)

		return NewVolumesTargetPrivateSwiftValueUnknown(), diags
	}

	regionVal, ok := regionAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`region expected to be ovhtypes.TfStringValue, was: %T`, regionAttribute))
	}

	if diags.HasError() {
		return NewVolumesTargetPrivateSwiftValueUnknown(), diags
	}

	return VolumesTargetPrivateSwiftValue{
		Archive:   archiveVal,
		Container: containerVal,
		Internal:  internalVal,
		Prefix:    prefixVal,
		Region:    regionVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewVolumesTargetPrivateSwiftValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) VolumesTargetPrivateSwiftValue {
	object, diags := NewVolumesTargetPrivateSwiftValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewVolumesTargetPrivateSwiftValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t VolumesTargetPrivateSwiftType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewVolumesTargetPrivateSwiftValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewVolumesTargetPrivateSwiftValueUnknown(), nil
	}

	if in.IsNull() {
		return NewVolumesTargetPrivateSwiftValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewVolumesTargetPrivateSwiftValueMust(VolumesTargetPrivateSwiftValue{}.AttributeTypes(ctx), attributes), nil
}

func (t VolumesTargetPrivateSwiftType) ValueType(ctx context.Context) attr.Value {
	return VolumesTargetPrivateSwiftValue{}
}

var _ basetypes.ObjectValuable = VolumesTargetPrivateSwiftValue{}

type VolumesTargetPrivateSwiftValue struct {
	Archive   ovhtypes.TfStringValue `tfsdk:"archive" json:"archive"`
	Container ovhtypes.TfStringValue `tfsdk:"container" json:"container"`
	Internal  ovhtypes.TfBoolValue   `tfsdk:"internal" json:"internal"`
	Prefix    ovhtypes.TfStringValue `tfsdk:"prefix" json:"prefix"`
	Region    ovhtypes.TfStringValue `tfsdk:"region" json:"region"`
	state     attr.ValueState
}

func (v VolumesTargetPrivateSwiftValue) ToCreate() *VolumesTargetPrivateSwiftValue {
	res := &VolumesTargetPrivateSwiftValue{}

	if !v.Archive.IsNull() {
		res.Archive = v.Archive
	}

	if !v.Container.IsNull() {
		res.Container = v.Container
	}

	if !v.Prefix.IsNull() {
		res.Prefix = v.Prefix
	}

	if !v.Region.IsNull() {
		res.Region = v.Region
	}

	res.state = attr.ValueStateKnown

	return res
}

func (v VolumesTargetPrivateSwiftValue) MarshalJSON() ([]byte, error) {
	toMarshal := map[string]any{}
	if !v.Archive.IsNull() && !v.Archive.IsUnknown() {
		toMarshal["archive"] = v.Archive
	}
	if !v.Container.IsNull() && !v.Container.IsUnknown() {
		toMarshal["container"] = v.Container
	}
	if !v.Prefix.IsNull() && !v.Prefix.IsUnknown() {
		toMarshal["prefix"] = v.Prefix
	}
	if !v.Region.IsNull() && !v.Region.IsUnknown() {
		toMarshal["region"] = v.Region
	}

	return json.Marshal(toMarshal)
}

func (v *VolumesTargetPrivateSwiftValue) UnmarshalJSON(data []byte) error {
	type JsonVolumesTargetPrivateSwiftValue VolumesTargetPrivateSwiftValue

	var tmp JsonVolumesTargetPrivateSwiftValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.Archive = tmp.Archive
	v.Container = tmp.Container
	v.Internal = tmp.Internal
	v.Prefix = tmp.Prefix
	v.Region = tmp.Region

	v.state = attr.ValueStateKnown

	return nil
}

func (v *VolumesTargetPrivateSwiftValue) MergeWith(other *VolumesTargetPrivateSwiftValue) {

	if (v.Archive.IsUnknown() || v.Archive.IsNull()) && !other.Archive.IsUnknown() {
		v.Archive = other.Archive
	}

	if (v.Container.IsUnknown() || v.Container.IsNull()) && !other.Container.IsUnknown() {
		v.Container = other.Container
	}

	if (v.Internal.IsUnknown() || v.Internal.IsNull()) && !other.Internal.IsUnknown() {
		v.Internal = other.Internal
	}

	if (v.Prefix.IsUnknown() || v.Prefix.IsNull()) && !other.Prefix.IsUnknown() {
		v.Prefix = other.Prefix
	}

	if (v.Region.IsUnknown() || v.Region.IsNull()) && !other.Region.IsUnknown() {
		v.Region = other.Region
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v VolumesTargetPrivateSwiftValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"archive":   v.Archive,
		"container": v.Container,
		"internal":  v.Internal,
		"prefix":    v.Prefix,
		"region":    v.Region,
	}
}
func (v VolumesTargetPrivateSwiftValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["archive"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["container"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["internal"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["prefix"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["region"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.Archive.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["archive"] = val

		val, err = v.Container.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["container"] = val

		val, err = v.Internal.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["internal"] = val

		val, err = v.Prefix.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["prefix"] = val

		val, err = v.Region.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["region"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v VolumesTargetPrivateSwiftValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v VolumesTargetPrivateSwiftValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v VolumesTargetPrivateSwiftValue) String() string {
	return "VolumesTargetPrivateSwiftValue"
}

func (v VolumesTargetPrivateSwiftValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"archive":   ovhtypes.TfStringType{},
			"container": ovhtypes.TfStringType{},
			"internal":  ovhtypes.TfBoolType{},
			"prefix":    ovhtypes.TfStringType{},
			"region":    ovhtypes.TfStringType{},
		},
		map[string]attr.Value{
			"archive":   v.Archive,
			"container": v.Container,
			"internal":  v.Internal,
			"prefix":    v.Prefix,
			"region":    v.Region,
		})

	return objVal, diags
}

func (v VolumesTargetPrivateSwiftValue) Equal(o attr.Value) bool {
	other, ok := o.(VolumesTargetPrivateSwiftValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Archive.Equal(other.Archive) {
		return false
	}

	if !v.Container.Equal(other.Container) {
		return false
	}

	if !v.Internal.Equal(other.Internal) {
		return false
	}

	if !v.Prefix.Equal(other.Prefix) {
		return false
	}

	if !v.Region.Equal(other.Region) {
		return false
	}

	return true
}

func (v VolumesTargetPrivateSwiftValue) Type(ctx context.Context) attr.Type {
	return VolumesTargetPrivateSwiftType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v VolumesTargetPrivateSwiftValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"archive":   ovhtypes.TfStringType{},
		"container": ovhtypes.TfStringType{},
		"internal":  ovhtypes.TfBoolType{},
		"prefix":    ovhtypes.TfStringType{},
		"region":    ovhtypes.TfStringType{},
	}
}

var _ basetypes.ObjectTypable = VolumesVolumeSourceType{}

type VolumesVolumeSourceType struct {
	basetypes.ObjectType
}

func (t VolumesVolumeSourceType) Equal(o attr.Type) bool {
	other, ok := o.(VolumesVolumeSourceType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t VolumesVolumeSourceType) String() string {
	return "VolumesVolumeSourceType"
}

func (t VolumesVolumeSourceType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	dataStoreAttribute, ok := attributes["data_store"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`data_store is missing from object`)

		return nil, diags
	}

	dataStoreVal, ok := dataStoreAttribute.(VolumesVolumeSourceDataStoreValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`data_store expected to be VolumesVolumeSourceDataStoreValue, was: %T`, dataStoreAttribute))
	}

	publicGitAttribute, ok := attributes["public_git"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`public_git is missing from object`)

		return nil, diags
	}

	publicGitVal, ok := publicGitAttribute.(VolumesVolumeSourcePublicGitValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`public_git expected to be VolumesVolumeSourcePublicGitValue, was: %T`, publicGitAttribute))
	}

	publicSwiftAttribute, ok := attributes["public_swift"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`public_swift is missing from object`)

		return nil, diags
	}

	publicSwiftVal, ok := publicSwiftAttribute.(VolumesVolumeSourcePublicSwiftValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`public_swift expected to be VolumesVolumeSourcePublicSwiftValue, was: %T`, publicSwiftAttribute))
	}

	standaloneAttribute, ok := attributes["standalone"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`standalone is missing from object`)

		return nil, diags
	}

	standaloneVal, ok := standaloneAttribute.(VolumesVolumeSourceStandaloneValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`standalone expected to be VolumesVolumeSourceStandaloneValue, was: %T`, standaloneAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return VolumesVolumeSourceValue{
		DataStore:   dataStoreVal,
		PublicGit:   publicGitVal,
		PublicSwift: publicSwiftVal,
		Standalone:  standaloneVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewVolumesVolumeSourceValueNull() VolumesVolumeSourceValue {
	return VolumesVolumeSourceValue{
		state: attr.ValueStateNull,
	}
}

func NewVolumesVolumeSourceValueUnknown() VolumesVolumeSourceValue {
	return VolumesVolumeSourceValue{
		state: attr.ValueStateUnknown,
	}
}

func NewVolumesVolumeSourceValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (VolumesVolumeSourceValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing VolumesVolumeSourceValue Attribute Value",
				"While creating a VolumesVolumeSourceValue value, a missing attribute value was detected. "+
					"A VolumesVolumeSourceValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VolumesVolumeSourceValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid VolumesVolumeSourceValue Attribute Type",
				"While creating a VolumesVolumeSourceValue value, an invalid attribute value was detected. "+
					"A VolumesVolumeSourceValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VolumesVolumeSourceValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("VolumesVolumeSourceValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra VolumesVolumeSourceValue Attribute Value",
				"While creating a VolumesVolumeSourceValue value, an extra attribute value was detected. "+
					"A VolumesVolumeSourceValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra VolumesVolumeSourceValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewVolumesVolumeSourceValueUnknown(), diags
	}

	dataStoreAttribute, ok := attributes["data_store"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`data_store is missing from object`)

		return NewVolumesVolumeSourceValueUnknown(), diags
	}

	dataStoreVal, ok := dataStoreAttribute.(VolumesVolumeSourceDataStoreValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`data_store expected to be VolumesVolumeSourceDataStoreValue, was: %T`, dataStoreAttribute))
	}

	publicGitAttribute, ok := attributes["public_git"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`public_git is missing from object`)

		return NewVolumesVolumeSourceValueUnknown(), diags
	}

	publicGitVal, ok := publicGitAttribute.(VolumesVolumeSourcePublicGitValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`public_git expected to be VolumesVolumeSourcePublicGitValue, was: %T`, publicGitAttribute))
	}

	publicSwiftAttribute, ok := attributes["public_swift"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`public_swift is missing from object`)

		return NewVolumesVolumeSourceValueUnknown(), diags
	}

	publicSwiftVal, ok := publicSwiftAttribute.(VolumesVolumeSourcePublicSwiftValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`public_swift expected to be VolumesVolumeSourcePublicSwiftValue, was: %T`, publicSwiftAttribute))
	}

	standaloneAttribute, ok := attributes["standalone"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`standalone is missing from object`)

		return NewVolumesVolumeSourceValueUnknown(), diags
	}

	standaloneVal, ok := standaloneAttribute.(VolumesVolumeSourceStandaloneValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`standalone expected to be VolumesVolumeSourceStandaloneValue, was: %T`, standaloneAttribute))
	}

	if diags.HasError() {
		return NewVolumesVolumeSourceValueUnknown(), diags
	}

	return VolumesVolumeSourceValue{
		DataStore:   dataStoreVal,
		PublicGit:   publicGitVal,
		PublicSwift: publicSwiftVal,
		Standalone:  standaloneVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewVolumesVolumeSourceValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) VolumesVolumeSourceValue {
	object, diags := NewVolumesVolumeSourceValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewVolumesVolumeSourceValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t VolumesVolumeSourceType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewVolumesVolumeSourceValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewVolumesVolumeSourceValueUnknown(), nil
	}

	if in.IsNull() {
		return NewVolumesVolumeSourceValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewVolumesVolumeSourceValueMust(VolumesVolumeSourceValue{}.AttributeTypes(ctx), attributes), nil
}

func (t VolumesVolumeSourceType) ValueType(ctx context.Context) attr.Value {
	return VolumesVolumeSourceValue{}
}

var _ basetypes.ObjectValuable = VolumesVolumeSourceValue{}

type VolumesVolumeSourceValue struct {
	DataStore   VolumesVolumeSourceDataStoreValue   `tfsdk:"data_store" json:"dataStore"`
	PublicGit   VolumesVolumeSourcePublicGitValue   `tfsdk:"public_git" json:"publicGit"`
	PublicSwift VolumesVolumeSourcePublicSwiftValue `tfsdk:"public_swift" json:"publicSwift"`
	Standalone  VolumesVolumeSourceStandaloneValue  `tfsdk:"standalone" json:"standalone"`
	state       attr.ValueState
}

func (v VolumesVolumeSourceValue) ToCreate() *VolumesVolumeSourceValue {
	res := &VolumesVolumeSourceValue{}

	if !v.DataStore.IsNull() {
		res.DataStore = v.DataStore
	}

	if !v.PublicGit.IsNull() {
		res.PublicGit = v.PublicGit
	}

	if !v.PublicSwift.IsNull() {
		res.PublicSwift = v.PublicSwift
	}

	if !v.Standalone.IsNull() {
		res.Standalone = v.Standalone
	}

	res.state = attr.ValueStateKnown

	return res
}

func (v VolumesVolumeSourceValue) MarshalJSON() ([]byte, error) {
	toMarshal := map[string]any{}
	if !v.DataStore.IsNull() && !v.DataStore.IsUnknown() {
		toMarshal["dataStore"] = v.DataStore
	}
	if !v.PublicGit.IsNull() && !v.PublicGit.IsUnknown() {
		toMarshal["publicGit"] = v.PublicGit
	}
	if !v.PublicSwift.IsNull() && !v.PublicSwift.IsUnknown() {
		toMarshal["publicSwift"] = v.PublicSwift
	}
	if !v.Standalone.IsNull() && !v.Standalone.IsUnknown() {
		toMarshal["standalone"] = v.Standalone
	}

	return json.Marshal(toMarshal)
}

func (v *VolumesVolumeSourceValue) UnmarshalJSON(data []byte) error {
	type JsonVolumesVolumeSourceValue VolumesVolumeSourceValue

	var tmp JsonVolumesVolumeSourceValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.DataStore = tmp.DataStore
	v.PublicGit = tmp.PublicGit
	v.PublicSwift = tmp.PublicSwift
	v.Standalone = tmp.Standalone

	v.state = attr.ValueStateKnown

	return nil
}

func (v *VolumesVolumeSourceValue) MergeWith(other *VolumesVolumeSourceValue) {

	if v.DataStore.IsUnknown() && !other.DataStore.IsUnknown() {
		v.DataStore = other.DataStore
	} else if !other.DataStore.IsUnknown() {
		v.DataStore.MergeWith(&other.DataStore)
	}

	if v.PublicGit.IsUnknown() && !other.PublicGit.IsUnknown() {
		v.PublicGit = other.PublicGit
	} else if !other.PublicGit.IsUnknown() {
		v.PublicGit.MergeWith(&other.PublicGit)
	}

	if v.PublicSwift.IsUnknown() && !other.PublicSwift.IsUnknown() {
		v.PublicSwift = other.PublicSwift
	} else if !other.PublicSwift.IsUnknown() {
		v.PublicSwift.MergeWith(&other.PublicSwift)
	}

	if v.Standalone.IsUnknown() && !other.Standalone.IsUnknown() {
		v.Standalone = other.Standalone
	} else if !other.Standalone.IsUnknown() {
		v.Standalone.MergeWith(&other.Standalone)
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v VolumesVolumeSourceValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"dataStore":   v.DataStore,
		"publicGit":   v.PublicGit,
		"publicSwift": v.PublicSwift,
		"standalone":  v.Standalone,
	}
}
func (v VolumesVolumeSourceValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["data_store"] = basetypes.ObjectType{
		AttrTypes: VolumesVolumeSourceDataStoreValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["public_git"] = basetypes.ObjectType{
		AttrTypes: VolumesVolumeSourcePublicGitValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["public_swift"] = basetypes.ObjectType{
		AttrTypes: VolumesVolumeSourcePublicSwiftValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["standalone"] = basetypes.ObjectType{
		AttrTypes: VolumesVolumeSourceStandaloneValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.DataStore.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["data_store"] = val

		val, err = v.PublicGit.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["public_git"] = val

		val, err = v.PublicSwift.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["public_swift"] = val

		val, err = v.Standalone.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["standalone"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v VolumesVolumeSourceValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v VolumesVolumeSourceValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v VolumesVolumeSourceValue) String() string {
	return "VolumesVolumeSourceValue"
}

func (v VolumesVolumeSourceValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"data_store": VolumesVolumeSourceDataStoreType{
				basetypes.ObjectType{
					AttrTypes: VolumesVolumeSourceDataStoreValue{}.AttributeTypes(ctx),
				},
			},
			"public_git": VolumesVolumeSourcePublicGitType{
				basetypes.ObjectType{
					AttrTypes: VolumesVolumeSourcePublicGitValue{}.AttributeTypes(ctx),
				},
			},
			"public_swift": VolumesVolumeSourcePublicSwiftType{
				basetypes.ObjectType{
					AttrTypes: VolumesVolumeSourcePublicSwiftValue{}.AttributeTypes(ctx),
				},
			},
			"standalone": VolumesVolumeSourceStandaloneType{
				basetypes.ObjectType{
					AttrTypes: VolumesVolumeSourceStandaloneValue{}.AttributeTypes(ctx),
				},
			},
		},
		map[string]attr.Value{
			"data_store":   v.DataStore,
			"public_git":   v.PublicGit,
			"public_swift": v.PublicSwift,
			"standalone":   v.Standalone,
		})

	return objVal, diags
}

func (v VolumesVolumeSourceValue) Equal(o attr.Value) bool {
	other, ok := o.(VolumesVolumeSourceValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.DataStore.Equal(other.DataStore) {
		return false
	}

	if !v.PublicGit.Equal(other.PublicGit) {
		return false
	}

	if !v.PublicSwift.Equal(other.PublicSwift) {
		return false
	}

	if !v.Standalone.Equal(other.Standalone) {
		return false
	}

	return true
}

func (v VolumesVolumeSourceValue) Type(ctx context.Context) attr.Type {
	return VolumesVolumeSourceType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v VolumesVolumeSourceValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"data_store":   VolumesVolumeSourceDataStoreValue{}.Type(ctx),
		"public_git":   VolumesVolumeSourcePublicGitValue{}.Type(ctx),
		"public_swift": VolumesVolumeSourcePublicSwiftValue{}.Type(ctx),
		"standalone":   VolumesVolumeSourceStandaloneValue{}.Type(ctx),
	}
}

var _ basetypes.ObjectTypable = VolumesVolumeSourceDataStoreType{}

type VolumesVolumeSourceDataStoreType struct {
	basetypes.ObjectType
}

func (t VolumesVolumeSourceDataStoreType) Equal(o attr.Type) bool {
	other, ok := o.(VolumesVolumeSourceDataStoreType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t VolumesVolumeSourceDataStoreType) String() string {
	return "VolumesVolumeSourceDataStoreType"
}

func (t VolumesVolumeSourceDataStoreType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	aliasAttribute, ok := attributes["alias"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`alias is missing from object`)

		return nil, diags
	}

	aliasVal, ok := aliasAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`alias expected to be ovhtypes.TfStringValue, was: %T`, aliasAttribute))
	}

	archiveAttribute, ok := attributes["archive"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`archive is missing from object`)

		return nil, diags
	}

	archiveVal, ok := archiveAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`archive expected to be ovhtypes.TfStringValue, was: %T`, archiveAttribute))
	}

	containerAttribute, ok := attributes["container"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`container is missing from object`)

		return nil, diags
	}

	containerVal, ok := containerAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`container expected to be ovhtypes.TfStringValue, was: %T`, containerAttribute))
	}

	internalAttribute, ok := attributes["internal"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`internal is missing from object`)

		return nil, diags
	}

	internalVal, ok := internalAttribute.(ovhtypes.TfBoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`internal expected to be ovhtypes.TfBoolValue, was: %T`, internalAttribute))
	}

	prefixAttribute, ok := attributes["prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix is missing from object`)

		return nil, diags
	}

	prefixVal, ok := prefixAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix expected to be ovhtypes.TfStringValue, was: %T`, prefixAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return VolumesVolumeSourceDataStoreValue{
		Alias:     aliasVal,
		Archive:   archiveVal,
		Container: containerVal,
		Internal:  internalVal,
		Prefix:    prefixVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewVolumesVolumeSourceDataStoreValueNull() VolumesVolumeSourceDataStoreValue {
	return VolumesVolumeSourceDataStoreValue{
		state: attr.ValueStateNull,
	}
}

func NewVolumesVolumeSourceDataStoreValueUnknown() VolumesVolumeSourceDataStoreValue {
	return VolumesVolumeSourceDataStoreValue{
		state: attr.ValueStateUnknown,
	}
}

func NewVolumesVolumeSourceDataStoreValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (VolumesVolumeSourceDataStoreValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing VolumesVolumeSourceDataStoreValue Attribute Value",
				"While creating a VolumesVolumeSourceDataStoreValue value, a missing attribute value was detected. "+
					"A VolumesVolumeSourceDataStoreValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VolumesVolumeSourceDataStoreValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid VolumesVolumeSourceDataStoreValue Attribute Type",
				"While creating a VolumesVolumeSourceDataStoreValue value, an invalid attribute value was detected. "+
					"A VolumesVolumeSourceDataStoreValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VolumesVolumeSourceDataStoreValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("VolumesVolumeSourceDataStoreValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra VolumesVolumeSourceDataStoreValue Attribute Value",
				"While creating a VolumesVolumeSourceDataStoreValue value, an extra attribute value was detected. "+
					"A VolumesVolumeSourceDataStoreValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra VolumesVolumeSourceDataStoreValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewVolumesVolumeSourceDataStoreValueUnknown(), diags
	}

	aliasAttribute, ok := attributes["alias"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`alias is missing from object`)

		return NewVolumesVolumeSourceDataStoreValueUnknown(), diags
	}

	aliasVal, ok := aliasAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`alias expected to be ovhtypes.TfStringValue, was: %T`, aliasAttribute))
	}

	archiveAttribute, ok := attributes["archive"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`archive is missing from object`)

		return NewVolumesVolumeSourceDataStoreValueUnknown(), diags
	}

	archiveVal, ok := archiveAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`archive expected to be ovhtypes.TfStringValue, was: %T`, archiveAttribute))
	}

	containerAttribute, ok := attributes["container"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`container is missing from object`)

		return NewVolumesVolumeSourceDataStoreValueUnknown(), diags
	}

	containerVal, ok := containerAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`container expected to be ovhtypes.TfStringValue, was: %T`, containerAttribute))
	}

	internalAttribute, ok := attributes["internal"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`internal is missing from object`)

		return NewVolumesVolumeSourceDataStoreValueUnknown(), diags
	}

	internalVal, ok := internalAttribute.(ovhtypes.TfBoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`internal expected to be ovhtypes.TfBoolValue, was: %T`, internalAttribute))
	}

	prefixAttribute, ok := attributes["prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix is missing from object`)

		return NewVolumesVolumeSourceDataStoreValueUnknown(), diags
	}

	prefixVal, ok := prefixAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix expected to be ovhtypes.TfStringValue, was: %T`, prefixAttribute))
	}

	if diags.HasError() {
		return NewVolumesVolumeSourceDataStoreValueUnknown(), diags
	}

	return VolumesVolumeSourceDataStoreValue{
		Alias:     aliasVal,
		Archive:   archiveVal,
		Container: containerVal,
		Internal:  internalVal,
		Prefix:    prefixVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewVolumesVolumeSourceDataStoreValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) VolumesVolumeSourceDataStoreValue {
	object, diags := NewVolumesVolumeSourceDataStoreValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewVolumesVolumeSourceDataStoreValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t VolumesVolumeSourceDataStoreType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewVolumesVolumeSourceDataStoreValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewVolumesVolumeSourceDataStoreValueUnknown(), nil
	}

	if in.IsNull() {
		return NewVolumesVolumeSourceDataStoreValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewVolumesVolumeSourceDataStoreValueMust(VolumesVolumeSourceDataStoreValue{}.AttributeTypes(ctx), attributes), nil
}

func (t VolumesVolumeSourceDataStoreType) ValueType(ctx context.Context) attr.Value {
	return VolumesVolumeSourceDataStoreValue{}
}

var _ basetypes.ObjectValuable = VolumesVolumeSourceDataStoreValue{}

type VolumesVolumeSourceDataStoreValue struct {
	Alias     ovhtypes.TfStringValue `tfsdk:"alias" json:"alias"`
	Archive   ovhtypes.TfStringValue `tfsdk:"archive" json:"archive"`
	Container ovhtypes.TfStringValue `tfsdk:"container" json:"container"`
	Internal  ovhtypes.TfBoolValue   `tfsdk:"internal" json:"internal"`
	Prefix    ovhtypes.TfStringValue `tfsdk:"prefix" json:"prefix"`
	state     attr.ValueState
}

func (v VolumesVolumeSourceDataStoreValue) ToCreate() *VolumesVolumeSourceDataStoreValue {
	res := &VolumesVolumeSourceDataStoreValue{}

	if !v.Container.IsNull() {
		res.Container = v.Container
	}

	if !v.Internal.IsNull() {
		res.Internal = v.Internal
	}

	if !v.Prefix.IsNull() {
		res.Prefix = v.Prefix
	}

	if !v.Alias.IsNull() {
		res.Alias = v.Alias
	}

	if !v.Archive.IsNull() {
		res.Archive = v.Archive
	}

	res.state = attr.ValueStateKnown

	return res
}

func (v VolumesVolumeSourceDataStoreValue) MarshalJSON() ([]byte, error) {
	toMarshal := map[string]any{}
	if !v.Alias.IsNull() && !v.Alias.IsUnknown() {
		toMarshal["alias"] = v.Alias
	}
	if !v.Archive.IsNull() && !v.Archive.IsUnknown() {
		toMarshal["archive"] = v.Archive
	}
	if !v.Container.IsNull() && !v.Container.IsUnknown() {
		toMarshal["container"] = v.Container
	}
	if !v.Internal.IsNull() && !v.Internal.IsUnknown() {
		toMarshal["internal"] = v.Internal
	}
	if !v.Prefix.IsNull() && !v.Prefix.IsUnknown() {
		toMarshal["prefix"] = v.Prefix
	}

	return json.Marshal(toMarshal)
}

func (v *VolumesVolumeSourceDataStoreValue) UnmarshalJSON(data []byte) error {
	type JsonVolumesVolumeSourceDataStoreValue VolumesVolumeSourceDataStoreValue

	var tmp JsonVolumesVolumeSourceDataStoreValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.Alias = tmp.Alias
	v.Archive = tmp.Archive
	v.Container = tmp.Container
	v.Internal = tmp.Internal
	v.Prefix = tmp.Prefix

	v.state = attr.ValueStateKnown

	return nil
}

func (v *VolumesVolumeSourceDataStoreValue) MergeWith(other *VolumesVolumeSourceDataStoreValue) {

	if (v.Alias.IsUnknown() || v.Alias.IsNull()) && !other.Alias.IsUnknown() {
		v.Alias = other.Alias
	}

	if (v.Archive.IsUnknown() || v.Archive.IsNull()) && !other.Archive.IsUnknown() {
		v.Archive = other.Archive
	}

	if (v.Container.IsUnknown() || v.Container.IsNull()) && !other.Container.IsUnknown() {
		v.Container = other.Container
	}

	if (v.Internal.IsUnknown() || v.Internal.IsNull()) && !other.Internal.IsUnknown() {
		v.Internal = other.Internal
	}

	if (v.Prefix.IsUnknown() || v.Prefix.IsNull()) && !other.Prefix.IsUnknown() {
		v.Prefix = other.Prefix
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v VolumesVolumeSourceDataStoreValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"alias":     v.Alias,
		"archive":   v.Archive,
		"container": v.Container,
		"internal":  v.Internal,
		"prefix":    v.Prefix,
	}
}
func (v VolumesVolumeSourceDataStoreValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["alias"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["archive"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["container"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["internal"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["prefix"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.Alias.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["alias"] = val

		val, err = v.Archive.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["archive"] = val

		val, err = v.Container.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["container"] = val

		val, err = v.Internal.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["internal"] = val

		val, err = v.Prefix.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["prefix"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v VolumesVolumeSourceDataStoreValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v VolumesVolumeSourceDataStoreValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v VolumesVolumeSourceDataStoreValue) String() string {
	return "VolumesVolumeSourceDataStoreValue"
}

func (v VolumesVolumeSourceDataStoreValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"alias":     ovhtypes.TfStringType{},
			"archive":   ovhtypes.TfStringType{},
			"container": ovhtypes.TfStringType{},
			"internal":  ovhtypes.TfBoolType{},
			"prefix":    ovhtypes.TfStringType{},
		},
		map[string]attr.Value{
			"alias":     v.Alias,
			"archive":   v.Archive,
			"container": v.Container,
			"internal":  v.Internal,
			"prefix":    v.Prefix,
		})

	return objVal, diags
}

func (v VolumesVolumeSourceDataStoreValue) Equal(o attr.Value) bool {
	other, ok := o.(VolumesVolumeSourceDataStoreValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Alias.Equal(other.Alias) {
		return false
	}

	if !v.Archive.Equal(other.Archive) {
		return false
	}

	if !v.Container.Equal(other.Container) {
		return false
	}

	if !v.Internal.Equal(other.Internal) {
		return false
	}

	if !v.Prefix.Equal(other.Prefix) {
		return false
	}

	return true
}

func (v VolumesVolumeSourceDataStoreValue) Type(ctx context.Context) attr.Type {
	return VolumesVolumeSourceDataStoreType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v VolumesVolumeSourceDataStoreValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"alias":     ovhtypes.TfStringType{},
		"archive":   ovhtypes.TfStringType{},
		"container": ovhtypes.TfStringType{},
		"internal":  ovhtypes.TfBoolType{},
		"prefix":    ovhtypes.TfStringType{},
	}
}

var _ basetypes.ObjectTypable = VolumesVolumeSourcePublicGitType{}

type VolumesVolumeSourcePublicGitType struct {
	basetypes.ObjectType
}

func (t VolumesVolumeSourcePublicGitType) Equal(o attr.Type) bool {
	other, ok := o.(VolumesVolumeSourcePublicGitType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t VolumesVolumeSourcePublicGitType) String() string {
	return "VolumesVolumeSourcePublicGitType"
}

func (t VolumesVolumeSourcePublicGitType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return nil, diags
	}

	urlVal, ok := urlAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be ovhtypes.TfStringValue, was: %T`, urlAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return VolumesVolumeSourcePublicGitValue{
		Url:   urlVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewVolumesVolumeSourcePublicGitValueNull() VolumesVolumeSourcePublicGitValue {
	return VolumesVolumeSourcePublicGitValue{
		state: attr.ValueStateNull,
	}
}

func NewVolumesVolumeSourcePublicGitValueUnknown() VolumesVolumeSourcePublicGitValue {
	return VolumesVolumeSourcePublicGitValue{
		state: attr.ValueStateUnknown,
	}
}

func NewVolumesVolumeSourcePublicGitValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (VolumesVolumeSourcePublicGitValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing VolumesVolumeSourcePublicGitValue Attribute Value",
				"While creating a VolumesVolumeSourcePublicGitValue value, a missing attribute value was detected. "+
					"A VolumesVolumeSourcePublicGitValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VolumesVolumeSourcePublicGitValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid VolumesVolumeSourcePublicGitValue Attribute Type",
				"While creating a VolumesVolumeSourcePublicGitValue value, an invalid attribute value was detected. "+
					"A VolumesVolumeSourcePublicGitValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VolumesVolumeSourcePublicGitValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("VolumesVolumeSourcePublicGitValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra VolumesVolumeSourcePublicGitValue Attribute Value",
				"While creating a VolumesVolumeSourcePublicGitValue value, an extra attribute value was detected. "+
					"A VolumesVolumeSourcePublicGitValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra VolumesVolumeSourcePublicGitValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewVolumesVolumeSourcePublicGitValueUnknown(), diags
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return NewVolumesVolumeSourcePublicGitValueUnknown(), diags
	}

	urlVal, ok := urlAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be ovhtypes.TfStringValue, was: %T`, urlAttribute))
	}

	if diags.HasError() {
		return NewVolumesVolumeSourcePublicGitValueUnknown(), diags
	}

	return VolumesVolumeSourcePublicGitValue{
		Url:   urlVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewVolumesVolumeSourcePublicGitValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) VolumesVolumeSourcePublicGitValue {
	object, diags := NewVolumesVolumeSourcePublicGitValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewVolumesVolumeSourcePublicGitValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t VolumesVolumeSourcePublicGitType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewVolumesVolumeSourcePublicGitValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewVolumesVolumeSourcePublicGitValueUnknown(), nil
	}

	if in.IsNull() {
		return NewVolumesVolumeSourcePublicGitValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewVolumesVolumeSourcePublicGitValueMust(VolumesVolumeSourcePublicGitValue{}.AttributeTypes(ctx), attributes), nil
}

func (t VolumesVolumeSourcePublicGitType) ValueType(ctx context.Context) attr.Value {
	return VolumesVolumeSourcePublicGitValue{}
}

var _ basetypes.ObjectValuable = VolumesVolumeSourcePublicGitValue{}

type VolumesVolumeSourcePublicGitValue struct {
	Url   ovhtypes.TfStringValue `tfsdk:"url" json:"url"`
	state attr.ValueState
}

func (v VolumesVolumeSourcePublicGitValue) ToCreate() *VolumesVolumeSourcePublicGitValue {
	res := &VolumesVolumeSourcePublicGitValue{}

	if !v.Url.IsNull() {
		res.Url = v.Url
	}

	res.state = attr.ValueStateKnown

	return res
}

func (v VolumesVolumeSourcePublicGitValue) MarshalJSON() ([]byte, error) {
	toMarshal := map[string]any{}
	if !v.Url.IsNull() && !v.Url.IsUnknown() {
		toMarshal["url"] = v.Url
	}

	return json.Marshal(toMarshal)
}

func (v *VolumesVolumeSourcePublicGitValue) UnmarshalJSON(data []byte) error {
	type JsonVolumesVolumeSourcePublicGitValue VolumesVolumeSourcePublicGitValue

	var tmp JsonVolumesVolumeSourcePublicGitValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.Url = tmp.Url

	v.state = attr.ValueStateKnown

	return nil
}

func (v *VolumesVolumeSourcePublicGitValue) MergeWith(other *VolumesVolumeSourcePublicGitValue) {

	if (v.Url.IsUnknown() || v.Url.IsNull()) && !other.Url.IsUnknown() {
		v.Url = other.Url
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v VolumesVolumeSourcePublicGitValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"url": v.Url,
	}
}
func (v VolumesVolumeSourcePublicGitValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["url"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Url.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["url"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v VolumesVolumeSourcePublicGitValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v VolumesVolumeSourcePublicGitValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v VolumesVolumeSourcePublicGitValue) String() string {
	return "VolumesVolumeSourcePublicGitValue"
}

func (v VolumesVolumeSourcePublicGitValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"url": ovhtypes.TfStringType{},
		},
		map[string]attr.Value{
			"url": v.Url,
		})

	return objVal, diags
}

func (v VolumesVolumeSourcePublicGitValue) Equal(o attr.Value) bool {
	other, ok := o.(VolumesVolumeSourcePublicGitValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Url.Equal(other.Url) {
		return false
	}

	return true
}

func (v VolumesVolumeSourcePublicGitValue) Type(ctx context.Context) attr.Type {
	return VolumesVolumeSourcePublicGitType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v VolumesVolumeSourcePublicGitValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"url": ovhtypes.TfStringType{},
	}
}

var _ basetypes.ObjectTypable = VolumesVolumeSourcePublicSwiftType{}

type VolumesVolumeSourcePublicSwiftType struct {
	basetypes.ObjectType
}

func (t VolumesVolumeSourcePublicSwiftType) Equal(o attr.Type) bool {
	other, ok := o.(VolumesVolumeSourcePublicSwiftType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t VolumesVolumeSourcePublicSwiftType) String() string {
	return "VolumesVolumeSourcePublicSwiftType"
}

func (t VolumesVolumeSourcePublicSwiftType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return nil, diags
	}

	urlVal, ok := urlAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be ovhtypes.TfStringValue, was: %T`, urlAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return VolumesVolumeSourcePublicSwiftValue{
		Url:   urlVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewVolumesVolumeSourcePublicSwiftValueNull() VolumesVolumeSourcePublicSwiftValue {
	return VolumesVolumeSourcePublicSwiftValue{
		state: attr.ValueStateNull,
	}
}

func NewVolumesVolumeSourcePublicSwiftValueUnknown() VolumesVolumeSourcePublicSwiftValue {
	return VolumesVolumeSourcePublicSwiftValue{
		state: attr.ValueStateUnknown,
	}
}

func NewVolumesVolumeSourcePublicSwiftValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (VolumesVolumeSourcePublicSwiftValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing VolumesVolumeSourcePublicSwiftValue Attribute Value",
				"While creating a VolumesVolumeSourcePublicSwiftValue value, a missing attribute value was detected. "+
					"A VolumesVolumeSourcePublicSwiftValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VolumesVolumeSourcePublicSwiftValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid VolumesVolumeSourcePublicSwiftValue Attribute Type",
				"While creating a VolumesVolumeSourcePublicSwiftValue value, an invalid attribute value was detected. "+
					"A VolumesVolumeSourcePublicSwiftValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VolumesVolumeSourcePublicSwiftValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("VolumesVolumeSourcePublicSwiftValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra VolumesVolumeSourcePublicSwiftValue Attribute Value",
				"While creating a VolumesVolumeSourcePublicSwiftValue value, an extra attribute value was detected. "+
					"A VolumesVolumeSourcePublicSwiftValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra VolumesVolumeSourcePublicSwiftValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewVolumesVolumeSourcePublicSwiftValueUnknown(), diags
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return NewVolumesVolumeSourcePublicSwiftValueUnknown(), diags
	}

	urlVal, ok := urlAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be ovhtypes.TfStringValue, was: %T`, urlAttribute))
	}

	if diags.HasError() {
		return NewVolumesVolumeSourcePublicSwiftValueUnknown(), diags
	}

	return VolumesVolumeSourcePublicSwiftValue{
		Url:   urlVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewVolumesVolumeSourcePublicSwiftValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) VolumesVolumeSourcePublicSwiftValue {
	object, diags := NewVolumesVolumeSourcePublicSwiftValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewVolumesVolumeSourcePublicSwiftValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t VolumesVolumeSourcePublicSwiftType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewVolumesVolumeSourcePublicSwiftValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewVolumesVolumeSourcePublicSwiftValueUnknown(), nil
	}

	if in.IsNull() {
		return NewVolumesVolumeSourcePublicSwiftValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewVolumesVolumeSourcePublicSwiftValueMust(VolumesVolumeSourcePublicSwiftValue{}.AttributeTypes(ctx), attributes), nil
}

func (t VolumesVolumeSourcePublicSwiftType) ValueType(ctx context.Context) attr.Value {
	return VolumesVolumeSourcePublicSwiftValue{}
}

var _ basetypes.ObjectValuable = VolumesVolumeSourcePublicSwiftValue{}

type VolumesVolumeSourcePublicSwiftValue struct {
	Url   ovhtypes.TfStringValue `tfsdk:"url" json:"url"`
	state attr.ValueState
}

func (v VolumesVolumeSourcePublicSwiftValue) ToCreate() *VolumesVolumeSourcePublicSwiftValue {
	res := &VolumesVolumeSourcePublicSwiftValue{}

	if !v.Url.IsNull() {
		res.Url = v.Url
	}

	res.state = attr.ValueStateKnown

	return res
}

func (v VolumesVolumeSourcePublicSwiftValue) MarshalJSON() ([]byte, error) {
	toMarshal := map[string]any{}
	if !v.Url.IsNull() && !v.Url.IsUnknown() {
		toMarshal["url"] = v.Url
	}

	return json.Marshal(toMarshal)
}

func (v *VolumesVolumeSourcePublicSwiftValue) UnmarshalJSON(data []byte) error {
	type JsonVolumesVolumeSourcePublicSwiftValue VolumesVolumeSourcePublicSwiftValue

	var tmp JsonVolumesVolumeSourcePublicSwiftValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.Url = tmp.Url

	v.state = attr.ValueStateKnown

	return nil
}

func (v *VolumesVolumeSourcePublicSwiftValue) MergeWith(other *VolumesVolumeSourcePublicSwiftValue) {

	if (v.Url.IsUnknown() || v.Url.IsNull()) && !other.Url.IsUnknown() {
		v.Url = other.Url
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v VolumesVolumeSourcePublicSwiftValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"url": v.Url,
	}
}
func (v VolumesVolumeSourcePublicSwiftValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["url"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Url.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["url"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v VolumesVolumeSourcePublicSwiftValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v VolumesVolumeSourcePublicSwiftValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v VolumesVolumeSourcePublicSwiftValue) String() string {
	return "VolumesVolumeSourcePublicSwiftValue"
}

func (v VolumesVolumeSourcePublicSwiftValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"url": ovhtypes.TfStringType{},
		},
		map[string]attr.Value{
			"url": v.Url,
		})

	return objVal, diags
}

func (v VolumesVolumeSourcePublicSwiftValue) Equal(o attr.Value) bool {
	other, ok := o.(VolumesVolumeSourcePublicSwiftValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Url.Equal(other.Url) {
		return false
	}

	return true
}

func (v VolumesVolumeSourcePublicSwiftValue) Type(ctx context.Context) attr.Type {
	return VolumesVolumeSourcePublicSwiftType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v VolumesVolumeSourcePublicSwiftValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"url": ovhtypes.TfStringType{},
	}
}

var _ basetypes.ObjectTypable = VolumesVolumeSourceStandaloneType{}

type VolumesVolumeSourceStandaloneType struct {
	basetypes.ObjectType
}

func (t VolumesVolumeSourceStandaloneType) Equal(o attr.Type) bool {
	other, ok := o.(VolumesVolumeSourceStandaloneType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t VolumesVolumeSourceStandaloneType) String() string {
	return "VolumesVolumeSourceStandaloneType"
}

func (t VolumesVolumeSourceStandaloneType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be ovhtypes.TfStringValue, was: %T`, nameAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return VolumesVolumeSourceStandaloneValue{
		Name:  nameVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewVolumesVolumeSourceStandaloneValueNull() VolumesVolumeSourceStandaloneValue {
	return VolumesVolumeSourceStandaloneValue{
		state: attr.ValueStateNull,
	}
}

func NewVolumesVolumeSourceStandaloneValueUnknown() VolumesVolumeSourceStandaloneValue {
	return VolumesVolumeSourceStandaloneValue{
		state: attr.ValueStateUnknown,
	}
}

func NewVolumesVolumeSourceStandaloneValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (VolumesVolumeSourceStandaloneValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing VolumesVolumeSourceStandaloneValue Attribute Value",
				"While creating a VolumesVolumeSourceStandaloneValue value, a missing attribute value was detected. "+
					"A VolumesVolumeSourceStandaloneValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VolumesVolumeSourceStandaloneValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid VolumesVolumeSourceStandaloneValue Attribute Type",
				"While creating a VolumesVolumeSourceStandaloneValue value, an invalid attribute value was detected. "+
					"A VolumesVolumeSourceStandaloneValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VolumesVolumeSourceStandaloneValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("VolumesVolumeSourceStandaloneValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra VolumesVolumeSourceStandaloneValue Attribute Value",
				"While creating a VolumesVolumeSourceStandaloneValue value, an extra attribute value was detected. "+
					"A VolumesVolumeSourceStandaloneValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra VolumesVolumeSourceStandaloneValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewVolumesVolumeSourceStandaloneValueUnknown(), diags
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewVolumesVolumeSourceStandaloneValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be ovhtypes.TfStringValue, was: %T`, nameAttribute))
	}

	if diags.HasError() {
		return NewVolumesVolumeSourceStandaloneValueUnknown(), diags
	}

	return VolumesVolumeSourceStandaloneValue{
		Name:  nameVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewVolumesVolumeSourceStandaloneValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) VolumesVolumeSourceStandaloneValue {
	object, diags := NewVolumesVolumeSourceStandaloneValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewVolumesVolumeSourceStandaloneValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t VolumesVolumeSourceStandaloneType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewVolumesVolumeSourceStandaloneValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewVolumesVolumeSourceStandaloneValueUnknown(), nil
	}

	if in.IsNull() {
		return NewVolumesVolumeSourceStandaloneValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewVolumesVolumeSourceStandaloneValueMust(VolumesVolumeSourceStandaloneValue{}.AttributeTypes(ctx), attributes), nil
}

func (t VolumesVolumeSourceStandaloneType) ValueType(ctx context.Context) attr.Value {
	return VolumesVolumeSourceStandaloneValue{}
}

var _ basetypes.ObjectValuable = VolumesVolumeSourceStandaloneValue{}

type VolumesVolumeSourceStandaloneValue struct {
	Name  ovhtypes.TfStringValue `tfsdk:"name" json:"name"`
	state attr.ValueState
}

func (v VolumesVolumeSourceStandaloneValue) ToCreate() *VolumesVolumeSourceStandaloneValue {
	res := &VolumesVolumeSourceStandaloneValue{}

	if !v.Name.IsNull() {
		res.Name = v.Name
	}

	res.state = attr.ValueStateKnown

	return res
}

func (v VolumesVolumeSourceStandaloneValue) MarshalJSON() ([]byte, error) {
	toMarshal := map[string]any{}
	if !v.Name.IsNull() && !v.Name.IsUnknown() {
		toMarshal["name"] = v.Name
	}

	return json.Marshal(toMarshal)
}

func (v *VolumesVolumeSourceStandaloneValue) UnmarshalJSON(data []byte) error {
	type JsonVolumesVolumeSourceStandaloneValue VolumesVolumeSourceStandaloneValue

	var tmp JsonVolumesVolumeSourceStandaloneValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.Name = tmp.Name

	v.state = attr.ValueStateKnown

	return nil
}

func (v *VolumesVolumeSourceStandaloneValue) MergeWith(other *VolumesVolumeSourceStandaloneValue) {

	if (v.Name.IsUnknown() || v.Name.IsNull()) && !other.Name.IsUnknown() {
		v.Name = other.Name
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v VolumesVolumeSourceStandaloneValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"name": v.Name,
	}
}
func (v VolumesVolumeSourceStandaloneValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v VolumesVolumeSourceStandaloneValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v VolumesVolumeSourceStandaloneValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v VolumesVolumeSourceStandaloneValue) String() string {
	return "VolumesVolumeSourceStandaloneValue"
}

func (v VolumesVolumeSourceStandaloneValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"name": ovhtypes.TfStringType{},
		},
		map[string]attr.Value{
			"name": v.Name,
		})

	return objVal, diags
}

func (v VolumesVolumeSourceStandaloneValue) Equal(o attr.Value) bool {
	other, ok := o.(VolumesVolumeSourceStandaloneValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	return true
}

func (v VolumesVolumeSourceStandaloneValue) Type(ctx context.Context) attr.Type {
	return VolumesVolumeSourceStandaloneType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v VolumesVolumeSourceStandaloneValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"name": ovhtypes.TfStringType{},
	}
}

var _ basetypes.ObjectTypable = VolumesVolumeTargetType{}

type VolumesVolumeTargetType struct {
	basetypes.ObjectType
}

func (t VolumesVolumeTargetType) Equal(o attr.Type) bool {
	other, ok := o.(VolumesVolumeTargetType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t VolumesVolumeTargetType) String() string {
	return "VolumesVolumeTargetType"
}

func (t VolumesVolumeTargetType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	targetDataStoreAttribute, ok := attributes["target_data_store"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`target_data_store is missing from object`)

		return nil, diags
	}

	targetDataStoreVal, ok := targetDataStoreAttribute.(VolumesVolumeTargetTargetDataStoreValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`target_data_store expected to be VolumesVolumeTargetTargetDataStoreValue, was: %T`, targetDataStoreAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return VolumesVolumeTargetValue{
		TargetDataStore: targetDataStoreVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewVolumesVolumeTargetValueNull() VolumesVolumeTargetValue {
	return VolumesVolumeTargetValue{
		state: attr.ValueStateNull,
	}
}

func NewVolumesVolumeTargetValueUnknown() VolumesVolumeTargetValue {
	return VolumesVolumeTargetValue{
		state: attr.ValueStateUnknown,
	}
}

func NewVolumesVolumeTargetValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (VolumesVolumeTargetValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing VolumesVolumeTargetValue Attribute Value",
				"While creating a VolumesVolumeTargetValue value, a missing attribute value was detected. "+
					"A VolumesVolumeTargetValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VolumesVolumeTargetValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid VolumesVolumeTargetValue Attribute Type",
				"While creating a VolumesVolumeTargetValue value, an invalid attribute value was detected. "+
					"A VolumesVolumeTargetValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VolumesVolumeTargetValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("VolumesVolumeTargetValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra VolumesVolumeTargetValue Attribute Value",
				"While creating a VolumesVolumeTargetValue value, an extra attribute value was detected. "+
					"A VolumesVolumeTargetValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra VolumesVolumeTargetValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewVolumesVolumeTargetValueUnknown(), diags
	}

	targetDataStoreAttribute, ok := attributes["target_data_store"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`target_data_store is missing from object`)

		return NewVolumesVolumeTargetValueUnknown(), diags
	}

	targetDataStoreVal, ok := targetDataStoreAttribute.(VolumesVolumeTargetTargetDataStoreValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`target_data_store expected to be VolumesVolumeTargetTargetDataStoreValue, was: %T`, targetDataStoreAttribute))
	}

	if diags.HasError() {
		return NewVolumesVolumeTargetValueUnknown(), diags
	}

	return VolumesVolumeTargetValue{
		TargetDataStore: targetDataStoreVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewVolumesVolumeTargetValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) VolumesVolumeTargetValue {
	object, diags := NewVolumesVolumeTargetValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewVolumesVolumeTargetValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t VolumesVolumeTargetType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewVolumesVolumeTargetValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewVolumesVolumeTargetValueUnknown(), nil
	}

	if in.IsNull() {
		return NewVolumesVolumeTargetValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewVolumesVolumeTargetValueMust(VolumesVolumeTargetValue{}.AttributeTypes(ctx), attributes), nil
}

func (t VolumesVolumeTargetType) ValueType(ctx context.Context) attr.Value {
	return VolumesVolumeTargetValue{}
}

var _ basetypes.ObjectValuable = VolumesVolumeTargetValue{}

type VolumesVolumeTargetValue struct {
	TargetDataStore VolumesVolumeTargetTargetDataStoreValue `tfsdk:"target_data_store" json:"targetDataStore"`
	state           attr.ValueState
}

func (v VolumesVolumeTargetValue) ToCreate() *VolumesVolumeTargetValue {
	res := &VolumesVolumeTargetValue{}

	if !v.TargetDataStore.IsNull() {
		res.TargetDataStore = v.TargetDataStore
	}

	res.state = attr.ValueStateKnown

	return res
}

func (v VolumesVolumeTargetValue) MarshalJSON() ([]byte, error) {
	toMarshal := map[string]any{}
	if !v.TargetDataStore.IsNull() && !v.TargetDataStore.IsUnknown() {
		toMarshal["targetDataStore"] = v.TargetDataStore
	}

	return json.Marshal(toMarshal)
}

func (v *VolumesVolumeTargetValue) UnmarshalJSON(data []byte) error {
	type JsonVolumesVolumeTargetValue VolumesVolumeTargetValue

	var tmp JsonVolumesVolumeTargetValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.TargetDataStore = tmp.TargetDataStore

	v.state = attr.ValueStateKnown

	return nil
}

func (v *VolumesVolumeTargetValue) MergeWith(other *VolumesVolumeTargetValue) {

	if v.TargetDataStore.IsUnknown() && !other.TargetDataStore.IsUnknown() {
		v.TargetDataStore = other.TargetDataStore
	} else if !other.TargetDataStore.IsUnknown() {
		v.TargetDataStore.MergeWith(&other.TargetDataStore)
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v VolumesVolumeTargetValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"targetDataStore": v.TargetDataStore,
	}
}
func (v VolumesVolumeTargetValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["target_data_store"] = basetypes.ObjectType{
		AttrTypes: VolumesVolumeTargetTargetDataStoreValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.TargetDataStore.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["target_data_store"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v VolumesVolumeTargetValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v VolumesVolumeTargetValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v VolumesVolumeTargetValue) String() string {
	return "VolumesVolumeTargetValue"
}

func (v VolumesVolumeTargetValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"target_data_store": VolumesVolumeTargetTargetDataStoreType{
				basetypes.ObjectType{
					AttrTypes: VolumesVolumeTargetTargetDataStoreValue{}.AttributeTypes(ctx),
				},
			},
		},
		map[string]attr.Value{
			"target_data_store": v.TargetDataStore,
		})

	return objVal, diags
}

func (v VolumesVolumeTargetValue) Equal(o attr.Value) bool {
	other, ok := o.(VolumesVolumeTargetValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.TargetDataStore.Equal(other.TargetDataStore) {
		return false
	}

	return true
}

func (v VolumesVolumeTargetValue) Type(ctx context.Context) attr.Type {
	return VolumesVolumeTargetType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v VolumesVolumeTargetValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"target_data_store": VolumesVolumeTargetTargetDataStoreValue{}.Type(ctx),
	}
}

var _ basetypes.ObjectTypable = VolumesVolumeTargetTargetDataStoreType{}

type VolumesVolumeTargetTargetDataStoreType struct {
	basetypes.ObjectType
}

func (t VolumesVolumeTargetTargetDataStoreType) Equal(o attr.Type) bool {
	other, ok := o.(VolumesVolumeTargetTargetDataStoreType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t VolumesVolumeTargetTargetDataStoreType) String() string {
	return "VolumesVolumeTargetTargetDataStoreType"
}

func (t VolumesVolumeTargetTargetDataStoreType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	aliasAttribute, ok := attributes["alias"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`alias is missing from object`)

		return nil, diags
	}

	aliasVal, ok := aliasAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`alias expected to be ovhtypes.TfStringValue, was: %T`, aliasAttribute))
	}

	archiveAttribute, ok := attributes["archive"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`archive is missing from object`)

		return nil, diags
	}

	archiveVal, ok := archiveAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`archive expected to be ovhtypes.TfStringValue, was: %T`, archiveAttribute))
	}

	containerAttribute, ok := attributes["container"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`container is missing from object`)

		return nil, diags
	}

	containerVal, ok := containerAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`container expected to be ovhtypes.TfStringValue, was: %T`, containerAttribute))
	}

	internalAttribute, ok := attributes["internal"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`internal is missing from object`)

		return nil, diags
	}

	internalVal, ok := internalAttribute.(ovhtypes.TfBoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`internal expected to be ovhtypes.TfBoolValue, was: %T`, internalAttribute))
	}

	prefixAttribute, ok := attributes["prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix is missing from object`)

		return nil, diags
	}

	prefixVal, ok := prefixAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix expected to be ovhtypes.TfStringValue, was: %T`, prefixAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return VolumesVolumeTargetTargetDataStoreValue{
		Alias:     aliasVal,
		Archive:   archiveVal,
		Container: containerVal,
		Internal:  internalVal,
		Prefix:    prefixVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewVolumesVolumeTargetTargetDataStoreValueNull() VolumesVolumeTargetTargetDataStoreValue {
	return VolumesVolumeTargetTargetDataStoreValue{
		state: attr.ValueStateNull,
	}
}

func NewVolumesVolumeTargetTargetDataStoreValueUnknown() VolumesVolumeTargetTargetDataStoreValue {
	return VolumesVolumeTargetTargetDataStoreValue{
		state: attr.ValueStateUnknown,
	}
}

func NewVolumesVolumeTargetTargetDataStoreValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (VolumesVolumeTargetTargetDataStoreValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing VolumesVolumeTargetTargetDataStoreValue Attribute Value",
				"While creating a VolumesVolumeTargetTargetDataStoreValue value, a missing attribute value was detected. "+
					"A VolumesVolumeTargetTargetDataStoreValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VolumesVolumeTargetTargetDataStoreValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid VolumesVolumeTargetTargetDataStoreValue Attribute Type",
				"While creating a VolumesVolumeTargetTargetDataStoreValue value, an invalid attribute value was detected. "+
					"A VolumesVolumeTargetTargetDataStoreValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VolumesVolumeTargetTargetDataStoreValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("VolumesVolumeTargetTargetDataStoreValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra VolumesVolumeTargetTargetDataStoreValue Attribute Value",
				"While creating a VolumesVolumeTargetTargetDataStoreValue value, an extra attribute value was detected. "+
					"A VolumesVolumeTargetTargetDataStoreValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra VolumesVolumeTargetTargetDataStoreValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewVolumesVolumeTargetTargetDataStoreValueUnknown(), diags
	}

	aliasAttribute, ok := attributes["alias"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`alias is missing from object`)

		return NewVolumesVolumeTargetTargetDataStoreValueUnknown(), diags
	}

	aliasVal, ok := aliasAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`alias expected to be ovhtypes.TfStringValue, was: %T`, aliasAttribute))
	}

	archiveAttribute, ok := attributes["archive"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`archive is missing from object`)

		return NewVolumesVolumeTargetTargetDataStoreValueUnknown(), diags
	}

	archiveVal, ok := archiveAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`archive expected to be ovhtypes.TfStringValue, was: %T`, archiveAttribute))
	}

	containerAttribute, ok := attributes["container"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`container is missing from object`)

		return NewVolumesVolumeTargetTargetDataStoreValueUnknown(), diags
	}

	containerVal, ok := containerAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`container expected to be ovhtypes.TfStringValue, was: %T`, containerAttribute))
	}

	internalAttribute, ok := attributes["internal"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`internal is missing from object`)

		return NewVolumesVolumeTargetTargetDataStoreValueUnknown(), diags
	}

	internalVal, ok := internalAttribute.(ovhtypes.TfBoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`internal expected to be ovhtypes.TfBoolValue, was: %T`, internalAttribute))
	}

	prefixAttribute, ok := attributes["prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix is missing from object`)

		return NewVolumesVolumeTargetTargetDataStoreValueUnknown(), diags
	}

	prefixVal, ok := prefixAttribute.(ovhtypes.TfStringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix expected to be ovhtypes.TfStringValue, was: %T`, prefixAttribute))
	}

	if diags.HasError() {
		return NewVolumesVolumeTargetTargetDataStoreValueUnknown(), diags
	}

	return VolumesVolumeTargetTargetDataStoreValue{
		Alias:     aliasVal,
		Archive:   archiveVal,
		Container: containerVal,
		Internal:  internalVal,
		Prefix:    prefixVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewVolumesVolumeTargetTargetDataStoreValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) VolumesVolumeTargetTargetDataStoreValue {
	object, diags := NewVolumesVolumeTargetTargetDataStoreValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewVolumesVolumeTargetTargetDataStoreValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t VolumesVolumeTargetTargetDataStoreType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewVolumesVolumeTargetTargetDataStoreValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewVolumesVolumeTargetTargetDataStoreValueUnknown(), nil
	}

	if in.IsNull() {
		return NewVolumesVolumeTargetTargetDataStoreValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewVolumesVolumeTargetTargetDataStoreValueMust(VolumesVolumeTargetTargetDataStoreValue{}.AttributeTypes(ctx), attributes), nil
}

func (t VolumesVolumeTargetTargetDataStoreType) ValueType(ctx context.Context) attr.Value {
	return VolumesVolumeTargetTargetDataStoreValue{}
}

var _ basetypes.ObjectValuable = VolumesVolumeTargetTargetDataStoreValue{}

type VolumesVolumeTargetTargetDataStoreValue struct {
	Alias     ovhtypes.TfStringValue `tfsdk:"alias" json:"alias"`
	Archive   ovhtypes.TfStringValue `tfsdk:"archive" json:"archive"`
	Container ovhtypes.TfStringValue `tfsdk:"container" json:"container"`
	Internal  ovhtypes.TfBoolValue   `tfsdk:"internal" json:"internal"`
	Prefix    ovhtypes.TfStringValue `tfsdk:"prefix" json:"prefix"`
	state     attr.ValueState
}

func (v VolumesVolumeTargetTargetDataStoreValue) ToCreate() *VolumesVolumeTargetTargetDataStoreValue {
	res := &VolumesVolumeTargetTargetDataStoreValue{}

	if !v.Alias.IsNull() {
		res.Alias = v.Alias
	}

	if !v.Archive.IsNull() {
		res.Archive = v.Archive
	}

	if !v.Container.IsNull() {
		res.Container = v.Container
	}

	if !v.Internal.IsNull() {
		res.Internal = v.Internal
	}

	if !v.Prefix.IsNull() {
		res.Prefix = v.Prefix
	}

	res.state = attr.ValueStateKnown

	return res
}

func (v VolumesVolumeTargetTargetDataStoreValue) MarshalJSON() ([]byte, error) {
	toMarshal := map[string]any{}
	if !v.Alias.IsNull() && !v.Alias.IsUnknown() {
		toMarshal["alias"] = v.Alias
	}
	if !v.Archive.IsNull() && !v.Archive.IsUnknown() {
		toMarshal["archive"] = v.Archive
	}
	if !v.Container.IsNull() && !v.Container.IsUnknown() {
		toMarshal["container"] = v.Container
	}
	if !v.Internal.IsNull() && !v.Internal.IsUnknown() {
		toMarshal["internal"] = v.Internal
	}
	if !v.Prefix.IsNull() && !v.Prefix.IsUnknown() {
		toMarshal["prefix"] = v.Prefix
	}

	return json.Marshal(toMarshal)
}

func (v *VolumesVolumeTargetTargetDataStoreValue) UnmarshalJSON(data []byte) error {
	type JsonVolumesVolumeTargetTargetDataStoreValue VolumesVolumeTargetTargetDataStoreValue

	var tmp JsonVolumesVolumeTargetTargetDataStoreValue
	if err := json.Unmarshal(data, &tmp); err != nil {
		return err
	}
	v.Alias = tmp.Alias
	v.Archive = tmp.Archive
	v.Container = tmp.Container
	v.Internal = tmp.Internal
	v.Prefix = tmp.Prefix

	v.state = attr.ValueStateKnown

	return nil
}

func (v *VolumesVolumeTargetTargetDataStoreValue) MergeWith(other *VolumesVolumeTargetTargetDataStoreValue) {

	if (v.Alias.IsUnknown() || v.Alias.IsNull()) && !other.Alias.IsUnknown() {
		v.Alias = other.Alias
	}

	if (v.Archive.IsUnknown() || v.Archive.IsNull()) && !other.Archive.IsUnknown() {
		v.Archive = other.Archive
	}

	if (v.Container.IsUnknown() || v.Container.IsNull()) && !other.Container.IsUnknown() {
		v.Container = other.Container
	}

	if (v.Internal.IsUnknown() || v.Internal.IsNull()) && !other.Internal.IsUnknown() {
		v.Internal = other.Internal
	}

	if (v.Prefix.IsUnknown() || v.Prefix.IsNull()) && !other.Prefix.IsUnknown() {
		v.Prefix = other.Prefix
	}

	if (v.state == attr.ValueStateUnknown || v.state == attr.ValueStateNull) && other.state != attr.ValueStateUnknown {
		v.state = other.state
	}
}

func (v VolumesVolumeTargetTargetDataStoreValue) Attributes() map[string]attr.Value {
	return map[string]attr.Value{
		"alias":     v.Alias,
		"archive":   v.Archive,
		"container": v.Container,
		"internal":  v.Internal,
		"prefix":    v.Prefix,
	}
}
func (v VolumesVolumeTargetTargetDataStoreValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["alias"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["archive"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["container"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["internal"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["prefix"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.Alias.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["alias"] = val

		val, err = v.Archive.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["archive"] = val

		val, err = v.Container.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["container"] = val

		val, err = v.Internal.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["internal"] = val

		val, err = v.Prefix.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["prefix"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v VolumesVolumeTargetTargetDataStoreValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v VolumesVolumeTargetTargetDataStoreValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v VolumesVolumeTargetTargetDataStoreValue) String() string {
	return "VolumesVolumeTargetTargetDataStoreValue"
}

func (v VolumesVolumeTargetTargetDataStoreValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"alias":     ovhtypes.TfStringType{},
			"archive":   ovhtypes.TfStringType{},
			"container": ovhtypes.TfStringType{},
			"internal":  ovhtypes.TfBoolType{},
			"prefix":    ovhtypes.TfStringType{},
		},
		map[string]attr.Value{
			"alias":     v.Alias,
			"archive":   v.Archive,
			"container": v.Container,
			"internal":  v.Internal,
			"prefix":    v.Prefix,
		})

	return objVal, diags
}

func (v VolumesVolumeTargetTargetDataStoreValue) Equal(o attr.Value) bool {
	other, ok := o.(VolumesVolumeTargetTargetDataStoreValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Alias.Equal(other.Alias) {
		return false
	}

	if !v.Archive.Equal(other.Archive) {
		return false
	}

	if !v.Container.Equal(other.Container) {
		return false
	}

	if !v.Internal.Equal(other.Internal) {
		return false
	}

	if !v.Prefix.Equal(other.Prefix) {
		return false
	}

	return true
}

func (v VolumesVolumeTargetTargetDataStoreValue) Type(ctx context.Context) attr.Type {
	return VolumesVolumeTargetTargetDataStoreType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v VolumesVolumeTargetTargetDataStoreValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"alias":     ovhtypes.TfStringType{},
		"archive":   ovhtypes.TfStringType{},
		"container": ovhtypes.TfStringType{},
		"internal":  ovhtypes.TfBoolType{},
		"prefix":    ovhtypes.TfStringType{},
	}
}
